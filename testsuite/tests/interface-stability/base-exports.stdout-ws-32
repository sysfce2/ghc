
module Control.Applicative where
  -- Safety: Trustworthy
  (<$) :: forall (f :: * -> *) a b. GHC.Base.Functor f => a -> f b -> f a
  (<$>) :: forall (f :: * -> *) a b. GHC.Base.Functor f => (a -> b) -> f a -> f b
  (<**>) :: forall (f :: * -> *) a b. Applicative f => f a -> f (a -> b) -> f b
  type Alternative :: (* -> *) -> Constraint
  class Applicative f => Alternative f where
    empty :: forall a. f a
    (<|>) :: forall a. f a -> f a -> f a
    some :: forall a. f a -> f [a]
    many :: forall a. f a -> f [a]
    {-# MINIMAL empty, (<|>) #-}
  type Applicative :: (* -> *) -> Constraint
  class GHC.Base.Functor f => Applicative f where
    pure :: forall a. a -> f a
    (<*>) :: forall a b. f (a -> b) -> f a -> f b
    liftA2 :: forall a b c. (a -> b -> c) -> f a -> f b -> f c
    (*>) :: forall a b. f a -> f b -> f b
    (<*) :: forall a b. f a -> f b -> f a
    {-# MINIMAL pure, ((<*>) | liftA2) #-}
  type role Const representational phantom
  type Const :: forall {k}. * -> k -> *
  newtype Const a b = Const {getConst :: a}
  type role WrappedArrow representational nominal nominal
  type WrappedArrow :: (* -> * -> *) -> * -> * -> *
  newtype WrappedArrow a b c = WrapArrow {unwrapArrow :: a b c}
  type role WrappedMonad representational nominal
  type WrappedMonad :: (* -> *) -> * -> *
  newtype WrappedMonad m a = WrapMonad {unwrapMonad :: m a}
  type ZipList :: * -> *
  newtype ZipList a = ZipList {getZipList :: [a]}
  asum :: forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
  liftA :: forall (f :: * -> *) a b. Applicative f => (a -> b) -> f a -> f b
  liftA3 :: forall (f :: * -> *) a b c d. Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  optional :: forall (f :: * -> *) a. Alternative f => f a -> f (GHC.Maybe.Maybe a)

module Control.Arrow where
  -- Safety: Trustworthy
  (<<<) :: forall {k} (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Control.Category.Category cat => cat b c -> cat a b -> cat a c
  (<<^) :: forall (a :: * -> * -> *) c d b. Arrow a => a c d -> (b -> c) -> a b d
  (>>>) :: forall {k} (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Control.Category.Category cat => cat a b -> cat b c -> cat a c
  (>>^) :: forall (a :: * -> * -> *) b c d. Arrow a => a b c -> (c -> d) -> a b d
  type Arrow :: (* -> * -> *) -> Constraint
  class Control.Category.Category a => Arrow a where
    arr :: forall b c. (b -> c) -> a b c
    first :: forall b c d. a b c -> a (b, d) (c, d)
    second :: forall b c d. a b c -> a (d, b) (d, c)
    (***) :: forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')
    (&&&) :: forall b c c'. a b c -> a b c' -> a b (c, c')
    {-# MINIMAL arr, (first | (***)) #-}
  type ArrowApply :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowApply a where
    app :: forall b c. a (a b c, b) c
    {-# MINIMAL app #-}
  type ArrowChoice :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowChoice a where
    left :: forall b c d. a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
    right :: forall b c d. a b c -> a (Data.Either.Either d b) (Data.Either.Either d c)
    (+++) :: forall b c b' c'. a b c -> a b' c' -> a (Data.Either.Either b b') (Data.Either.Either c c')
    (|||) :: forall b d c. a b d -> a c d -> a (Data.Either.Either b c) d
    {-# MINIMAL (left | (+++)) #-}
  type ArrowLoop :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowLoop a where
    loop :: forall b d c. a (b, d) (c, d) -> a b c
    {-# MINIMAL loop #-}
  type role ArrowMonad representational nominal
  type ArrowMonad :: (* -> * -> *) -> * -> *
  newtype ArrowMonad a b = ArrowMonad (a () b)
  type ArrowPlus :: (* -> * -> *) -> Constraint
  class ArrowZero a => ArrowPlus a where
    (<+>) :: forall b c. a b c -> a b c -> a b c
    {-# MINIMAL (<+>) #-}
  type ArrowZero :: (* -> * -> *) -> Constraint
  class Arrow a => ArrowZero a where
    zeroArrow :: forall b c. a b c
    {-# MINIMAL zeroArrow #-}
  type role Kleisli representational representational nominal
  type Kleisli :: (* -> *) -> * -> * -> *
  newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
  (^<<) :: forall (a :: * -> * -> *) c d b. Arrow a => (c -> d) -> a b c -> a b d
  (^>>) :: forall (a :: * -> * -> *) b c d. Arrow a => (b -> c) -> a c d -> a b d
  leftApp :: forall (a :: * -> * -> *) b c d. ArrowApply a => a b c -> a (Data.Either.Either b d) (Data.Either.Either c d)
  returnA :: forall (a :: * -> * -> *) b. Arrow a => a b b

module Control.Category where
  -- Safety: Trustworthy
  (<<<) :: forall {k} (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
  (>>>) :: forall {k} (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
  type Category :: forall {k}. (k -> k -> *) -> Constraint
  class Category cat where
    id :: forall (a :: k). cat a a
    (.) :: forall (b :: k) (c :: k) (a :: k). cat b c -> cat a b -> cat a c
    {-# MINIMAL id, (.) #-}

module Control.Concurrent where
  -- Safety: Trustworthy
  type Chan :: * -> *
  data Chan a = ...
  type MVar :: * -> *
  data MVar a = ...
  type QSem :: *
  newtype QSem = ...
  type QSemN :: *
  data QSemN = ...
  type ThreadId :: *
  data ThreadId = ...
  addMVarFinalizer :: forall a. MVar a -> GHC.Types.IO () -> GHC.Types.IO ()
  dupChan :: forall a. Chan a -> GHC.Types.IO (Chan a)
  forkFinally :: forall a. GHC.Types.IO a -> (Data.Either.Either GHC.Exception.Type.SomeException a -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkIO :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkIOWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOS :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOSWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOn :: GHC.Types.Int -> GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOnWithUnmask :: GHC.Types.Int -> ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  getChanContents :: forall a. Chan a -> GHC.Types.IO [a]
  getNumCapabilities :: GHC.Types.IO GHC.Types.Int
  isCurrentThreadBound :: GHC.Types.IO GHC.Types.Bool
  isEmptyMVar :: forall a. MVar a -> GHC.Types.IO GHC.Types.Bool
  killThread :: ThreadId -> GHC.Types.IO ()
  mkWeakMVar :: forall a. MVar a -> GHC.Types.IO () -> GHC.Types.IO (GHC.Weak.Weak (MVar a))
  mkWeakThreadId :: ThreadId -> GHC.Types.IO (GHC.Weak.Weak ThreadId)
  modifyMVar :: forall a b. MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked :: forall a b. MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked_ :: forall a. MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  modifyMVar_ :: forall a. MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  myThreadId :: GHC.Types.IO ThreadId
  newChan :: forall a. GHC.Types.IO (Chan a)
  newEmptyMVar :: forall a. GHC.Types.IO (MVar a)
  newMVar :: forall a. a -> GHC.Types.IO (MVar a)
  newQSem :: GHC.Types.Int -> GHC.Types.IO QSem
  newQSemN :: GHC.Types.Int -> GHC.Types.IO QSemN
  putMVar :: forall a. MVar a -> a -> GHC.Types.IO ()
  readChan :: forall a. Chan a -> GHC.Types.IO a
  readMVar :: forall a. MVar a -> GHC.Types.IO a
  rtsSupportsBoundThreads :: GHC.Types.Bool
  runInBoundThread :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  runInUnboundThread :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  setNumCapabilities :: GHC.Types.Int -> GHC.Types.IO ()
  signalQSem :: QSem -> GHC.Types.IO ()
  signalQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()
  swapMVar :: forall a. MVar a -> a -> GHC.Types.IO a
  takeMVar :: forall a. MVar a -> GHC.Types.IO a
  threadCapability :: ThreadId -> GHC.Types.IO (GHC.Types.Int, GHC.Types.Bool)
  threadDelay :: GHC.Types.Int -> GHC.Types.IO ()
  threadWaitRead :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitReadSTM :: System.Posix.Types.Fd -> GHC.Types.IO (GHC.Conc.Sync.STM (), GHC.Types.IO ())
  threadWaitWrite :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitWriteSTM :: System.Posix.Types.Fd -> GHC.Types.IO (GHC.Conc.Sync.STM (), GHC.Types.IO ())
  throwTo :: forall e. GHC.Exception.Type.Exception e => ThreadId -> e -> GHC.Types.IO ()
  tryPutMVar :: forall a. MVar a -> a -> GHC.Types.IO GHC.Types.Bool
  tryReadMVar :: forall a. MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  tryTakeMVar :: forall a. MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  waitQSem :: QSem -> GHC.Types.IO ()
  waitQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()
  withMVar :: forall a b. MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMVarMasked :: forall a b. MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  writeChan :: forall a. Chan a -> a -> GHC.Types.IO ()
  writeList2Chan :: forall a. Chan a -> [a] -> GHC.Types.IO ()
  yield :: GHC.Types.IO ()

module Control.Concurrent.Chan where
  -- Safety: Trustworthy
  type Chan :: * -> *
  data Chan a = ...
  dupChan :: forall a. Chan a -> GHC.Types.IO (Chan a)
  getChanContents :: forall a. Chan a -> GHC.Types.IO [a]
  newChan :: forall a. GHC.Types.IO (Chan a)
  readChan :: forall a. Chan a -> GHC.Types.IO a
  writeChan :: forall a. Chan a -> a -> GHC.Types.IO ()
  writeList2Chan :: forall a. Chan a -> [a] -> GHC.Types.IO ()

module Control.Concurrent.MVar where
  -- Safety: Trustworthy
  type MVar :: * -> *
  data MVar a = ...
  addMVarFinalizer :: forall a. MVar a -> GHC.Types.IO () -> GHC.Types.IO ()
  isEmptyMVar :: forall a. MVar a -> GHC.Types.IO GHC.Types.Bool
  mkWeakMVar :: forall a. MVar a -> GHC.Types.IO () -> GHC.Types.IO (GHC.Weak.Weak (MVar a))
  modifyMVar :: forall a b. MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked :: forall a b. MVar a -> (a -> GHC.Types.IO (a, b)) -> GHC.Types.IO b
  modifyMVarMasked_ :: forall a. MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  modifyMVar_ :: forall a. MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  newEmptyMVar :: forall a. GHC.Types.IO (MVar a)
  newMVar :: forall a. a -> GHC.Types.IO (MVar a)
  putMVar :: forall a. MVar a -> a -> GHC.Types.IO ()
  readMVar :: forall a. MVar a -> GHC.Types.IO a
  swapMVar :: forall a. MVar a -> a -> GHC.Types.IO a
  takeMVar :: forall a. MVar a -> GHC.Types.IO a
  tryPutMVar :: forall a. MVar a -> a -> GHC.Types.IO GHC.Types.Bool
  tryReadMVar :: forall a. MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  tryTakeMVar :: forall a. MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  withMVar :: forall a b. MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMVarMasked :: forall a b. MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b

module Control.Concurrent.QSem where
  -- Safety: Safe
  type QSem :: *
  newtype QSem = ...
  newQSem :: GHC.Types.Int -> GHC.Types.IO QSem
  signalQSem :: QSem -> GHC.Types.IO ()
  waitQSem :: QSem -> GHC.Types.IO ()

module Control.Concurrent.QSemN where
  -- Safety: Trustworthy
  type QSemN :: *
  data QSemN = ...
  newQSemN :: GHC.Types.Int -> GHC.Types.IO QSemN
  signalQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()
  waitQSemN :: QSemN -> GHC.Types.Int -> GHC.Types.IO ()

module Control.Exception where
  -- Safety: Trustworthy
  type AllocationLimitExceeded :: *
  data AllocationLimitExceeded = AllocationLimitExceeded
  type ArithException :: *
  data ArithException = Overflow | Underflow | LossOfPrecision | DivideByZero | Denormal | RatioZeroDenominator
  type ArrayException :: *
  data ArrayException = IndexOutOfBounds GHC.Base.String | UndefinedElement GHC.Base.String
  type AssertionFailed :: *
  newtype AssertionFailed = AssertionFailed GHC.Base.String
  type AsyncException :: *
  data AsyncException = StackOverflow | HeapOverflow | ThreadKilled | UserInterrupt
  type BlockedIndefinitelyOnMVar :: *
  data BlockedIndefinitelyOnMVar = BlockedIndefinitelyOnMVar
  type BlockedIndefinitelyOnSTM :: *
  data BlockedIndefinitelyOnSTM = BlockedIndefinitelyOnSTM
  type CompactionFailed :: *
  newtype CompactionFailed = CompactionFailed GHC.Base.String
  type Deadlock :: *
  data Deadlock = Deadlock
  pattern ErrorCall :: GHC.Base.String -> ErrorCall
  type ErrorCall :: *
  data ErrorCall = ErrorCallWithLocation GHC.Base.String GHC.Base.String
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e where
    toException :: e -> SomeException
    fromException :: SomeException -> GHC.Maybe.Maybe e
    displayException :: e -> GHC.Base.String
    {-# MINIMAL #-}
  type Handler :: * -> *
  data Handler a = forall e. Exception e => Handler (e -> GHC.Types.IO a)
  type IOException :: *
  data IOException = ...
  type MaskingState :: *
  data MaskingState = Unmasked | MaskedInterruptible | MaskedUninterruptible
  type NestedAtomically :: *
  data NestedAtomically = NestedAtomically
  type NoMethodError :: *
  newtype NoMethodError = NoMethodError GHC.Base.String
  type NonTermination :: *
  data NonTermination = NonTermination
  type PatternMatchFail :: *
  newtype PatternMatchFail = PatternMatchFail GHC.Base.String
  type RecConError :: *
  newtype RecConError = RecConError GHC.Base.String
  type RecSelError :: *
  newtype RecSelError = RecSelError GHC.Base.String
  type RecUpdError :: *
  newtype RecUpdError = RecUpdError GHC.Base.String
  type SomeAsyncException :: *
  data SomeAsyncException = forall e. Exception e => SomeAsyncException e
  type SomeException :: *
  data SomeException = forall e. Exception e => SomeException e
  type TypeError :: *
  newtype TypeError = TypeError GHC.Base.String
  allowInterrupt :: GHC.Types.IO ()
  assert :: forall a. GHC.Types.Bool -> a -> a
  asyncExceptionFromException :: forall e. Exception e => SomeException -> GHC.Maybe.Maybe e
  asyncExceptionToException :: forall e. Exception e => e -> SomeException
  bracket :: forall a b c. GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracketOnError :: forall a b c. GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracket_ :: forall a b c. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c -> GHC.Types.IO c
  catch :: forall e a. Exception e => GHC.Types.IO a -> (e -> GHC.Types.IO a) -> GHC.Types.IO a
  catchJust :: forall e b a. Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> (b -> GHC.Types.IO a) -> GHC.Types.IO a
  catches :: forall a. GHC.Types.IO a -> [Handler a] -> GHC.Types.IO a
  evaluate :: forall a. a -> GHC.Types.IO a
  finally :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  getMaskingState :: GHC.Types.IO MaskingState
  handle :: forall e a. Exception e => (e -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  handleJust :: forall e b a. Exception e => (e -> GHC.Maybe.Maybe b) -> (b -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  interruptible :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  ioError :: forall a. GHC.IO.Exception.IOError -> GHC.Types.IO a
  mapException :: forall e1 e2 a. (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
  mask :: forall b. ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  mask_ :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  onException :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throw :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) e. Exception e => e -> a
  throwIO :: forall e a. Exception e => e -> GHC.Types.IO a
  throwTo :: forall e. Exception e => GHC.Conc.Sync.ThreadId -> e -> GHC.Types.IO ()
  try :: forall e a. Exception e => GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either e a)
  tryJust :: forall e b a. Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either b a)
  uninterruptibleMask :: forall b. ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  uninterruptibleMask_ :: forall a. GHC.Types.IO a -> GHC.Types.IO a

module Control.Exception.Base where
  -- Safety: Trustworthy
  type AllocationLimitExceeded :: *
  data AllocationLimitExceeded = AllocationLimitExceeded
  type ArithException :: *
  data ArithException = Overflow | Underflow | LossOfPrecision | DivideByZero | Denormal | RatioZeroDenominator
  type ArrayException :: *
  data ArrayException = IndexOutOfBounds GHC.Base.String | UndefinedElement GHC.Base.String
  type AssertionFailed :: *
  newtype AssertionFailed = AssertionFailed GHC.Base.String
  type AsyncException :: *
  data AsyncException = StackOverflow | HeapOverflow | ThreadKilled | UserInterrupt
  type BlockedIndefinitelyOnMVar :: *
  data BlockedIndefinitelyOnMVar = BlockedIndefinitelyOnMVar
  type BlockedIndefinitelyOnSTM :: *
  data BlockedIndefinitelyOnSTM = BlockedIndefinitelyOnSTM
  type CompactionFailed :: *
  newtype CompactionFailed = CompactionFailed GHC.Base.String
  type Deadlock :: *
  data Deadlock = Deadlock
  pattern ErrorCall :: GHC.Base.String -> ErrorCall
  type ErrorCall :: *
  data ErrorCall = ErrorCallWithLocation GHC.Base.String GHC.Base.String
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e where
    toException :: e -> SomeException
    fromException :: SomeException -> GHC.Maybe.Maybe e
    displayException :: e -> GHC.Base.String
    {-# MINIMAL #-}
  type FixIOException :: *
  data FixIOException = FixIOException
  type IOException :: *
  data IOException = ...
  type MaskingState :: *
  data MaskingState = Unmasked | MaskedInterruptible | MaskedUninterruptible
  type NestedAtomically :: *
  data NestedAtomically = NestedAtomically
  type NoMatchingContinuationPrompt :: *
  data NoMatchingContinuationPrompt = NoMatchingContinuationPrompt
  type NoMethodError :: *
  newtype NoMethodError = NoMethodError GHC.Base.String
  type NonTermination :: *
  data NonTermination = NonTermination
  type PatternMatchFail :: *
  newtype PatternMatchFail = PatternMatchFail GHC.Base.String
  type RecConError :: *
  newtype RecConError = RecConError GHC.Base.String
  type RecSelError :: *
  newtype RecSelError = RecSelError GHC.Base.String
  type RecUpdError :: *
  newtype RecUpdError = RecUpdError GHC.Base.String
  type SomeAsyncException :: *
  data SomeAsyncException = forall e. Exception e => SomeAsyncException e
  type SomeException :: *
  data SomeException = forall e. Exception e => SomeException e
  type TypeError :: *
  newtype TypeError = TypeError GHC.Base.String
  assert :: forall a. GHC.Types.Bool -> a -> a
  asyncExceptionFromException :: forall e. Exception e => SomeException -> GHC.Maybe.Maybe e
  asyncExceptionToException :: forall e. Exception e => e -> SomeException
  bracket :: forall a b c. GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracketOnError :: forall a b c. GHC.Types.IO a -> (a -> GHC.Types.IO b) -> (a -> GHC.Types.IO c) -> GHC.Types.IO c
  bracket_ :: forall a b c. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO c -> GHC.Types.IO c
  catch :: forall e a. Exception e => GHC.Types.IO a -> (e -> GHC.Types.IO a) -> GHC.Types.IO a
  catchJust :: forall e b a. Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> (b -> GHC.Types.IO a) -> GHC.Types.IO a
  evaluate :: forall a. a -> GHC.Types.IO a
  finally :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  getMaskingState :: GHC.Types.IO MaskingState
  handle :: forall e a. Exception e => (e -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  handleJust :: forall e b a. Exception e => (e -> GHC.Maybe.Maybe b) -> (b -> GHC.Types.IO a) -> GHC.Types.IO a -> GHC.Types.IO a
  impossibleConstraintError :: forall (q :: GHC.Types.RuntimeRep) (a :: GHC.Prim.CONSTRAINT q). GHC.Prim.Addr# -=> a
  impossibleError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  ioError :: forall a. GHC.IO.Exception.IOError -> GHC.Types.IO a
  mapException :: forall e1 e2 a. (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
  mask :: forall b. ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  mask_ :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  nestedAtomically :: SomeException
  noMatchingContinuationPrompt :: SomeException
  noMethodBindingError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  nonExhaustiveGuardsError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  nonTermination :: SomeException
  onException :: forall a b. GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  patError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  recConError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  recSelError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  throw :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) e. Exception e => e -> a
  throwIO :: forall e a. Exception e => e -> GHC.Types.IO a
  throwTo :: forall e. Exception e => GHC.Conc.Sync.ThreadId -> e -> GHC.Types.IO ()
  try :: forall e a. Exception e => GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either e a)
  tryJust :: forall e b a. Exception e => (e -> GHC.Maybe.Maybe b) -> GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either b a)
  typeError :: forall (q :: GHC.Types.RuntimeRep) (a :: TYPE q). GHC.Prim.Addr# -> a
  uninterruptibleMask :: forall b. ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO b) -> GHC.Types.IO b
  uninterruptibleMask_ :: forall a. GHC.Types.IO a -> GHC.Types.IO a

module Control.Monad where
  -- Safety: Trustworthy
  (<$!>) :: forall (m :: * -> *) a b. Monad m => (a -> b) -> m a -> m b
  (<=<) :: forall (m :: * -> *) b c a. Monad m => (b -> m c) -> (a -> m b) -> a -> m c
  (=<<) :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> m a -> m b
  (>=>) :: forall (m :: * -> *) a b c. Monad m => (a -> m b) -> (b -> m c) -> a -> m c
  type Functor :: (* -> *) -> Constraint
  class Functor f where
    fmap :: forall a b. (a -> b) -> f a -> f b
    (<$) :: forall a b. a -> f b -> f a
    {-# MINIMAL fmap #-}
  type Monad :: (* -> *) -> Constraint
  class GHC.Base.Applicative m => Monad m where
    (>>=) :: forall a b. m a -> (a -> m b) -> m b
    (>>) :: forall a b. m a -> m b -> m b
    return :: forall a. a -> m a
    {-# MINIMAL (>>=) #-}
  type MonadFail :: (* -> *) -> Constraint
  class Monad m => MonadFail m where
    fail :: forall a. GHC.Base.String -> m a
    {-# MINIMAL fail #-}
  type MonadPlus :: (* -> *) -> Constraint
  class (GHC.Base.Alternative m, Monad m) => MonadPlus m where
    mzero :: forall a. m a
    mplus :: forall a. m a -> m a -> m a
    {-# MINIMAL #-}
  ap :: forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
  filterM :: forall (m :: * -> *) a. GHC.Base.Applicative m => (a -> m GHC.Types.Bool) -> [a] -> m [a]
  foldM :: forall (t :: * -> *) (m :: * -> *) b a. (Data.Foldable.Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
  foldM_ :: forall (t :: * -> *) (m :: * -> *) b a. (Data.Foldable.Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m ()
  forM :: forall (t :: * -> *) (m :: * -> *) a b. (Data.Traversable.Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
  forM_ :: forall (t :: * -> *) (m :: * -> *) a b. (Data.Foldable.Foldable t, Monad m) => t a -> (a -> m b) -> m ()
  forever :: forall (f :: * -> *) a b. GHC.Base.Applicative f => f a -> f b
  guard :: forall (f :: * -> *). GHC.Base.Alternative f => GHC.Types.Bool -> f ()
  join :: forall (m :: * -> *) a. Monad m => m (m a) -> m a
  liftM :: forall (m :: * -> *) a1 r. Monad m => (a1 -> r) -> m a1 -> m r
  liftM2 :: forall (m :: * -> *) a1 a2 r. Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
  liftM3 :: forall (m :: * -> *) a1 a2 a3 r. Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
  liftM4 :: forall (m :: * -> *) a1 a2 a3 a4 r. Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
  liftM5 :: forall (m :: * -> *) a1 a2 a3 a4 a5 r. Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
  mapAndUnzipM :: forall (m :: * -> *) a b c. GHC.Base.Applicative m => (a -> m (b, c)) -> [a] -> m ([b], [c])
  mapM :: forall (t :: * -> *) (m :: * -> *) a b. (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
  mapM_ :: forall (t :: * -> *) (m :: * -> *) a b. (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
  mfilter :: forall (m :: * -> *) a. MonadPlus m => (a -> GHC.Types.Bool) -> m a -> m a
  msum :: forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, MonadPlus m) => t (m a) -> m a
  replicateM :: forall (m :: * -> *) a. GHC.Base.Applicative m => GHC.Types.Int -> m a -> m [a]
  replicateM_ :: forall (m :: * -> *) a. GHC.Base.Applicative m => GHC.Types.Int -> m a -> m ()
  sequence :: forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
  sequence_ :: forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, Monad m) => t (m a) -> m ()
  unless :: forall (f :: * -> *). GHC.Base.Applicative f => GHC.Types.Bool -> f () -> f ()
  void :: forall (f :: * -> *) a. Functor f => f a -> f ()
  when :: forall (f :: * -> *). GHC.Base.Applicative f => GHC.Types.Bool -> f () -> f ()
  zipWithM :: forall (m :: * -> *) a b c. GHC.Base.Applicative m => (a -> b -> m c) -> [a] -> [b] -> m [c]
  zipWithM_ :: forall (m :: * -> *) a b c. GHC.Base.Applicative m => (a -> b -> m c) -> [a] -> [b] -> m ()

module Control.Monad.Fail where
  -- Safety: Trustworthy
  type MonadFail :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadFail m where
    fail :: forall a. GHC.Base.String -> m a
    {-# MINIMAL fail #-}

module Control.Monad.Fix where
  -- Safety: Trustworthy
  type MonadFix :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadFix m where
    mfix :: forall a. (a -> m a) -> m a
    {-# MINIMAL mfix #-}
  fix :: forall a. (a -> a) -> a

module Control.Monad.IO.Class where
  -- Safety: Safe
  type MonadIO :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadIO m where
    liftIO :: forall a. GHC.Types.IO a -> m a
    {-# MINIMAL liftIO #-}

module Control.Monad.Instances where
  -- Safety: Safe
  type Functor :: (* -> *) -> Constraint
  class Functor f where
    fmap :: forall a b. (a -> b) -> f a -> f b
    (<$) :: forall a b. a -> f b -> f a
    {-# MINIMAL fmap #-}
  type Monad :: (* -> *) -> Constraint
  class GHC.Base.Applicative m => Monad m where
    (>>=) :: forall a b. m a -> (a -> m b) -> m b
    (>>) :: forall a b. m a -> m b -> m b
    return :: forall a. a -> m a
    {-# MINIMAL (>>=) #-}

module Control.Monad.ST where
  -- Safety: Trustworthy
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: forall a s. (a -> ST s a) -> ST s a
  runST :: forall a. (forall s. ST s a) -> a
  stToIO :: forall a. ST RealWorld a -> GHC.Types.IO a

module Control.Monad.ST.Lazy where
  -- Safety: Trustworthy
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: forall a s. (a -> ST s a) -> ST s a
  lazyToStrictST :: forall s a. ST s a -> GHC.ST.ST s a
  runST :: forall a. (forall s. ST s a) -> a
  stToIO :: forall a. ST RealWorld a -> GHC.Types.IO a
  strictToLazyST :: forall s a. GHC.ST.ST s a -> ST s a

module Control.Monad.ST.Lazy.Safe where
  -- Safety: Trustworthy
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: forall a s. (a -> ST s a) -> ST s a
  lazyToStrictST :: forall s a. ST s a -> GHC.ST.ST s a
  runST :: forall a. (forall s. ST s a) -> a
  stToIO :: forall a. ST RealWorld a -> GHC.Types.IO a
  strictToLazyST :: forall s a. GHC.ST.ST s a -> ST s a

module Control.Monad.ST.Lazy.Unsafe where
  -- Safety: Unsafe
  unsafeIOToST :: forall a s. GHC.Types.IO a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a
  unsafeInterleaveST :: forall s a. base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a

module Control.Monad.ST.Safe where
  -- Safety: Trustworthy
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: forall a s. (a -> ST s a) -> ST s a
  runST :: forall a. (forall s. ST s a) -> a
  stToIO :: forall a. ST RealWorld a -> GHC.Types.IO a

module Control.Monad.ST.Strict where
  -- Safety: Safe
  type RealWorld :: *
  data RealWorld
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ...
  fixST :: forall a s. (a -> ST s a) -> ST s a
  runST :: forall a. (forall s. ST s a) -> a
  stToIO :: forall a. ST RealWorld a -> GHC.Types.IO a

module Control.Monad.ST.Unsafe where
  -- Safety: Unsafe
  unsafeDupableInterleaveST :: forall s a. GHC.ST.ST s a -> GHC.ST.ST s a
  unsafeIOToST :: forall a s. GHC.Types.IO a -> GHC.ST.ST s a
  unsafeInterleaveST :: forall s a. GHC.ST.ST s a -> GHC.ST.ST s a
  unsafeSTToIO :: forall s a. GHC.ST.ST s a -> GHC.Types.IO a

module Control.Monad.Zip where
  -- Safety: Safe
  type MonadZip :: (* -> *) -> Constraint
  class GHC.Base.Monad m => MonadZip m where
    mzip :: forall a b. m a -> m b -> m (a, b)
    mzipWith :: forall a b c. (a -> b -> c) -> m a -> m b -> m c
    munzip :: forall a b. m (a, b) -> (m a, m b)
    {-# MINIMAL mzip | mzipWith #-}

module Data.Array.Byte where
  -- Safety: Trustworthy
  type ByteArray :: *
  data ByteArray = ByteArray GHC.Prim.ByteArray#
  type role MutableByteArray nominal
  type MutableByteArray :: * -> *
  data MutableByteArray s = MutableByteArray (GHC.Prim.MutableByteArray# s)

module Data.Bifoldable where
  -- Safety: Safe
  type Bifoldable :: (* -> * -> *) -> Constraint
  class Bifoldable p where
    bifold :: forall m. GHC.Base.Monoid m => p m m -> m
    bifoldMap :: forall m a b. GHC.Base.Monoid m => (a -> m) -> (b -> m) -> p a b -> m
    bifoldr :: forall a c b. (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
    bifoldl :: forall c a b. (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c
    {-# MINIMAL bifoldr | bifoldMap #-}
  biList :: forall (t :: * -> * -> *) a. Bifoldable t => t a a -> [a]
  biall :: forall (t :: * -> * -> *) a b. Bifoldable t => (a -> GHC.Types.Bool) -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
  biand :: forall (t :: * -> * -> *). Bifoldable t => t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
  biany :: forall (t :: * -> * -> *) a b. Bifoldable t => (a -> GHC.Types.Bool) -> (b -> GHC.Types.Bool) -> t a b -> GHC.Types.Bool
  biasum :: forall (t :: * -> * -> *) (f :: * -> *) a. (Bifoldable t, GHC.Base.Alternative f) => t (f a) (f a) -> f a
  biconcat :: forall (t :: * -> * -> *) a. Bifoldable t => t [a] [a] -> [a]
  biconcatMap :: forall (t :: * -> * -> *) a c b. Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]
  bielem :: forall (t :: * -> * -> *) a. (Bifoldable t, GHC.Classes.Eq a) => a -> t a a -> GHC.Types.Bool
  bifind :: forall (t :: * -> * -> *) a. Bifoldable t => (a -> GHC.Types.Bool) -> t a a -> GHC.Maybe.Maybe a
  bifoldl' :: forall (t :: * -> * -> *) a b c. Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a
  bifoldl1 :: forall (t :: * -> * -> *) a. Bifoldable t => (a -> a -> a) -> t a a -> a
  bifoldlM :: forall (t :: * -> * -> *) (m :: * -> *) a b c. (Bifoldable t, GHC.Base.Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a
  bifoldr' :: forall (t :: * -> * -> *) a c b. Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c
  bifoldr1 :: forall (t :: * -> * -> *) a. Bifoldable t => (a -> a -> a) -> t a a -> a
  bifoldrM :: forall (t :: * -> * -> *) (m :: * -> *) a c b. (Bifoldable t, GHC.Base.Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c
  biforM_ :: forall (t :: * -> * -> *) (f :: * -> *) a b c d. (Bifoldable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()
  bifor_ :: forall (t :: * -> * -> *) (f :: * -> *) a b c d. (Bifoldable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()
  bilength :: forall (t :: * -> * -> *) a b. Bifoldable t => t a b -> GHC.Types.Int
  bimapM_ :: forall (t :: * -> * -> *) (f :: * -> *) a c b d. (Bifoldable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()
  bimaximum :: forall (t :: * -> * -> *) a. (Bifoldable t, GHC.Classes.Ord a) => t a a -> a
  bimaximumBy :: forall (t :: * -> * -> *) a. Bifoldable t => (a -> a -> GHC.Types.Ordering) -> t a a -> a
  biminimum :: forall (t :: * -> * -> *) a. (Bifoldable t, GHC.Classes.Ord a) => t a a -> a
  biminimumBy :: forall (t :: * -> * -> *) a. Bifoldable t => (a -> a -> GHC.Types.Ordering) -> t a a -> a
  bimsum :: forall (t :: * -> * -> *) (f :: * -> *) a. (Bifoldable t, GHC.Base.Alternative f) => t (f a) (f a) -> f a
  binotElem :: forall (t :: * -> * -> *) a. (Bifoldable t, GHC.Classes.Eq a) => a -> t a a -> GHC.Types.Bool
  binull :: forall (t :: * -> * -> *) a b. Bifoldable t => t a b -> GHC.Types.Bool
  bior :: forall (t :: * -> * -> *). Bifoldable t => t GHC.Types.Bool GHC.Types.Bool -> GHC.Types.Bool
  biproduct :: forall (t :: * -> * -> *) a. (Bifoldable t, GHC.Num.Num a) => t a a -> a
  bisequenceA_ :: forall (t :: * -> * -> *) (f :: * -> *) a b. (Bifoldable t, GHC.Base.Applicative f) => t (f a) (f b) -> f ()
  bisequence_ :: forall (t :: * -> * -> *) (f :: * -> *) a b. (Bifoldable t, GHC.Base.Applicative f) => t (f a) (f b) -> f ()
  bisum :: forall (t :: * -> * -> *) a. (Bifoldable t, GHC.Num.Num a) => t a a -> a
  bitraverse_ :: forall (t :: * -> * -> *) (f :: * -> *) a c b d. (Bifoldable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

module Data.Bifoldable1 where
  -- Safety: Safe
  type Bifoldable1 :: (* -> * -> *) -> Constraint
  class Data.Bifoldable.Bifoldable t => Bifoldable1 t where
    bifold1 :: forall m. GHC.Base.Semigroup m => t m m -> m
    bifoldMap1 :: forall m a b. GHC.Base.Semigroup m => (a -> m) -> (b -> m) -> t a b -> m
    {-# MINIMAL bifoldMap1 #-}

module Data.Bifunctor where
  -- Safety: Safe
  type Bifunctor :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Base.Functor (p a)) => Bifunctor p where
    bimap :: forall a b c d. (a -> b) -> (c -> d) -> p a c -> p b d
    first :: forall a b c. (a -> b) -> p a c -> p b c
    second :: forall b c a. (b -> c) -> p a b -> p a c
    {-# MINIMAL bimap | first, second #-}

module Data.Bitraversable where
  -- Safety: Trustworthy
  type Bitraversable :: (* -> * -> *) -> Constraint
  class (Data.Bifunctor.Bifunctor t, Data.Bifoldable.Bifoldable t) => Bitraversable t where
    bitraverse :: forall (f :: * -> *) a c b d. GHC.Base.Applicative f => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
    {-# MINIMAL bitraverse #-}
  bifoldMapDefault :: forall (t :: * -> * -> *) m a b. (Bitraversable t, GHC.Base.Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
  bifor :: forall (t :: * -> * -> *) (f :: * -> *) a b c d. (Bitraversable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
  biforM :: forall (t :: * -> * -> *) (f :: * -> *) a b c d. (Bitraversable t, GHC.Base.Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)
  bimapAccumL :: forall (t :: * -> * -> *) a b c d e. Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
  bimapAccumR :: forall (t :: * -> * -> *) a b c d e. Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)
  bimapDefault :: forall (t :: * -> * -> *) a b c d. Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d
  bimapM :: forall (t :: * -> * -> *) (f :: * -> *) a c b d. (Bitraversable t, GHC.Base.Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
  bisequence :: forall (t :: * -> * -> *) (f :: * -> *) a b. (Bitraversable t, GHC.Base.Applicative f) => t (f a) (f b) -> f (t a b)
  bisequenceA :: forall (t :: * -> * -> *) (f :: * -> *) a b. (Bitraversable t, GHC.Base.Applicative f) => t (f a) (f b) -> f (t a b)

module Data.Bits where
  -- Safety: Trustworthy
  (!<<.) :: forall a. Bits a => a -> GHC.Types.Int -> a
  (!>>.) :: forall a. Bits a => a -> GHC.Types.Int -> a
  (.<<.) :: forall a. Bits a => a -> GHC.Types.Int -> a
  (.>>.) :: forall a. Bits a => a -> GHC.Types.Int -> a
  (.^.) :: forall a. Bits a => a -> a -> a
  type And :: * -> *
  newtype And a = And {getAnd :: a}
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a where
    (.&.) :: a -> a -> a
    (.|.) :: a -> a -> a
    xor :: a -> a -> a
    complement :: a -> a
    shift :: a -> GHC.Types.Int -> a
    rotate :: a -> GHC.Types.Int -> a
    zeroBits :: a
    bit :: GHC.Types.Int -> a
    setBit :: a -> GHC.Types.Int -> a
    clearBit :: a -> GHC.Types.Int -> a
    complementBit :: a -> GHC.Types.Int -> a
    testBit :: a -> GHC.Types.Int -> GHC.Types.Bool
    bitSizeMaybe :: a -> GHC.Maybe.Maybe GHC.Types.Int
    bitSize :: a -> GHC.Types.Int
    isSigned :: a -> GHC.Types.Bool
    shiftL :: a -> GHC.Types.Int -> a
    unsafeShiftL :: a -> GHC.Types.Int -> a
    shiftR :: a -> GHC.Types.Int -> a
    unsafeShiftR :: a -> GHC.Types.Int -> a
    rotateL :: a -> GHC.Types.Int -> a
    rotateR :: a -> GHC.Types.Int -> a
    popCount :: a -> GHC.Types.Int
    {-# MINIMAL (.&.), (.|.), xor, complement, (shift | (shiftL, shiftR)), (rotate | (rotateL, rotateR)), bitSize, bitSizeMaybe, isSigned, testBit, bit, popCount #-}
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b where
    finiteBitSize :: b -> GHC.Types.Int
    countLeadingZeros :: b -> GHC.Types.Int
    countTrailingZeros :: b -> GHC.Types.Int
    {-# MINIMAL finiteBitSize #-}
  type Iff :: * -> *
  newtype Iff a = Iff {getIff :: a}
  type Ior :: * -> *
  newtype Ior a = Ior {getIor :: a}
  type Xor :: * -> *
  newtype Xor a = Xor {getXor :: a}
  bitDefault :: forall a. (Bits a, GHC.Num.Num a) => GHC.Types.Int -> a
  oneBits :: forall a. FiniteBits a => a
  popCountDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int
  testBitDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int -> GHC.Types.Bool
  toIntegralSized :: forall a b. (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b

module Data.Bool where
  -- Safety: Trustworthy
  (&&) :: Bool -> Bool -> Bool
  type Bool :: *
  data Bool = False | True
  bool :: forall a. a -> a -> Bool -> a
  not :: Bool -> Bool
  otherwise :: Bool
  (||) :: Bool -> Bool -> Bool

module Data.Char where
  -- Safety: Trustworthy
  type Char :: *
  data Char = ...
  type GeneralCategory :: *
  data GeneralCategory = UppercaseLetter | LowercaseLetter | TitlecaseLetter | ModifierLetter | OtherLetter | NonSpacingMark | SpacingCombiningMark | EnclosingMark | DecimalNumber | LetterNumber | OtherNumber | ConnectorPunctuation | DashPunctuation | OpenPunctuation | ClosePunctuation | InitialQuote | FinalQuote | OtherPunctuation | MathSymbol | CurrencySymbol | ModifierSymbol | OtherSymbol | Space | LineSeparator | ParagraphSeparator | Control | Format | Surrogate | PrivateUse | NotAssigned
  chr :: GHC.Types.Int -> Char
  digitToInt :: Char -> GHC.Types.Int
  generalCategory :: Char -> GeneralCategory
  intToDigit :: GHC.Types.Int -> Char
  isAlpha :: Char -> GHC.Types.Bool
  isAlphaNum :: Char -> GHC.Types.Bool
  isAscii :: Char -> GHC.Types.Bool
  isAsciiLower :: Char -> GHC.Types.Bool
  isAsciiUpper :: Char -> GHC.Types.Bool
  isControl :: Char -> GHC.Types.Bool
  isDigit :: Char -> GHC.Types.Bool
  isHexDigit :: Char -> GHC.Types.Bool
  isLatin1 :: Char -> GHC.Types.Bool
  isLetter :: Char -> GHC.Types.Bool
  isLower :: Char -> GHC.Types.Bool
  isLowerCase :: Char -> GHC.Types.Bool
  isMark :: Char -> GHC.Types.Bool
  isNumber :: Char -> GHC.Types.Bool
  isOctDigit :: Char -> GHC.Types.Bool
  isPrint :: Char -> GHC.Types.Bool
  isPunctuation :: Char -> GHC.Types.Bool
  isSeparator :: Char -> GHC.Types.Bool
  isSpace :: Char -> GHC.Types.Bool
  isSymbol :: Char -> GHC.Types.Bool
  isUpper :: Char -> GHC.Types.Bool
  isUpperCase :: Char -> GHC.Types.Bool
  lexLitChar :: Text.ParserCombinators.ReadP.ReadS GHC.Base.String
  ord :: Char -> GHC.Types.Int
  readLitChar :: Text.ParserCombinators.ReadP.ReadS Char
  showLitChar :: Char -> GHC.Show.ShowS
  toLower :: Char -> Char
  toTitle :: Char -> Char
  toUpper :: Char -> Char

module Data.Coerce where
  -- Safety: Unsafe
  type role Coercible representational representational
  type Coercible :: forall k. k -> k -> Constraint
  class Coercible a b => Coercible a b
    {-# MINIMAL #-}
  coerce :: forall {k :: GHC.Types.RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b

module Data.Complex where
  -- Safety: Trustworthy
  type Complex :: * -> *
  data Complex a = !a :+ !a
  cis :: forall a. GHC.Float.Floating a => a -> Complex a
  conjugate :: forall a. GHC.Num.Num a => Complex a -> Complex a
  imagPart :: forall a. Complex a -> a
  magnitude :: forall a. GHC.Float.RealFloat a => Complex a -> a
  mkPolar :: forall a. GHC.Float.Floating a => a -> a -> Complex a
  phase :: forall a. GHC.Float.RealFloat a => Complex a -> a
  polar :: forall a. GHC.Float.RealFloat a => Complex a -> (a, a)
  realPart :: forall a. Complex a -> a

module Data.Data where
  -- Safety: Trustworthy
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    Refl :: forall {k} (a :: k). (:~:) a a
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    HRefl :: forall {k1} (a :: k1). (:~~:) a a
  type ConIndex :: *
  type ConIndex = GHC.Types.Int
  type Constr :: *
  data Constr = ...
  type ConstrRep :: *
  data ConstrRep = AlgConstr ConIndex | IntConstr GHC.Num.Integer.Integer | FloatConstr GHC.Real.Rational | CharConstr GHC.Types.Char
  type Data :: * -> Constraint
  class Typeable a => Data a where
    gfoldl :: forall (c :: * -> *). (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
    gunfold :: forall (c :: * -> *). (forall b r. Data b => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
    toConstr :: a -> Constr
    dataTypeOf :: a -> DataType
    dataCast1 :: forall (t :: * -> *) (c :: * -> *). Typeable t => (forall d. Data d => c (t d)) -> GHC.Maybe.Maybe (c a)
    dataCast2 :: forall (t :: * -> * -> *) (c :: * -> *). Typeable t => (forall d e. (Data d, Data e) => c (t d e)) -> GHC.Maybe.Maybe (c a)
    gmapT :: (forall b. Data b => b -> b) -> a -> a
    gmapQl :: forall r r'. (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
    gmapQr :: forall r r'. (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
    gmapQ :: forall u. (forall d. Data d => d -> u) -> a -> [u]
    gmapQi :: forall u. GHC.Types.Int -> (forall d. Data d => d -> u) -> a -> u
    gmapM :: forall (m :: * -> *). GHC.Base.Monad m => (forall d. Data d => d -> m d) -> a -> m a
    gmapMp :: forall (m :: * -> *). GHC.Base.MonadPlus m => (forall d. Data d => d -> m d) -> a -> m a
    gmapMo :: forall (m :: * -> *). GHC.Base.MonadPlus m => (forall d. Data d => d -> m d) -> a -> m a
    {-# MINIMAL gunfold, toConstr, dataTypeOf #-}
  type DataRep :: *
  data DataRep = AlgRep [Constr] | IntRep | FloatRep | CharRep | NoRep
  type DataType :: *
  data DataType = ...
  type Fixity :: *
  data Fixity = Prefix | Infix
  type role Proxy phantom
  type Proxy :: forall {k}. k -> *
  data Proxy t = Proxy
  type TyCon :: *
  data TyCon = ...
  type TypeRep :: *
  type TypeRep = base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep
  type Typeable :: forall k. k -> Constraint
  class Typeable a where
    ...
    {-# MINIMAL base-4.18.0.0:Data.Typeable.Internal.typeRep# #-}
  cast :: forall a b. (Typeable a, Typeable b) => a -> GHC.Maybe.Maybe b
  constrFields :: Constr -> [GHC.Base.String]
  constrFixity :: Constr -> Fixity
  constrIndex :: Constr -> ConIndex
  constrRep :: Constr -> ConstrRep
  constrType :: Constr -> DataType
  dataTypeConstrs :: DataType -> [Constr]
  dataTypeName :: DataType -> GHC.Base.String
  dataTypeRep :: DataType -> DataRep
  decT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => Data.Either.Either ((a :~: b) -> GHC.Base.Void) (a :~: b)
  eqT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~: b)
  fromConstr :: forall a. Data a => Constr -> a
  fromConstrB :: forall a. Data a => (forall d. Data d => d) -> Constr -> a
  fromConstrM :: forall (m :: * -> *) a. (GHC.Base.Monad m, Data a) => (forall d. Data d => m d) -> Constr -> m a
  funResultTy :: TypeRep -> TypeRep -> GHC.Maybe.Maybe TypeRep
  gcast :: forall {k} (a :: k) (b :: k) (c :: k -> *). (Typeable a, Typeable b) => c a -> GHC.Maybe.Maybe (c b)
  gcast1 :: forall {k1} {k2} (c :: k1 -> *) (t :: k2 -> k1) (t' :: k2 -> k1) (a :: k2). (Typeable t, Typeable t') => c (t a) -> GHC.Maybe.Maybe (c (t' a))
  gcast2 :: forall {k1} {k2} {k3} (c :: k1 -> *) (t :: k2 -> k3 -> k1) (t' :: k2 -> k3 -> k1) (a :: k2) (b :: k3). (Typeable t, Typeable t') => c (t a b) -> GHC.Maybe.Maybe (c (t' a b))
  hdecT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => Data.Either.Either ((a :~~: b) -> GHC.Base.Void) (a :~~: b)
  heqT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~~: b)
  indexConstr :: DataType -> ConIndex -> Constr
  isAlgType :: DataType -> GHC.Types.Bool
  isNorepType :: DataType -> GHC.Types.Bool
  maxConstrIndex :: DataType -> ConIndex
  mkCharConstr :: DataType -> GHC.Types.Char -> Constr
  mkCharType :: GHC.Base.String -> DataType
  mkConstr :: DataType -> GHC.Base.String -> [GHC.Base.String] -> Fixity -> Constr
  mkConstrTag :: DataType -> GHC.Base.String -> GHC.Types.Int -> [GHC.Base.String] -> Fixity -> Constr
  mkDataType :: GHC.Base.String -> [Constr] -> DataType
  mkFloatType :: GHC.Base.String -> DataType
  mkFunTy :: TypeRep -> TypeRep -> TypeRep
  mkIntType :: GHC.Base.String -> DataType
  mkIntegralConstr :: forall a. (GHC.Real.Integral a, GHC.Show.Show a) => DataType -> a -> Constr
  mkNoRepType :: GHC.Base.String -> DataType
  mkRealConstr :: forall a. (GHC.Real.Real a, GHC.Show.Show a) => DataType -> a -> Constr
  readConstr :: DataType -> GHC.Base.String -> GHC.Maybe.Maybe Constr
  repConstr :: DataType -> ConstrRep -> Constr
  rnfTyCon :: TyCon -> ()
  rnfTypeRep :: TypeRep -> ()
  showConstr :: Constr -> GHC.Base.String
  showsTypeRep :: TypeRep -> GHC.Show.ShowS
  splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
  trLiftedRep :: base-4.18.0.0:Data.Typeable.Internal.TypeRep GHC.Types.LiftedRep
  tyConFingerprint :: TyCon -> GHC.Fingerprint.Type.Fingerprint
  tyConModule :: TyCon -> GHC.Base.String
  tyConName :: TyCon -> GHC.Base.String
  tyConPackage :: TyCon -> GHC.Base.String
  tyconModule :: GHC.Base.String -> GHC.Base.String
  tyconUQname :: GHC.Base.String -> GHC.Base.String
  typeOf :: forall a. Typeable a => a -> TypeRep
  typeOf1 :: forall (t :: * -> *) a. Typeable t => t a -> TypeRep
  typeOf2 :: forall (t :: * -> * -> *) a b. Typeable t => t a b -> TypeRep
  typeOf3 :: forall (t :: * -> * -> * -> *) a b c. Typeable t => t a b c -> TypeRep
  typeOf4 :: forall (t :: * -> * -> * -> * -> *) a b c d. Typeable t => t a b c d -> TypeRep
  typeOf5 :: forall (t :: * -> * -> * -> * -> * -> *) a b c d e. Typeable t => t a b c d e -> TypeRep
  typeOf6 :: forall (t :: * -> * -> * -> * -> * -> * -> *) a b c d e f. Typeable t => t a b c d e f -> TypeRep
  typeOf7 :: forall (t :: * -> * -> * -> * -> * -> * -> * -> *) a b c d e f g. Typeable t => t a b c d e f g -> TypeRep
  typeRep :: forall {k} (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
  typeRepArgs :: TypeRep -> [TypeRep]
  typeRepFingerprint :: TypeRep -> GHC.Fingerprint.Type.Fingerprint
  typeRepTyCon :: TypeRep -> TyCon

module Data.Dynamic where
  -- Safety: Trustworthy
  type Dynamic :: *
  data Dynamic where
    Dynamic :: forall a. base-4.18.0.0:Data.Typeable.Internal.TypeRep a -> a -> Dynamic
  type Typeable :: forall k. k -> Constraint
  class Typeable a where
    ...
    {-# MINIMAL base-4.18.0.0:Data.Typeable.Internal.typeRep# #-}
  dynApp :: Dynamic -> Dynamic -> Dynamic
  dynApply :: Dynamic -> Dynamic -> GHC.Maybe.Maybe Dynamic
  dynTypeRep :: Dynamic -> base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep
  fromDyn :: forall a. Typeable a => Dynamic -> a -> a
  fromDynamic :: forall a. Typeable a => Dynamic -> GHC.Maybe.Maybe a
  toDyn :: forall a. Typeable a => a -> Dynamic

module Data.Either where
  -- Safety: Trustworthy
  type Either :: * -> * -> *
  data Either a b = Left a | Right b
  either :: forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
  fromLeft :: forall a b. a -> Either a b -> a
  fromRight :: forall b a. b -> Either a b -> b
  isLeft :: forall a b. Either a b -> GHC.Types.Bool
  isRight :: forall a b. Either a b -> GHC.Types.Bool
  lefts :: forall a b. [Either a b] -> [a]
  partitionEithers :: forall a b. [Either a b] -> ([a], [b])
  rights :: forall a b. [Either a b] -> [b]

module Data.Enum where
  -- Safety: Safe-Inferred
  type Bounded :: * -> Constraint
  class Bounded a where
    minBound :: a
    maxBound :: a
    {-# MINIMAL minBound, maxBound #-}
  type Enum :: * -> Constraint
  class Enum a where
    succ :: a -> a
    pred :: a -> a
    toEnum :: GHC.Types.Int -> a
    fromEnum :: a -> GHC.Types.Int
    enumFrom :: a -> [a]
    enumFromThen :: a -> a -> [a]
    enumFromTo :: a -> a -> [a]
    enumFromThenTo :: a -> a -> a -> [a]
    {-# MINIMAL toEnum, fromEnum #-}

module Data.Eq where
  -- Safety: Trustworthy
  type Eq :: * -> Constraint
  class Eq a where
    (==) :: a -> a -> GHC.Types.Bool
    (/=) :: a -> a -> GHC.Types.Bool
    {-# MINIMAL (==) | (/=) #-}

module Data.Fixed where
  -- Safety: Trustworthy
  type Centi :: *
  type Centi = Fixed E2
  type Deci :: *
  type Deci = Fixed E1
  type E0 :: *
  data E0
  type E1 :: *
  data E1
  type E12 :: *
  data E12
  type E2 :: *
  data E2
  type E3 :: *
  data E3
  type E6 :: *
  data E6
  type E9 :: *
  data E9
  type role Fixed phantom
  type Fixed :: forall k. k -> *
  newtype Fixed a = MkFixed GHC.Num.Integer.Integer
  type HasResolution :: forall k. k -> Constraint
  class HasResolution a where
    resolution :: forall (p :: k -> *). p a -> GHC.Num.Integer.Integer
    {-# MINIMAL resolution #-}
  type Micro :: *
  type Micro = Fixed E6
  type Milli :: *
  type Milli = Fixed E3
  type Nano :: *
  type Nano = Fixed E9
  type Pico :: *
  type Pico = Fixed E12
  type Uni :: *
  type Uni = Fixed E0
  div' :: forall a b. (GHC.Real.Real a, GHC.Real.Integral b) => a -> a -> b
  divMod' :: forall a b. (GHC.Real.Real a, GHC.Real.Integral b) => a -> a -> (b, a)
  mod' :: forall a. GHC.Real.Real a => a -> a -> a
  showFixed :: forall {k} (a :: k). HasResolution a => GHC.Types.Bool -> Fixed a -> GHC.Base.String

module Data.Foldable where
  -- Safety: Trustworthy
  type Foldable :: (* -> *) -> Constraint
  class Foldable t where
    fold :: forall m. GHC.Base.Monoid m => t m -> m
    foldMap :: forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
    foldMap' :: forall m a. GHC.Base.Monoid m => (a -> m) -> t a -> m
    foldr :: forall a b. (a -> b -> b) -> b -> t a -> b
    foldr' :: forall a b. (a -> b -> b) -> b -> t a -> b
    foldl :: forall b a. (b -> a -> b) -> b -> t a -> b
    foldl' :: forall b a. (b -> a -> b) -> b -> t a -> b
    foldr1 :: forall a. (a -> a -> a) -> t a -> a
    foldl1 :: forall a. (a -> a -> a) -> t a -> a
    toList :: forall a. t a -> [a]
    null :: forall a. t a -> GHC.Types.Bool
    length :: forall a. t a -> GHC.Types.Int
    elem :: forall a. GHC.Classes.Eq a => a -> t a -> GHC.Types.Bool
    maximum :: forall a. GHC.Classes.Ord a => t a -> a
    minimum :: forall a. GHC.Classes.Ord a => t a -> a
    sum :: forall a. GHC.Num.Num a => t a -> a
    product :: forall a. GHC.Num.Num a => t a -> a
    {-# MINIMAL foldMap | foldr #-}
  all :: forall (t :: * -> *) a. Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  and :: forall (t :: * -> *). Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  any :: forall (t :: * -> *) a. Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  asum :: forall (t :: * -> *) (f :: * -> *) a. (Foldable t, GHC.Base.Alternative f) => t (f a) -> f a
  concat :: forall (t :: * -> *) a. Foldable t => t [a] -> [a]
  concatMap :: forall (t :: * -> *) a b. Foldable t => (a -> [b]) -> t a -> [b]
  find :: forall (t :: * -> *) a. Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Maybe.Maybe a
  foldlM :: forall (t :: * -> *) (m :: * -> *) b a. (Foldable t, GHC.Base.Monad m) => (b -> a -> m b) -> b -> t a -> m b
  foldrM :: forall (t :: * -> *) (m :: * -> *) a b. (Foldable t, GHC.Base.Monad m) => (a -> b -> m b) -> b -> t a -> m b
  forM_ :: forall (t :: * -> *) (m :: * -> *) a b. (Foldable t, GHC.Base.Monad m) => t a -> (a -> m b) -> m ()
  for_ :: forall (t :: * -> *) (f :: * -> *) a b. (Foldable t, GHC.Base.Applicative f) => t a -> (a -> f b) -> f ()
  mapM_ :: forall (t :: * -> *) (m :: * -> *) a b. (Foldable t, GHC.Base.Monad m) => (a -> m b) -> t a -> m ()
  maximumBy :: forall (t :: * -> *) a. Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  minimumBy :: forall (t :: * -> *) a. Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  msum :: forall (t :: * -> *) (m :: * -> *) a. (Foldable t, GHC.Base.MonadPlus m) => t (m a) -> m a
  notElem :: forall (t :: * -> *) a. (Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  or :: forall (t :: * -> *). Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  sequenceA_ :: forall (t :: * -> *) (f :: * -> *) a. (Foldable t, GHC.Base.Applicative f) => t (f a) -> f ()
  sequence_ :: forall (t :: * -> *) (m :: * -> *) a. (Foldable t, GHC.Base.Monad m) => t (m a) -> m ()
  traverse_ :: forall (t :: * -> *) (f :: * -> *) a b. (Foldable t, GHC.Base.Applicative f) => (a -> f b) -> t a -> f ()

module Data.Foldable1 where
  -- Safety: Trustworthy
  type Foldable1 :: (* -> *) -> Constraint
  class Data.Foldable.Foldable t => Foldable1 t where
    fold1 :: forall m. GHC.Base.Semigroup m => t m -> m
    foldMap1 :: forall m a. GHC.Base.Semigroup m => (a -> m) -> t a -> m
    foldMap1' :: forall m a. GHC.Base.Semigroup m => (a -> m) -> t a -> m
    toNonEmpty :: forall a. t a -> GHC.Base.NonEmpty a
    maximum :: forall a. GHC.Classes.Ord a => t a -> a
    minimum :: forall a. GHC.Classes.Ord a => t a -> a
    head :: forall a. t a -> a
    last :: forall a. t a -> a
    foldrMap1 :: forall a b. (a -> b) -> (a -> b -> b) -> t a -> b
    foldlMap1' :: forall a b. (a -> b) -> (b -> a -> b) -> t a -> b
    foldlMap1 :: forall a b. (a -> b) -> (b -> a -> b) -> t a -> b
    foldrMap1' :: forall a b. (a -> b) -> (a -> b -> b) -> t a -> b
    {-# MINIMAL foldMap1 | foldrMap1 #-}
  foldl1 :: forall (t :: * -> *) a. Foldable1 t => (a -> a -> a) -> t a -> a
  foldl1' :: forall (t :: * -> *) a. Foldable1 t => (a -> a -> a) -> t a -> a
  foldlM1 :: forall (t :: * -> *) (m :: * -> *) a. (Foldable1 t, GHC.Base.Monad m) => (a -> a -> m a) -> t a -> m a
  foldlMapM1 :: forall (t :: * -> *) (m :: * -> *) a b. (Foldable1 t, GHC.Base.Monad m) => (a -> m b) -> (b -> a -> m b) -> t a -> m b
  foldr1 :: forall (t :: * -> *) a. Foldable1 t => (a -> a -> a) -> t a -> a
  foldr1' :: forall (t :: * -> *) a. Foldable1 t => (a -> a -> a) -> t a -> a
  foldrM1 :: forall (t :: * -> *) (m :: * -> *) a. (Foldable1 t, GHC.Base.Monad m) => (a -> a -> m a) -> t a -> m a
  foldrMapM1 :: forall (t :: * -> *) (m :: * -> *) a b. (Foldable1 t, GHC.Base.Monad m) => (a -> m b) -> (a -> b -> m b) -> t a -> m b
  intercalate1 :: forall (t :: * -> *) m. (Foldable1 t, GHC.Base.Semigroup m) => m -> t m -> m
  maximumBy :: forall (t :: * -> *) a. Foldable1 t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  minimumBy :: forall (t :: * -> *) a. Foldable1 t => (a -> a -> GHC.Types.Ordering) -> t a -> a

module Data.Function where
  -- Safety: Trustworthy
  ($) :: forall (repa :: GHC.Types.RuntimeRep) (repb :: GHC.Types.RuntimeRep) (a :: TYPE repa) (b :: TYPE repb). (a -> b) -> a -> b
  (&) :: forall (r :: GHC.Types.RuntimeRep) a (b :: TYPE r). a -> (a -> b) -> b
  (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
  applyWhen :: forall a. GHC.Types.Bool -> (a -> a) -> a -> a
  const :: forall a b. a -> b -> a
  fix :: forall a. (a -> a) -> a
  flip :: forall a b c. (a -> b -> c) -> b -> a -> c
  id :: forall a. a -> a
  on :: forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c

module Data.Functor where
  -- Safety: Trustworthy
  ($>) :: forall (f :: * -> *) a b. Functor f => f a -> b -> f b
  (<$>) :: forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
  (<&>) :: forall (f :: * -> *) a b. Functor f => f a -> (a -> b) -> f b
  type Functor :: (* -> *) -> Constraint
  class Functor f where
    fmap :: forall a b. (a -> b) -> f a -> f b
    (<$) :: forall a b. a -> f b -> f a
    {-# MINIMAL fmap #-}
  unzip :: forall (f :: * -> *) a b. Functor f => f (a, b) -> (f a, f b)
  void :: forall (f :: * -> *) a. Functor f => f a -> f ()

module Data.Functor.Classes where
  -- Safety: Safe
  type Eq1 :: (* -> *) -> Constraint
  class (forall a. GHC.Classes.Eq a => GHC.Classes.Eq (f a)) => Eq1 f where
    liftEq :: forall a b. (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
    default liftEq :: forall (f' :: * -> * -> *) c a b. (f ~ f' c, Eq2 f', GHC.Classes.Eq c) => (a -> b -> GHC.Types.Bool) -> f a -> f b -> GHC.Types.Bool
    {-# MINIMAL #-}
  type Eq2 :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Classes.Eq a => Eq1 (f a)) => Eq2 f where
    liftEq2 :: forall a b c d. (a -> b -> GHC.Types.Bool) -> (c -> d -> GHC.Types.Bool) -> f a c -> f b d -> GHC.Types.Bool
    {-# MINIMAL liftEq2 #-}
  type Ord1 :: (* -> *) -> Constraint
  class (Eq1 f, forall a. GHC.Classes.Ord a => GHC.Classes.Ord (f a)) => Ord1 f where
    liftCompare :: forall a b. (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
    default liftCompare :: forall (f' :: * -> * -> *) c a b. (f ~ f' c, Ord2 f', GHC.Classes.Ord c) => (a -> b -> GHC.Types.Ordering) -> f a -> f b -> GHC.Types.Ordering
    {-# MINIMAL #-}
  type Ord2 :: (* -> * -> *) -> Constraint
  class (Eq2 f, forall a. GHC.Classes.Ord a => Ord1 (f a)) => Ord2 f where
    liftCompare2 :: forall a b c d. (a -> b -> GHC.Types.Ordering) -> (c -> d -> GHC.Types.Ordering) -> f a c -> f b d -> GHC.Types.Ordering
    {-# MINIMAL liftCompare2 #-}
  type Read1 :: (* -> *) -> Constraint
  class (forall a. GHC.Read.Read a => GHC.Read.Read (f a)) => Read1 f where
    liftReadsPrec :: forall a. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
    liftReadList :: forall a. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> Text.ParserCombinators.ReadP.ReadS [f a]
    liftReadPrec :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec (f a)
    liftReadListPrec :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
    {-# MINIMAL liftReadsPrec | liftReadPrec #-}
  type Read2 :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Read.Read a => Read1 (f a)) => Read2 f where
    liftReadsPrec2 :: forall a b. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> Text.ParserCombinators.ReadP.ReadS [b] -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
    liftReadList2 :: forall a b. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> Text.ParserCombinators.ReadP.ReadS [b] -> Text.ParserCombinators.ReadP.ReadS [f a b]
    liftReadPrec2 :: forall a b. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec b -> Text.ParserCombinators.ReadPrec.ReadPrec [b] -> Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
    liftReadListPrec2 :: forall a b. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec b -> Text.ParserCombinators.ReadPrec.ReadPrec [b] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
    {-# MINIMAL liftReadsPrec2 | liftReadPrec2 #-}
  type Show1 :: (* -> *) -> Constraint
  class (forall a. GHC.Show.Show a => GHC.Show.Show (f a)) => Show1 f where
    liftShowsPrec :: forall a. (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> GHC.Types.Int -> f a -> GHC.Show.ShowS
    default liftShowsPrec :: forall (f' :: * -> * -> *) b a. (f ~ f' b, Show2 f', GHC.Show.Show b) => (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> GHC.Types.Int -> f a -> GHC.Show.ShowS
    liftShowList :: forall a. (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> [f a] -> GHC.Show.ShowS
    {-# MINIMAL #-}
  type Show2 :: (* -> * -> *) -> Constraint
  class (forall a. GHC.Show.Show a => Show1 (f a)) => Show2 f where
    liftShowsPrec2 :: forall a b. (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> (GHC.Types.Int -> b -> GHC.Show.ShowS) -> ([b] -> GHC.Show.ShowS) -> GHC.Types.Int -> f a b -> GHC.Show.ShowS
    liftShowList2 :: forall a b. (GHC.Types.Int -> a -> GHC.Show.ShowS) -> ([a] -> GHC.Show.ShowS) -> (GHC.Types.Int -> b -> GHC.Show.ShowS) -> ([b] -> GHC.Show.ShowS) -> [f a b] -> GHC.Show.ShowS
    {-# MINIMAL liftShowsPrec2 #-}
  compare1 :: forall (f :: * -> *) a. (Ord1 f, GHC.Classes.Ord a) => f a -> f a -> GHC.Types.Ordering
  compare2 :: forall (f :: * -> * -> *) a b. (Ord2 f, GHC.Classes.Ord a, GHC.Classes.Ord b) => f a b -> f a b -> GHC.Types.Ordering
  eq1 :: forall (f :: * -> *) a. (Eq1 f, GHC.Classes.Eq a) => f a -> f a -> GHC.Types.Bool
  eq2 :: forall (f :: * -> * -> *) a b. (Eq2 f, GHC.Classes.Eq a, GHC.Classes.Eq b) => f a b -> f a b -> GHC.Types.Bool
  liftReadList2Default :: forall (f :: * -> * -> *) a b. Read2 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> Text.ParserCombinators.ReadP.ReadS [b] -> Text.ParserCombinators.ReadP.ReadS [f a b]
  liftReadListDefault :: forall (f :: * -> *) a. Read1 f => (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> Text.ParserCombinators.ReadP.ReadS [a] -> Text.ParserCombinators.ReadP.ReadS [f a]
  liftReadListPrec2Default :: forall (f :: * -> * -> *) a b. Read2 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec b -> Text.ParserCombinators.ReadPrec.ReadPrec [b] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a b]
  liftReadListPrecDefault :: forall (f :: * -> *) a. Read1 f => Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a] -> Text.ParserCombinators.ReadPrec.ReadPrec [f a]
  readBinaryWith :: forall a b t. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec b -> GHC.Base.String -> (a -> b -> t) -> Text.ParserCombinators.ReadPrec.ReadPrec t
  readData :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readPrec1 :: forall (f :: * -> *) a. (Read1 f, GHC.Read.Read a) => Text.ParserCombinators.ReadPrec.ReadPrec (f a)
  readPrec2 :: forall (f :: * -> * -> *) a b. (Read2 f, GHC.Read.Read a, GHC.Read.Read b) => Text.ParserCombinators.ReadPrec.ReadPrec (f a b)
  readUnaryWith :: forall a t. Text.ParserCombinators.ReadPrec.ReadPrec a -> GHC.Base.String -> (a -> t) -> Text.ParserCombinators.ReadPrec.ReadPrec t
  readsBinary1 :: forall (f :: * -> *) (g :: * -> *) a t. (Read1 f, Read1 g, GHC.Read.Read a) => GHC.Base.String -> (f a -> g a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsBinaryWith :: forall a b t. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS b) -> GHC.Base.String -> (a -> b -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsData :: forall a. (GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS a) -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
  readsPrec1 :: forall (f :: * -> *) a. (Read1 f, GHC.Read.Read a) => GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a)
  readsPrec2 :: forall (f :: * -> * -> *) a b. (Read2 f, GHC.Read.Read a, GHC.Read.Read b) => GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS (f a b)
  readsUnary :: forall a t. GHC.Read.Read a => GHC.Base.String -> (a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsUnary1 :: forall (f :: * -> *) a t. (Read1 f, GHC.Read.Read a) => GHC.Base.String -> (f a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  readsUnaryWith :: forall a t. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> GHC.Base.String -> (a -> t) -> GHC.Base.String -> Text.ParserCombinators.ReadP.ReadS t
  showsBinary1 :: forall (f :: * -> *) (g :: * -> *) a. (Show1 f, Show1 g, GHC.Show.Show a) => GHC.Base.String -> GHC.Types.Int -> f a -> g a -> GHC.Show.ShowS
  showsBinaryWith :: forall a b. (GHC.Types.Int -> a -> GHC.Show.ShowS) -> (GHC.Types.Int -> b -> GHC.Show.ShowS) -> GHC.Base.String -> GHC.Types.Int -> a -> b -> GHC.Show.ShowS
  showsPrec1 :: forall (f :: * -> *) a. (Show1 f, GHC.Show.Show a) => GHC.Types.Int -> f a -> GHC.Show.ShowS
  showsPrec2 :: forall (f :: * -> * -> *) a b. (Show2 f, GHC.Show.Show a, GHC.Show.Show b) => GHC.Types.Int -> f a b -> GHC.Show.ShowS
  showsUnary :: forall a. GHC.Show.Show a => GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS
  showsUnary1 :: forall (f :: * -> *) a. (Show1 f, GHC.Show.Show a) => GHC.Base.String -> GHC.Types.Int -> f a -> GHC.Show.ShowS
  showsUnaryWith :: forall a. (GHC.Types.Int -> a -> GHC.Show.ShowS) -> GHC.Base.String -> GHC.Types.Int -> a -> GHC.Show.ShowS

module Data.Functor.Compose where
  -- Safety: Trustworthy
  type role Compose representational nominal nominal
  type Compose :: forall {k} {k1}. (k -> *) -> (k1 -> k) -> k1 -> *
  newtype Compose f g a = Compose {getCompose :: f (g a)}

module Data.Functor.Const where
  -- Safety: Trustworthy
  type role Const representational phantom
  type Const :: forall {k}. * -> k -> *
  newtype Const a b = Const {getConst :: a}

module Data.Functor.Contravariant where
  -- Safety: Trustworthy
  ($<) :: forall (f :: * -> *) b a. Contravariant f => f b -> b -> f a
  (>$$<) :: forall (f :: * -> *) b a. Contravariant f => f b -> (a -> b) -> f a
  (>$<) :: forall (f :: * -> *) a b. Contravariant f => (a -> b) -> f b -> f a
  type Comparison :: * -> *
  newtype Comparison a = Comparison {getComparison :: a -> a -> GHC.Types.Ordering}
  type Contravariant :: (* -> *) -> Constraint
  class Contravariant f where
    contramap :: forall a' a. (a' -> a) -> f a -> f a'
    (>$) :: forall b a. b -> f b -> f a
    {-# MINIMAL contramap #-}
  type Equivalence :: * -> *
  newtype Equivalence a = Equivalence {getEquivalence :: a -> a -> GHC.Types.Bool}
  type Op :: * -> * -> *
  newtype Op a b = Op {getOp :: b -> a}
  type Predicate :: * -> *
  newtype Predicate a = Predicate {getPredicate :: a -> GHC.Types.Bool}
  comparisonEquivalence :: forall a. Comparison a -> Equivalence a
  defaultComparison :: forall a. GHC.Classes.Ord a => Comparison a
  defaultEquivalence :: forall a. GHC.Classes.Eq a => Equivalence a
  phantom :: forall (f :: * -> *) a b. (GHC.Base.Functor f, Contravariant f) => f a -> f b

module Data.Functor.Identity where
  -- Safety: Trustworthy
  type Identity :: * -> *
  newtype Identity a = Identity {runIdentity :: a}

module Data.Functor.Product where
  -- Safety: Safe
  type role Product representational representational nominal
  type Product :: forall {k}. (k -> *) -> (k -> *) -> k -> *
  data Product f g a = Pair (f a) (g a)

module Data.Functor.Sum where
  -- Safety: Safe
  type role Sum representational representational nominal
  type Sum :: forall {k}. (k -> *) -> (k -> *) -> k -> *
  data Sum f g a = InL (f a) | InR (g a)

module Data.IORef where
  -- Safety: Trustworthy
  type IORef :: * -> *
  newtype IORef a = ...
  atomicModifyIORef :: forall a b. IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicModifyIORef' :: forall a b. IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicWriteIORef :: forall a. IORef a -> a -> GHC.Types.IO ()
  mkWeakIORef :: forall a. IORef a -> GHC.Types.IO () -> GHC.Types.IO (GHC.Weak.Weak (IORef a))
  modifyIORef :: forall a. IORef a -> (a -> a) -> GHC.Types.IO ()
  modifyIORef' :: forall a. IORef a -> (a -> a) -> GHC.Types.IO ()
  newIORef :: forall a. a -> GHC.Types.IO (IORef a)
  readIORef :: forall a. IORef a -> GHC.Types.IO a
  writeIORef :: forall a. IORef a -> a -> GHC.Types.IO ()

module Data.Int where
  -- Safety: Trustworthy
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...

module Data.Ix where
  -- Safety: Trustworthy
  type Ix :: * -> Constraint
  class GHC.Classes.Ord a => Ix a where
    range :: (a, a) -> [a]
    index :: (a, a) -> a -> GHC.Types.Int
    ...
    inRange :: (a, a) -> a -> GHC.Types.Bool
    rangeSize :: (a, a) -> GHC.Types.Int
    ...
    {-# MINIMAL range, (index | GHC.Ix.unsafeIndex), inRange #-}

module Data.Kind where
  -- Safety: Trustworthy
  type Constraint :: *
  type Constraint = GHC.Prim.CONSTRAINT GHC.Types.LiftedRep
  type role FUN nominal representational representational
  type FUN :: forall (n :: GHC.Types.Multiplicity) -> forall {q :: GHC.Types.RuntimeRep} {r :: GHC.Types.RuntimeRep}. TYPE q -> TYPE r -> *
  data FUN n a b
  type Type :: *
  type Type = TYPE GHC.Types.LiftedRep

module Data.List where
  -- Safety: Trustworthy
  (!!) :: forall a. GHC.Stack.Types.HasCallStack => [a] -> GHC.Types.Int -> a
  (!?) :: forall a. [a] -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. [a] -> [a] -> [a]
  (\\) :: forall a. GHC.Classes.Eq a => [a] -> [a] -> [a]
  all :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  and :: forall (t :: * -> *). Data.Foldable.Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  any :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
  break :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  concat :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t [a] -> [a]
  concatMap :: forall (t :: * -> *) a b. Data.Foldable.Foldable t => (a -> [b]) -> t a -> [b]
  cycle :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  delete :: forall a. GHC.Classes.Eq a => a -> [a] -> [a]
  deleteBy :: forall a. (a -> a -> GHC.Types.Bool) -> a -> [a] -> [a]
  deleteFirstsBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  drop :: forall a. GHC.Types.Int -> [a] -> [a]
  dropWhile :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  dropWhileEnd :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  elem :: forall (t :: * -> *) a. (Data.Foldable.Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  elemIndex :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall a. GHC.Classes.Eq a => a -> [a] -> [GHC.Types.Int]
  filter :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  find :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Maybe.Maybe a
  findIndex :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall a. (a -> GHC.Types.Bool) -> [a] -> [GHC.Types.Int]
  foldl :: forall (t :: * -> *) b a. Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl' :: forall (t :: * -> *) b a. Data.Foldable.Foldable t => (b -> a -> b) -> b -> t a -> b
  foldl1 :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> a -> a) -> t a -> a
  foldl1' :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldr :: forall (t :: * -> *) a b. Data.Foldable.Foldable t => (a -> b -> b) -> b -> t a -> b
  foldr1 :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> a -> a) -> t a -> a
  genericDrop :: forall i a. GHC.Real.Integral i => i -> [a] -> [a]
  genericIndex :: forall i a. GHC.Real.Integral i => [a] -> i -> a
  genericLength :: forall i a. GHC.Num.Num i => [a] -> i
  genericReplicate :: forall i a. GHC.Real.Integral i => i -> a -> [a]
  genericSplitAt :: forall i a. GHC.Real.Integral i => i -> [a] -> ([a], [a])
  genericTake :: forall i a. GHC.Real.Integral i => i -> [a] -> [a]
  group :: forall a. GHC.Classes.Eq a => [a] -> [[a]]
  groupBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [[a]]
  head :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  init :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  inits :: forall a. [a] -> [[a]]
  insert :: forall a. GHC.Classes.Ord a => a -> [a] -> [a]
  insertBy :: forall a. (a -> a -> GHC.Types.Ordering) -> a -> [a] -> [a]
  intercalate :: forall a. [a] -> [[a]] -> [a]
  intersect :: forall a. GHC.Classes.Eq a => [a] -> [a] -> [a]
  intersectBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  intersperse :: forall a. a -> [a] -> [a]
  isInfixOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isPrefixOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isSubsequenceOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isSuffixOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  iterate :: forall a. (a -> a) -> a -> [a]
  iterate' :: forall a. (a -> a) -> a -> [a]
  last :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  length :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t a -> GHC.Types.Int
  lines :: GHC.Base.String -> [GHC.Base.String]
  lookup :: forall a b. GHC.Classes.Eq a => a -> [(a, b)] -> GHC.Maybe.Maybe b
  map :: forall a b. (a -> b) -> [a] -> [b]
  mapAccumL :: forall (t :: * -> *) s a b. Data.Traversable.Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  mapAccumR :: forall (t :: * -> *) s a b. Data.Traversable.Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  maximum :: forall (t :: * -> *) a. (Data.Foldable.Foldable t, GHC.Classes.Ord a) => t a -> a
  maximumBy :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  minimum :: forall (t :: * -> *) a. (Data.Foldable.Foldable t, GHC.Classes.Ord a) => t a -> a
  minimumBy :: forall (t :: * -> *) a. Data.Foldable.Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
  notElem :: forall (t :: * -> *) a. (Data.Foldable.Foldable t, GHC.Classes.Eq a) => a -> t a -> GHC.Types.Bool
  nub :: forall a. GHC.Classes.Eq a => [a] -> [a]
  nubBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a]
  null :: forall (t :: * -> *) a. Data.Foldable.Foldable t => t a -> GHC.Types.Bool
  or :: forall (t :: * -> *). Data.Foldable.Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
  partition :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  permutations :: forall a. [a] -> [[a]]
  product :: forall (t :: * -> *) a. (Data.Foldable.Foldable t, GHC.Num.Num a) => t a -> a
  repeat :: forall a. a -> [a]
  replicate :: forall a. GHC.Types.Int -> a -> [a]
  reverse :: forall a. [a] -> [a]
  scanl :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl' :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
  scanr :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: forall a. (a -> a -> a) -> [a] -> [a]
  singleton :: forall a. a -> [a]
  sort :: forall a. GHC.Classes.Ord a => [a] -> [a]
  sortBy :: forall a. (a -> a -> GHC.Types.Ordering) -> [a] -> [a]
  sortOn :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
  span :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
  stripPrefix :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Maybe.Maybe [a]
  subsequences :: forall a. [a] -> [[a]]
  sum :: forall (t :: * -> *) a. (Data.Foldable.Foldable t, GHC.Num.Num a) => t a -> a
  tail :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  tails :: forall a. [a] -> [[a]]
  take :: forall a. GHC.Types.Int -> [a] -> [a]
  takeWhile :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  transpose :: forall a. [[a]] -> [[a]]
  uncons :: forall a. [a] -> GHC.Maybe.Maybe (a, [a])
  unfoldr :: forall b a. (b -> GHC.Maybe.Maybe (a, b)) -> b -> [a]
  union :: forall a. GHC.Classes.Eq a => [a] -> [a] -> [a]
  unionBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  unlines :: [GHC.Base.String] -> GHC.Base.String
  unsnoc :: forall a. [a] -> GHC.Maybe.Maybe ([a], a)
  unwords :: [GHC.Base.String] -> GHC.Base.String
  unzip :: forall a b. [(a, b)] -> ([a], [b])
  unzip3 :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
  unzip4 :: forall a b c d. [(a, b, c, d)] -> ([a], [b], [c], [d])
  unzip5 :: forall a b c d e. [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
  unzip6 :: forall a b c d e f. [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
  unzip7 :: forall a b c d e f g. [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
  words :: GHC.Base.String -> [GHC.Base.String]
  zip :: forall a b. [a] -> [b] -> [(a, b)]
  zip3 :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
  zip4 :: forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
  zip5 :: forall a b c d e. [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
  zip6 :: forall a b c d e f. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
  zip7 :: forall a b c d e f g. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
  zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
  zipWith4 :: forall a b c d e. (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
  zipWith5 :: forall a b c d e f. (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
  zipWith6 :: forall a b c d e f g. (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
  zipWith7 :: forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

module Data.List.NonEmpty where
  -- Safety: Trustworthy
  (!!) :: forall a. GHC.Stack.Types.HasCallStack => NonEmpty a -> GHC.Types.Int -> a
  (<|) :: forall a. a -> NonEmpty a -> NonEmpty a
  type NonEmpty :: * -> *
  data NonEmpty a = a :| [a]
  append :: forall a. NonEmpty a -> NonEmpty a -> NonEmpty a
  appendList :: forall a. NonEmpty a -> [a] -> NonEmpty a
  break :: forall a. (a -> GHC.Types.Bool) -> NonEmpty a -> ([a], [a])
  cons :: forall a. a -> NonEmpty a -> NonEmpty a
  cycle :: forall a. NonEmpty a -> NonEmpty a
  drop :: forall a. GHC.Types.Int -> NonEmpty a -> [a]
  dropWhile :: forall a. (a -> GHC.Types.Bool) -> NonEmpty a -> [a]
  filter :: forall a. (a -> GHC.Types.Bool) -> NonEmpty a -> [a]
  fromList :: forall a. GHC.Stack.Types.HasCallStack => [a] -> NonEmpty a
  group :: forall (f :: * -> *) a. (Data.Foldable.Foldable f, GHC.Classes.Eq a) => f a -> [NonEmpty a]
  group1 :: forall a. GHC.Classes.Eq a => NonEmpty a -> NonEmpty (NonEmpty a)
  groupAllWith :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [NonEmpty a]
  groupAllWith1 :: forall b a. GHC.Classes.Ord b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)
  groupBy :: forall (f :: * -> *) a. Data.Foldable.Foldable f => (a -> a -> GHC.Types.Bool) -> f a -> [NonEmpty a]
  groupBy1 :: forall a. (a -> a -> GHC.Types.Bool) -> NonEmpty a -> NonEmpty (NonEmpty a)
  groupWith :: forall (f :: * -> *) b a. (Data.Foldable.Foldable f, GHC.Classes.Eq b) => (a -> b) -> f a -> [NonEmpty a]
  groupWith1 :: forall b a. GHC.Classes.Eq b => (a -> b) -> NonEmpty a -> NonEmpty (NonEmpty a)
  head :: forall a. NonEmpty a -> a
  init :: forall a. NonEmpty a -> [a]
  inits :: forall (f :: * -> *) a. Data.Foldable.Foldable f => f a -> NonEmpty [a]
  inits1 :: forall a. NonEmpty a -> NonEmpty (NonEmpty a)
  insert :: forall (f :: * -> *) a. (Data.Foldable.Foldable f, GHC.Classes.Ord a) => a -> f a -> NonEmpty a
  intersperse :: forall a. a -> NonEmpty a -> NonEmpty a
  isPrefixOf :: forall a. GHC.Classes.Eq a => [a] -> NonEmpty a -> GHC.Types.Bool
  iterate :: forall a. (a -> a) -> a -> NonEmpty a
  last :: forall a. NonEmpty a -> a
  length :: forall a. NonEmpty a -> GHC.Types.Int
  map :: forall a b. (a -> b) -> NonEmpty a -> NonEmpty b
  nonEmpty :: forall a. [a] -> GHC.Maybe.Maybe (NonEmpty a)
  nub :: forall a. GHC.Classes.Eq a => NonEmpty a -> NonEmpty a
  nubBy :: forall a. (a -> a -> GHC.Types.Bool) -> NonEmpty a -> NonEmpty a
  partition :: forall a. (a -> GHC.Types.Bool) -> NonEmpty a -> ([a], [a])
  prependList :: forall a. [a] -> NonEmpty a -> NonEmpty a
  repeat :: forall a. a -> NonEmpty a
  reverse :: forall a. NonEmpty a -> NonEmpty a
  scanl :: forall (f :: * -> *) b a. Data.Foldable.Foldable f => (b -> a -> b) -> b -> f a -> NonEmpty b
  scanl1 :: forall a. (a -> a -> a) -> NonEmpty a -> NonEmpty a
  scanr :: forall (f :: * -> *) a b. Data.Foldable.Foldable f => (a -> b -> b) -> b -> f a -> NonEmpty b
  scanr1 :: forall a. (a -> a -> a) -> NonEmpty a -> NonEmpty a
  singleton :: forall a. a -> NonEmpty a
  some1 :: forall (f :: * -> *) a. GHC.Base.Alternative f => f a -> f (NonEmpty a)
  sort :: forall a. GHC.Classes.Ord a => NonEmpty a -> NonEmpty a
  sortBy :: forall a. (a -> a -> GHC.Types.Ordering) -> NonEmpty a -> NonEmpty a
  sortWith :: forall o a. GHC.Classes.Ord o => (a -> o) -> NonEmpty a -> NonEmpty a
  span :: forall a. (a -> GHC.Types.Bool) -> NonEmpty a -> ([a], [a])
  splitAt :: forall a. GHC.Types.Int -> NonEmpty a -> ([a], [a])
  tail :: forall a. NonEmpty a -> [a]
  tails :: forall (f :: * -> *) a. Data.Foldable.Foldable f => f a -> NonEmpty [a]
  tails1 :: forall a. NonEmpty a -> NonEmpty (NonEmpty a)
  take :: forall a. GHC.Types.Int -> NonEmpty a -> [a]
  takeWhile :: forall a. (a -> GHC.Types.Bool) -> NonEmpty a -> [a]
  toList :: forall a. NonEmpty a -> [a]
  transpose :: forall a. NonEmpty (NonEmpty a) -> NonEmpty (NonEmpty a)
  uncons :: forall a. NonEmpty a -> (a, GHC.Maybe.Maybe (NonEmpty a))
  unfold :: forall a b. (a -> (b, GHC.Maybe.Maybe a)) -> a -> NonEmpty b
  unfoldr :: forall a b. (a -> (b, GHC.Maybe.Maybe a)) -> a -> NonEmpty b
  unzip :: forall (f :: * -> *) a b. GHC.Base.Functor f => f (a, b) -> (f a, f b)
  xor :: NonEmpty GHC.Types.Bool -> GHC.Types.Bool
  zip :: forall a b. NonEmpty a -> NonEmpty b -> NonEmpty (a, b)
  zipWith :: forall a b c. (a -> b -> c) -> NonEmpty a -> NonEmpty b -> NonEmpty c

module Data.Maybe where
  -- Safety: Trustworthy
  type Maybe :: * -> *
  data Maybe a = Nothing | Just a
  catMaybes :: forall a. [Maybe a] -> [a]
  fromJust :: forall a. GHC.Stack.Types.HasCallStack => Maybe a -> a
  fromMaybe :: forall a. a -> Maybe a -> a
  isJust :: forall a. Maybe a -> GHC.Types.Bool
  isNothing :: forall a. Maybe a -> GHC.Types.Bool
  listToMaybe :: forall a. [a] -> Maybe a
  mapMaybe :: forall a b. (a -> Maybe b) -> [a] -> [b]
  maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
  maybeToList :: forall a. Maybe a -> [a]

module Data.Monoid where
  -- Safety: Trustworthy
  (<>) :: forall a. GHC.Base.Semigroup a => a -> a -> a
  type All :: *
  newtype All = All {getAll :: GHC.Types.Bool}
  type role Alt representational nominal
  type Alt :: forall {k}. (k -> *) -> k -> *
  newtype Alt f a = Alt {getAlt :: f a}
  type Any :: *
  newtype Any = Any {getAny :: GHC.Types.Bool}
  type role Ap representational nominal
  type Ap :: forall {k}. (k -> *) -> k -> *
  newtype Ap f a = Ap {getAp :: f a}
  type Dual :: * -> *
  newtype Dual a = Dual {getDual :: a}
  type Endo :: * -> *
  newtype Endo a = Endo {appEndo :: a -> a}
  type First :: * -> *
  newtype First a = First {getFirst :: GHC.Maybe.Maybe a}
  type Last :: * -> *
  newtype Last a = Last {getLast :: GHC.Maybe.Maybe a}
  type Monoid :: * -> Constraint
  class GHC.Base.Semigroup a => Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    mconcat :: [a] -> a
    {-# MINIMAL mempty | mconcat #-}
  type Product :: * -> *
  newtype Product a = Product {getProduct :: a}
  type Sum :: * -> *
  newtype Sum a = Sum {getSum :: a}

module Data.Ord where
  -- Safety: Trustworthy
  type Down :: * -> *
  newtype Down a = Down {getDown :: a}
  type Ord :: * -> Constraint
  class GHC.Classes.Eq a => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> GHC.Types.Bool
    (<=) :: a -> a -> GHC.Types.Bool
    (>) :: a -> a -> GHC.Types.Bool
    (>=) :: a -> a -> GHC.Types.Bool
    max :: a -> a -> a
    min :: a -> a -> a
    {-# MINIMAL compare | (<=) #-}
  type Ordering :: *
  data Ordering = LT | EQ | GT
  clamp :: forall a. Ord a => (a, a) -> a -> a
  comparing :: forall a b. Ord a => (b -> a) -> b -> b -> Ordering

module Data.Proxy where
  -- Safety: Trustworthy
  type role KProxy phantom
  type KProxy :: * -> *
  data KProxy t = KProxy
  type role Proxy phantom
  type Proxy :: forall {k}. k -> *
  data Proxy t = Proxy
  asProxyTypeOf :: forall a (proxy :: * -> *). a -> proxy a -> a

module Data.Ratio where
  -- Safety: Safe
  (%) :: forall a. GHC.Real.Integral a => a -> a -> Ratio a
  type Ratio :: * -> *
  data Ratio a = ...
  type Rational :: *
  type Rational = Ratio GHC.Num.Integer.Integer
  approxRational :: forall a. GHC.Real.RealFrac a => a -> a -> Rational
  denominator :: forall a. Ratio a -> a
  numerator :: forall a. Ratio a -> a

module Data.STRef where
  -- Safety: Trustworthy
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  modifySTRef :: forall s a. STRef s a -> (a -> a) -> GHC.ST.ST s ()
  modifySTRef' :: forall s a. STRef s a -> (a -> a) -> GHC.ST.ST s ()
  newSTRef :: forall a s. a -> GHC.ST.ST s (STRef s a)
  readSTRef :: forall s a. STRef s a -> GHC.ST.ST s a
  writeSTRef :: forall s a. STRef s a -> a -> GHC.ST.ST s ()

module Data.STRef.Lazy where
  -- Safety: Safe
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  modifySTRef :: forall s a. STRef s a -> (a -> a) -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s ()
  newSTRef :: forall a s. a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s (STRef s a)
  readSTRef :: forall s a. STRef s a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s a
  writeSTRef :: forall s a. STRef s a -> a -> base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s ()

module Data.STRef.Strict where
  -- Safety: Safe
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = ...
  modifySTRef :: forall s a. STRef s a -> (a -> a) -> GHC.ST.ST s ()
  modifySTRef' :: forall s a. STRef s a -> (a -> a) -> GHC.ST.ST s ()
  newSTRef :: forall a s. a -> GHC.ST.ST s (STRef s a)
  readSTRef :: forall s a. STRef s a -> GHC.ST.ST s a
  writeSTRef :: forall s a. STRef s a -> a -> GHC.ST.ST s ()

module Data.Semigroup where
  -- Safety: Trustworthy
  type All :: *
  newtype All = All {getAll :: GHC.Types.Bool}
  type Any :: *
  newtype Any = Any {getAny :: GHC.Types.Bool}
  type Arg :: * -> * -> *
  data Arg a b = Arg a b
  type ArgMax :: * -> * -> *
  type ArgMax a b = Max (Arg a b)
  type ArgMin :: * -> * -> *
  type ArgMin a b = Min (Arg a b)
  type Dual :: * -> *
  newtype Dual a = Dual {getDual :: a}
  type Endo :: * -> *
  newtype Endo a = Endo {appEndo :: a -> a}
  type First :: * -> *
  newtype First a = First {getFirst :: a}
  type Last :: * -> *
  newtype Last a = Last {getLast :: a}
  type Max :: * -> *
  newtype Max a = Max {getMax :: a}
  type Min :: * -> *
  newtype Min a = Min {getMin :: a}
  type Product :: * -> *
  newtype Product a = Product {getProduct :: a}
  type Semigroup :: * -> Constraint
  class Semigroup a where
    (<>) :: a -> a -> a
    sconcat :: GHC.Base.NonEmpty a -> a
    stimes :: forall b. GHC.Real.Integral b => b -> a -> a
    {-# MINIMAL (<>) | sconcat #-}
  type Sum :: * -> *
  newtype Sum a = Sum {getSum :: a}
  type WrappedMonoid :: * -> *
  newtype WrappedMonoid m = WrapMonoid {unwrapMonoid :: m}
  cycle1 :: forall m. Semigroup m => m -> m
  diff :: forall m. Semigroup m => m -> Endo m
  mtimesDefault :: forall b a. (GHC.Real.Integral b, GHC.Base.Monoid a) => b -> a -> a
  stimesIdempotent :: forall b a. GHC.Real.Integral b => b -> a -> a
  stimesIdempotentMonoid :: forall b a. (GHC.Real.Integral b, GHC.Base.Monoid a) => b -> a -> a
  stimesMonoid :: forall b a. (GHC.Real.Integral b, GHC.Base.Monoid a) => b -> a -> a

module Data.String where
  -- Safety: Trustworthy
  type IsString :: * -> Constraint
  class IsString a where
    fromString :: String -> a
    {-# MINIMAL fromString #-}
  type String :: *
  type String = [GHC.Types.Char]
  lines :: String -> [String]
  unlines :: [String] -> String
  unwords :: [String] -> String
  words :: String -> [String]

module Data.Traversable where
  -- Safety: Trustworthy
  type Traversable :: (* -> *) -> Constraint
  class (GHC.Base.Functor t, Data.Foldable.Foldable t) => Traversable t where
    traverse :: forall (f :: * -> *) a b. GHC.Base.Applicative f => (a -> f b) -> t a -> f (t b)
    sequenceA :: forall (f :: * -> *) a. GHC.Base.Applicative f => t (f a) -> f (t a)
    mapM :: forall (m :: * -> *) a b. GHC.Base.Monad m => (a -> m b) -> t a -> m (t b)
    sequence :: forall (m :: * -> *) a. GHC.Base.Monad m => t (m a) -> m (t a)
    {-# MINIMAL traverse | sequenceA #-}
  fmapDefault :: forall (t :: * -> *) a b. Traversable t => (a -> b) -> t a -> t b
  foldMapDefault :: forall (t :: * -> *) m a. (Traversable t, GHC.Base.Monoid m) => (a -> m) -> t a -> m
  for :: forall (t :: * -> *) (f :: * -> *) a b. (Traversable t, GHC.Base.Applicative f) => t a -> (a -> f b) -> f (t b)
  forAccumM :: forall (m :: * -> *) (t :: * -> *) s a b. (GHC.Base.Monad m, Traversable t) => s -> t a -> (s -> a -> m (s, b)) -> m (s, t b)
  forM :: forall (t :: * -> *) (m :: * -> *) a b. (Traversable t, GHC.Base.Monad m) => t a -> (a -> m b) -> m (t b)
  mapAccumL :: forall (t :: * -> *) s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)
  mapAccumM :: forall (m :: * -> *) (t :: * -> *) s a b. (GHC.Base.Monad m, Traversable t) => (s -> a -> m (s, b)) -> s -> t a -> m (s, t b)
  mapAccumR :: forall (t :: * -> *) s a b. Traversable t => (s -> a -> (s, b)) -> s -> t a -> (s, t b)

module Data.Tuple where
  -- Safety: Trustworthy
  pattern Solo :: forall a. a -> Solo a
  type Solo :: * -> *
  data Solo a = MkSolo a
  curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
  fst :: forall a b. (a, b) -> a
  getSolo :: forall a. Solo a -> a
  snd :: forall a b. (a, b) -> b
  swap :: forall a b. (a, b) -> (b, a)
  uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c

module Data.Type.Bool where
  -- Safety: Safe
  type (&&) :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  type family (&&) a b where
    forall (a :: GHC.Types.Bool). (&&) GHC.Types.False a = GHC.Types.False
    forall (a :: GHC.Types.Bool). (&&) GHC.Types.True a = a
    forall (a :: GHC.Types.Bool). (&&) a GHC.Types.False = GHC.Types.False
    forall (a :: GHC.Types.Bool). (&&) a GHC.Types.True = a
    forall (a :: GHC.Types.Bool). (&&) a a = a
  type If :: forall {k}. GHC.Types.Bool -> k -> k -> k
  type family If cond tru fls where
    forall k (tru :: k) (fls :: k). If GHC.Types.True tru fls = tru
    forall k (tru :: k) (fls :: k). If GHC.Types.False tru fls = fls
  type Not :: GHC.Types.Bool -> GHC.Types.Bool
  type family Not a where = res | res -> a
      Not GHC.Types.False = GHC.Types.True
      Not GHC.Types.True = GHC.Types.False
  type (||) :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  type family (||) a b where
    forall (a :: GHC.Types.Bool). (||) GHC.Types.False a = a
    forall (a :: GHC.Types.Bool). (||) GHC.Types.True a = GHC.Types.True
    forall (a :: GHC.Types.Bool). (||) a GHC.Types.False = a
    forall (a :: GHC.Types.Bool). (||) a GHC.Types.True = GHC.Types.True
    forall (a :: GHC.Types.Bool). (||) a a = a

module Data.Type.Coercion where
  -- Safety: None
  type Coercion :: forall {k}. k -> k -> *
  data Coercion a b where
    Coercion :: forall {k} (a :: k) (b :: k). Coercible a b => Coercion a b
  type TestCoercion :: forall {k}. (k -> *) -> Constraint
  class TestCoercion f where
    testCoercion :: forall (a :: k) (b :: k). f a -> f b -> GHC.Maybe.Maybe (Coercion a b)
    {-# MINIMAL testCoercion #-}
  coerceWith :: forall a b. Coercion a b -> a -> b
  gcoerceWith :: forall {k} (a :: k) (b :: k) r. Coercion a b -> (Coercible a b => r) -> r
  repr :: forall {k} (a :: k) (b :: k). (a Data.Type.Equality.:~: b) -> Coercion a b
  sym :: forall {k} (a :: k) (b :: k). Coercion a b -> Coercion b a
  trans :: forall {k} (a :: k) (b :: k) (c :: k). Coercion a b -> Coercion b c -> Coercion a c

module Data.Type.Equality where
  -- Safety: Trustworthy
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    Refl :: forall {k} (a :: k). (:~:) a a
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    HRefl :: forall {k1} (a :: k1). (:~~:) a a
  type (==) :: forall k. k -> k -> GHC.Types.Bool
  type family (==) a b where
    forall k1 k2 (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (==) (f a) (g b) = (f == g) Data.Type.Bool.&& (a == b)
    forall k (a :: k). (==) a a = GHC.Types.True
    forall k (_1 :: k) (_2 :: k). (==) _1 _2 = GHC.Types.False
  type TestEquality :: forall {k}. (k -> *) -> Constraint
  class TestEquality f where
    testEquality :: forall (a :: k) (b :: k). f a -> f b -> GHC.Maybe.Maybe (a :~: b)
    {-# MINIMAL testEquality #-}
  apply :: forall {k1} {k2} (f :: k1 -> k2) (g :: k1 -> k2) (a :: k1) (b :: k1). (f :~: g) -> (a :~: b) -> f a :~: g b
  castWith :: forall a b. (a :~: b) -> a -> b
  gcastWith :: forall {k} (a :: k) (b :: k) r. (a :~: b) -> ((a ~ b) => r) -> r
  inner :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> a :~: b
  outer :: forall {k1} {k2} (f :: k1 -> k2) (a :: k1) (g :: k1 -> k2) (b :: k1). (f a :~: g b) -> f :~: g
  sym :: forall {k} (a :: k) (b :: k). (a :~: b) -> b :~: a
  trans :: forall {k} (a :: k) (b :: k) (c :: k). (a :~: b) -> (b :~: c) -> a :~: c
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
    {-# MINIMAL #-}
  type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
  class (a ~~ b) => (~~) a b
    {-# MINIMAL #-}

module Data.Type.Ord where
  -- Safety: Trustworthy
  type (<) :: forall {t}. t -> t -> Constraint
  type (<) x y = GHC.TypeError.Assert (x <? y) (Data.Type.Ord.LtErrMsg x y) :: Constraint
  type (<=) :: forall {t}. t -> t -> Constraint
  type (<=) x y = GHC.TypeError.Assert (x <=? y) (Data.Type.Ord.LeErrMsg x y) :: Constraint
  type (<=?) :: forall k. k -> k -> GHC.Types.Bool
  type (<=?) m n = OrdCond (Compare m n) GHC.Types.True GHC.Types.True GHC.Types.False :: GHC.Types.Bool
  type (<?) :: forall k. k -> k -> GHC.Types.Bool
  type (<?) m n = OrdCond (Compare m n) GHC.Types.True GHC.Types.False GHC.Types.False :: GHC.Types.Bool
  type (>) :: forall {t}. t -> t -> Constraint
  type (>) x y = GHC.TypeError.Assert (x >? y) (Data.Type.Ord.GtErrMsg x y) :: Constraint
  type (>=) :: forall {t}. t -> t -> Constraint
  type (>=) x y = GHC.TypeError.Assert (x >=? y) (Data.Type.Ord.GeErrMsg x y) :: Constraint
  type (>=?) :: forall k. k -> k -> GHC.Types.Bool
  type (>=?) m n = OrdCond (Compare m n) GHC.Types.False GHC.Types.True GHC.Types.True :: GHC.Types.Bool
  type (>?) :: forall k. k -> k -> GHC.Types.Bool
  type (>?) m n = OrdCond (Compare m n) GHC.Types.False GHC.Types.False GHC.Types.True :: GHC.Types.Bool
  type Compare :: forall k. k -> k -> GHC.Types.Ordering
  type family Compare a b
  type Max :: forall k. k -> k -> k
  type Max m n = OrdCond (Compare m n) n n m :: k
  type Min :: forall k. k -> k -> k
  type Min m n = OrdCond (Compare m n) m m n :: k
  type OrdCond :: forall k. GHC.Types.Ordering -> k -> k -> k -> k
  type family OrdCond o lt eq gt where
    forall k (lt :: k) (eq :: k) (gt :: k). OrdCond GHC.Types.LT lt eq gt = lt
    forall k (lt :: k) (eq :: k) (gt :: k). OrdCond GHC.Types.EQ lt eq gt = eq
    forall k (lt :: k) (eq :: k) (gt :: k). OrdCond GHC.Types.GT lt eq gt = gt
  type role OrderingI nominal nominal
  type OrderingI :: forall {k}. k -> k -> *
  data OrderingI a b where
    LTI :: forall {k} (a :: k) (b :: k). (Compare a b ~ GHC.Types.LT) => OrderingI a b
    EQI :: forall {k} (a :: k). (Compare a a ~ GHC.Types.EQ) => OrderingI a a
    GTI :: forall {k} (a :: k) (b :: k). (Compare a b ~ GHC.Types.GT) => OrderingI a b

module Data.Typeable where
  -- Safety: Trustworthy
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    Refl :: forall {k} (a :: k). (:~:) a a
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    HRefl :: forall {k1} (a :: k1). (:~~:) a a
  type role Proxy phantom
  type Proxy :: forall {k}. k -> *
  data Proxy t = Proxy
  type TyCon :: *
  data TyCon = ...
  type TypeRep :: *
  type TypeRep = base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep
  type Typeable :: forall k. k -> Constraint
  class Typeable a where
    ...
    {-# MINIMAL base-4.18.0.0:Data.Typeable.Internal.typeRep# #-}
  cast :: forall a b. (Typeable a, Typeable b) => a -> GHC.Maybe.Maybe b
  decT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => Data.Either.Either ((a :~: b) -> GHC.Base.Void) (a :~: b)
  eqT :: forall {k} (a :: k) (b :: k). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~: b)
  funResultTy :: TypeRep -> TypeRep -> GHC.Maybe.Maybe TypeRep
  gcast :: forall {k} (a :: k) (b :: k) (c :: k -> *). (Typeable a, Typeable b) => c a -> GHC.Maybe.Maybe (c b)
  gcast1 :: forall {k1} {k2} (c :: k1 -> *) (t :: k2 -> k1) (t' :: k2 -> k1) (a :: k2). (Typeable t, Typeable t') => c (t a) -> GHC.Maybe.Maybe (c (t' a))
  gcast2 :: forall {k1} {k2} {k3} (c :: k1 -> *) (t :: k2 -> k3 -> k1) (t' :: k2 -> k3 -> k1) (a :: k2) (b :: k3). (Typeable t, Typeable t') => c (t a b) -> GHC.Maybe.Maybe (c (t' a b))
  hdecT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => Data.Either.Either ((a :~~: b) -> GHC.Base.Void) (a :~~: b)
  heqT :: forall {k1} {k2} (a :: k1) (b :: k2). (Typeable a, Typeable b) => GHC.Maybe.Maybe (a :~~: b)
  mkFunTy :: TypeRep -> TypeRep -> TypeRep
  rnfTyCon :: TyCon -> ()
  rnfTypeRep :: TypeRep -> ()
  showsTypeRep :: TypeRep -> GHC.Show.ShowS
  splitTyConApp :: TypeRep -> (TyCon, [TypeRep])
  trLiftedRep :: base-4.18.0.0:Data.Typeable.Internal.TypeRep GHC.Types.LiftedRep
  tyConFingerprint :: TyCon -> GHC.Fingerprint.Type.Fingerprint
  tyConModule :: TyCon -> GHC.Base.String
  tyConName :: TyCon -> GHC.Base.String
  tyConPackage :: TyCon -> GHC.Base.String
  typeOf :: forall a. Typeable a => a -> TypeRep
  typeOf1 :: forall (t :: * -> *) a. Typeable t => t a -> TypeRep
  typeOf2 :: forall (t :: * -> * -> *) a b. Typeable t => t a b -> TypeRep
  typeOf3 :: forall (t :: * -> * -> * -> *) a b c. Typeable t => t a b c -> TypeRep
  typeOf4 :: forall (t :: * -> * -> * -> * -> *) a b c d. Typeable t => t a b c d -> TypeRep
  typeOf5 :: forall (t :: * -> * -> * -> * -> * -> *) a b c d e. Typeable t => t a b c d e -> TypeRep
  typeOf6 :: forall (t :: * -> * -> * -> * -> * -> * -> *) a b c d e f. Typeable t => t a b c d e f -> TypeRep
  typeOf7 :: forall (t :: * -> * -> * -> * -> * -> * -> * -> *) a b c d e f g. Typeable t => t a b c d e f g -> TypeRep
  typeRep :: forall {k} (proxy :: k -> *) (a :: k). Typeable a => proxy a -> TypeRep
  typeRepArgs :: TypeRep -> [TypeRep]
  typeRepFingerprint :: TypeRep -> GHC.Fingerprint.Type.Fingerprint
  typeRepTyCon :: TypeRep -> TyCon

module Data.Unique where
  -- Safety: Trustworthy
  type Unique :: *
  newtype Unique = ...
  hashUnique :: Unique -> GHC.Types.Int
  newUnique :: GHC.Types.IO Unique

module Data.Version where
  -- Safety: Safe
  type Version :: *
  data Version = Version {versionBranch :: [GHC.Types.Int], versionTags :: [GHC.Base.String]}
  makeVersion :: [GHC.Types.Int] -> Version
  parseVersion :: Text.ParserCombinators.ReadP.ReadP Version
  showVersion :: Version -> GHC.Base.String

module Data.Void where
  -- Safety: Trustworthy
  type Void :: *
  data Void
  absurd :: forall a. Void -> a
  vacuous :: forall (f :: * -> *) a. GHC.Base.Functor f => f Void -> f a

module Data.Word where
  -- Safety: Safe
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64

module Debug.Trace where
  -- Safety: Unsafe
  flushEventLog :: GHC.Types.IO ()
  putTraceMsg :: GHC.Base.String -> GHC.Types.IO ()
  trace :: forall a. GHC.Base.String -> a -> a
  traceEvent :: forall a. GHC.Base.String -> a -> a
  traceEventIO :: GHC.Base.String -> GHC.Types.IO ()
  traceEventWith :: forall a. (a -> GHC.Base.String) -> a -> a
  traceIO :: GHC.Base.String -> GHC.Types.IO ()
  traceId :: GHC.Base.String -> GHC.Base.String
  traceM :: forall (f :: * -> *). GHC.Base.Applicative f => GHC.Base.String -> f ()
  traceMarker :: forall a. GHC.Base.String -> a -> a
  traceMarkerIO :: GHC.Base.String -> GHC.Types.IO ()
  traceShow :: forall a b. GHC.Show.Show a => a -> b -> b
  traceShowId :: forall a. GHC.Show.Show a => a -> a
  traceShowM :: forall a (f :: * -> *). (GHC.Show.Show a, GHC.Base.Applicative f) => a -> f ()
  traceShowWith :: forall b a. GHC.Show.Show b => (a -> b) -> a -> a
  traceStack :: forall a. GHC.Base.String -> a -> a
  traceWith :: forall a. (a -> GHC.Base.String) -> a -> a

module Foreign where
  -- Safety: Safe
  (!<<.) :: forall a. Bits a => a -> Int -> a
  (!>>.) :: forall a. Bits a => a -> Int -> a
  (.<<.) :: forall a. Bits a => a -> Int -> a
  (.>>.) :: forall a. Bits a => a -> Int -> a
  (.^.) :: forall a. Bits a => a -> a -> a
  type And :: * -> *
  newtype And a = And {getAnd :: a}
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a where
    (.&.) :: a -> a -> a
    (.|.) :: a -> a -> a
    xor :: a -> a -> a
    complement :: a -> a
    shift :: a -> Int -> a
    rotate :: a -> Int -> a
    zeroBits :: a
    bit :: Int -> a
    setBit :: a -> Int -> a
    clearBit :: a -> Int -> a
    complementBit :: a -> Int -> a
    testBit :: a -> Int -> GHC.Types.Bool
    bitSizeMaybe :: a -> GHC.Maybe.Maybe Int
    bitSize :: a -> Int
    isSigned :: a -> GHC.Types.Bool
    shiftL :: a -> Int -> a
    unsafeShiftL :: a -> Int -> a
    shiftR :: a -> Int -> a
    unsafeShiftR :: a -> Int -> a
    rotateL :: a -> Int -> a
    rotateR :: a -> Int -> a
    popCount :: a -> Int
    {-# MINIMAL (.&.), (.|.), xor, complement, (shift | (shiftL, shiftR)), (rotate | (rotateL, rotateR)), bitSize, bitSizeMaybe, isSigned, testBit, bit, popCount #-}
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = FunPtr (Ptr a -> GHC.Types.IO ())
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b where
    finiteBitSize :: b -> Int
    countLeadingZeros :: b -> Int
    countTrailingZeros :: b -> Int
    {-# MINIMAL finiteBitSize #-}
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  type Iff :: * -> *
  newtype Iff a = Iff {getIff :: a}
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...
  type IntPtr :: *
  newtype IntPtr = IntPtr Int
  type Ior :: * -> *
  newtype Ior a = Ior {getIor :: a}
  type Pool :: *
  newtype Pool = ...
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  type StablePtr :: * -> *
  data StablePtr a = ...
  type Storable :: * -> Constraint
  class Storable a where
    sizeOf :: a -> Int
    alignment :: a -> Int
    peekElemOff :: Ptr a -> Int -> GHC.Types.IO a
    pokeElemOff :: Ptr a -> Int -> a -> GHC.Types.IO ()
    peekByteOff :: forall b. Ptr b -> Int -> GHC.Types.IO a
    pokeByteOff :: forall b. Ptr b -> Int -> a -> GHC.Types.IO ()
    peek :: Ptr a -> GHC.Types.IO a
    poke :: Ptr a -> a -> GHC.Types.IO ()
    {-# MINIMAL sizeOf, alignment, (peek | peekElemOff | peekByteOff), (poke | pokeElemOff | pokeByteOff) #-}
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  type WordPtr :: *
  newtype WordPtr = WordPtr Word
  type Xor :: * -> *
  newtype Xor a = Xor {getXor :: a}
  addForeignPtrFinalizer :: forall a. FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: forall env a. FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  advancePtr :: forall a. Storable a => Ptr a -> Int -> Ptr a
  alignPtr :: forall a. Ptr a -> Int -> Ptr a
  alloca :: forall a b. Storable a => (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: forall a b. Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: forall a b. Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: forall a b. Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: forall a b. Int -> Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  bitDefault :: forall a. (Bits a, GHC.Num.Num a) => Int -> a
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64
  calloc :: forall a. Storable a => GHC.Types.IO (Ptr a)
  callocArray :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  callocArray0 :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  callocBytes :: forall a. Int -> GHC.Types.IO (Ptr a)
  castForeignPtr :: forall a b. ForeignPtr a -> ForeignPtr b
  castFunPtr :: forall a b. FunPtr a -> FunPtr b
  castFunPtrToPtr :: forall a b. FunPtr a -> Ptr b
  castPtr :: forall a b. Ptr a -> Ptr b
  castPtrToFunPtr :: forall a b. Ptr a -> FunPtr b
  castPtrToStablePtr :: forall a. Ptr () -> StablePtr a
  castStablePtrToPtr :: forall a. StablePtr a -> Ptr ()
  copyArray :: forall a. Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  copyBytes :: forall a. Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  deRefStablePtr :: forall a. StablePtr a -> GHC.Types.IO a
  fillBytes :: forall a. Ptr a -> Word8 -> Int -> GHC.Types.IO ()
  finalizeForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  finalizerFree :: forall a. FinalizerPtr a
  free :: forall a. Ptr a -> GHC.Types.IO ()
  freeHaskellFunPtr :: forall a. FunPtr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  freeStablePtr :: forall a. StablePtr a -> GHC.Types.IO ()
  fromBool :: forall a. GHC.Num.Num a => GHC.Types.Bool -> a
  intPtrToPtr :: forall a. IntPtr -> Ptr a
  lengthArray0 :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO Int
  malloc :: forall a. Storable a => GHC.Types.IO (Ptr a)
  mallocArray :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocArray0 :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocBytes :: forall a. Int -> GHC.Types.IO (Ptr a)
  mallocForeignPtr :: forall a. Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: forall a. Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: forall a. Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: forall a. Int -> GHC.Types.IO (ForeignPtr a)
  maybeNew :: forall a b. (a -> GHC.Types.IO (Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (Ptr b)
  maybePeek :: forall a b. (Ptr a -> GHC.Types.IO b) -> Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: forall a b c. (a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  minusPtr :: forall a b. Ptr a -> Ptr b -> Int
  moveArray :: forall a. Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  moveBytes :: forall a. Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  new :: forall a. Storable a => a -> GHC.Types.IO (Ptr a)
  newArray :: forall a. Storable a => [a] -> GHC.Types.IO (Ptr a)
  newArray0 :: forall a. Storable a => a -> [a] -> GHC.Types.IO (Ptr a)
  newForeignPtr :: forall a. FinalizerPtr a -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: forall env a. FinalizerEnvPtr env a -> Ptr env -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: forall a. Ptr a -> GHC.Types.IO (ForeignPtr a)
  newPool :: GHC.Types.IO Pool
  newStablePtr :: forall a. a -> GHC.Types.IO (StablePtr a)
  nullFunPtr :: forall a. FunPtr a
  nullPtr :: forall a. Ptr a
  oneBits :: forall a. FiniteBits a => a
  peekArray :: forall a. Storable a => Int -> Ptr a -> GHC.Types.IO [a]
  peekArray0 :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO [a]
  plusForeignPtr :: forall a b. ForeignPtr a -> Int -> ForeignPtr b
  plusPtr :: forall a b. Ptr a -> Int -> Ptr b
  pokeArray :: forall a. Storable a => Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: forall a. Storable a => a -> Ptr a -> [a] -> GHC.Types.IO ()
  pooledMalloc :: forall a. Storable a => Pool -> GHC.Types.IO (Ptr a)
  pooledMallocArray :: forall a. Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocArray0 :: forall a. Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocBytes :: forall a. Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledNew :: forall a. Storable a => Pool -> a -> GHC.Types.IO (Ptr a)
  pooledNewArray :: forall a. Storable a => Pool -> [a] -> GHC.Types.IO (Ptr a)
  pooledNewArray0 :: forall a. Storable a => Pool -> a -> [a] -> GHC.Types.IO (Ptr a)
  pooledRealloc :: forall a. Storable a => Pool -> Ptr a -> GHC.Types.IO (Ptr a)
  pooledReallocArray :: forall a. Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocArray0 :: forall a. Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocBytes :: forall a. Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  popCountDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> Int
  ptrToIntPtr :: forall a. Ptr a -> IntPtr
  ptrToWordPtr :: forall a. Ptr a -> WordPtr
  realloc :: forall a b. Storable b => Ptr a -> GHC.Types.IO (Ptr b)
  reallocArray :: forall a. Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocArray0 :: forall a. Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocBytes :: forall a. Ptr a -> Int -> GHC.Types.IO (Ptr a)
  testBitDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> Int -> GHC.Types.Bool
  throwIf :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (Ptr a) -> GHC.Types.IO (Ptr a)
  throwIf_ :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  toIntegralSized :: forall a b. (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b
  touchForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  void :: forall a. GHC.Types.IO a -> GHC.Types.IO ()
  with :: forall a b. Storable a => a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: forall a b. Storable a => [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: forall a b. Storable a => a -> [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: forall a b. Storable a => [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: forall a b. Storable a => a -> [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withForeignPtr :: forall a b. ForeignPtr a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: forall a b res. (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: forall b. (Pool -> GHC.Types.IO b) -> GHC.Types.IO b
  wordPtrToPtr :: forall a. WordPtr -> Ptr a

module Foreign.C where
  -- Safety: Safe
  type CBool :: *
  newtype CBool = ...
  type CChar :: *
  newtype CChar = ...
  type CClock :: *
  newtype CClock = ...
  type CDouble :: *
  newtype CDouble = ...
  type CFile :: *
  data CFile = ...
  type CFloat :: *
  newtype CFloat = ...
  type CFpos :: *
  data CFpos = ...
  type CInt :: *
  newtype CInt = ...
  type CIntMax :: *
  newtype CIntMax = ...
  type CIntPtr :: *
  newtype CIntPtr = ...
  type CJmpBuf :: *
  data CJmpBuf = ...
  type CLLong :: *
  newtype CLLong = ...
  type CLong :: *
  newtype CLong = ...
  type CPtrdiff :: *
  newtype CPtrdiff = ...
  type CSChar :: *
  newtype CSChar = ...
  type CSUSeconds :: *
  newtype CSUSeconds = ...
  type CShort :: *
  newtype CShort = ...
  type CSigAtomic :: *
  newtype CSigAtomic = ...
  type CSize :: *
  newtype CSize = ...
  type CString :: *
  type CString = GHC.Ptr.Ptr CChar
  type CStringLen :: *
  type CStringLen = (GHC.Ptr.Ptr CChar, GHC.Types.Int)
  type CTime :: *
  newtype CTime = ...
  type CUChar :: *
  newtype CUChar = ...
  type CUInt :: *
  newtype CUInt = ...
  type CUIntMax :: *
  newtype CUIntMax = ...
  type CUIntPtr :: *
  newtype CUIntPtr = ...
  type CULLong :: *
  newtype CULLong = ...
  type CULong :: *
  newtype CULong = ...
  type CUSeconds :: *
  newtype CUSeconds = ...
  type CUShort :: *
  newtype CUShort = ...
  type CWString :: *
  type CWString = GHC.Ptr.Ptr CWchar
  type CWStringLen :: *
  type CWStringLen = (GHC.Ptr.Ptr CWchar, GHC.Types.Int)
  type CWchar :: *
  newtype CWchar = ...
  type Errno :: *
  newtype Errno = Errno CInt
  castCCharToChar :: CChar -> GHC.Types.Char
  castCSCharToChar :: CSChar -> GHC.Types.Char
  castCUCharToChar :: CUChar -> GHC.Types.Char
  castCharToCChar :: GHC.Types.Char -> CChar
  castCharToCSChar :: GHC.Types.Char -> CSChar
  castCharToCUChar :: GHC.Types.Char -> CUChar
  charIsRepresentable :: GHC.Types.Char -> GHC.Types.IO GHC.Types.Bool
  e2BIG :: Errno
  eACCES :: Errno
  eADDRINUSE :: Errno
  eADDRNOTAVAIL :: Errno
  eADV :: Errno
  eAFNOSUPPORT :: Errno
  eAGAIN :: Errno
  eALREADY :: Errno
  eBADF :: Errno
  eBADMSG :: Errno
  eBADRPC :: Errno
  eBUSY :: Errno
  eCHILD :: Errno
  eCOMM :: Errno
  eCONNABORTED :: Errno
  eCONNREFUSED :: Errno
  eCONNRESET :: Errno
  eDEADLK :: Errno
  eDESTADDRREQ :: Errno
  eDIRTY :: Errno
  eDOM :: Errno
  eDQUOT :: Errno
  eEXIST :: Errno
  eFAULT :: Errno
  eFBIG :: Errno
  eFTYPE :: Errno
  eHOSTDOWN :: Errno
  eHOSTUNREACH :: Errno
  eIDRM :: Errno
  eILSEQ :: Errno
  eINPROGRESS :: Errno
  eINTR :: Errno
  eINVAL :: Errno
  eIO :: Errno
  eISCONN :: Errno
  eISDIR :: Errno
  eLOOP :: Errno
  eMFILE :: Errno
  eMLINK :: Errno
  eMSGSIZE :: Errno
  eMULTIHOP :: Errno
  eNAMETOOLONG :: Errno
  eNETDOWN :: Errno
  eNETRESET :: Errno
  eNETUNREACH :: Errno
  eNFILE :: Errno
  eNOBUFS :: Errno
  eNODATA :: Errno
  eNODEV :: Errno
  eNOENT :: Errno
  eNOEXEC :: Errno
  eNOLCK :: Errno
  eNOLINK :: Errno
  eNOMEM :: Errno
  eNOMSG :: Errno
  eNONET :: Errno
  eNOPROTOOPT :: Errno
  eNOSPC :: Errno
  eNOSR :: Errno
  eNOSTR :: Errno
  eNOSYS :: Errno
  eNOTBLK :: Errno
  eNOTCONN :: Errno
  eNOTDIR :: Errno
  eNOTEMPTY :: Errno
  eNOTSOCK :: Errno
  eNOTSUP :: Errno
  eNOTTY :: Errno
  eNXIO :: Errno
  eOK :: Errno
  eOPNOTSUPP :: Errno
  ePERM :: Errno
  ePFNOSUPPORT :: Errno
  ePIPE :: Errno
  ePROCLIM :: Errno
  ePROCUNAVAIL :: Errno
  ePROGMISMATCH :: Errno
  ePROGUNAVAIL :: Errno
  ePROTO :: Errno
  ePROTONOSUPPORT :: Errno
  ePROTOTYPE :: Errno
  eRANGE :: Errno
  eREMCHG :: Errno
  eREMOTE :: Errno
  eROFS :: Errno
  eRPCMISMATCH :: Errno
  eRREMOTE :: Errno
  eSHUTDOWN :: Errno
  eSOCKTNOSUPPORT :: Errno
  eSPIPE :: Errno
  eSRCH :: Errno
  eSRMNT :: Errno
  eSTALE :: Errno
  eTIME :: Errno
  eTIMEDOUT :: Errno
  eTOOMANYREFS :: Errno
  eTXTBSY :: Errno
  eUSERS :: Errno
  eWOULDBLOCK :: Errno
  eXDEV :: Errno
  errnoToIOError :: GHC.Base.String -> Errno -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.Base.String -> GHC.IO.Exception.IOError
  getErrno :: GHC.Types.IO Errno
  isValidErrno :: Errno -> GHC.Types.Bool
  newCAString :: GHC.Base.String -> GHC.Types.IO CString
  newCAStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCString :: GHC.Base.String -> GHC.Types.IO CString
  newCStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCWString :: GHC.Base.String -> GHC.Types.IO CWString
  newCWStringLen :: GHC.Base.String -> GHC.Types.IO CWStringLen
  peekCAString :: CString -> GHC.Types.IO GHC.Base.String
  peekCAStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCString :: CString -> GHC.Types.IO GHC.Base.String
  peekCStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCWString :: CWString -> GHC.Types.IO GHC.Base.String
  peekCWStringLen :: CWStringLen -> GHC.Types.IO GHC.Base.String
  resetErrno :: GHC.Types.IO ()
  throwErrno :: forall a. GHC.Base.String -> GHC.Types.IO a
  throwErrnoIf :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1 :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1Retry :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock :: forall a b. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock_ :: forall a b. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfMinus1Retry_ :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfMinus1_ :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetry :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetryMayBlock :: forall a b. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO b -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfRetry :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock :: forall a b. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock_ :: forall a b. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfRetry_ :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIf_ :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPath :: forall a. GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a
  throwErrnoPathIf :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1 :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1_ :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPathIfNull :: forall a. GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoPathIf_ :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()
  withCAString :: forall a. GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCAStringLen :: forall a. GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCString :: forall a. GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen :: forall a. GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWString :: forall a. GHC.Base.String -> (CWString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWStringLen :: forall a. GHC.Base.String -> (CWStringLen -> GHC.Types.IO a) -> GHC.Types.IO a

module Foreign.C.ConstPtr where
  -- Safety: Trustworthy
  type role ConstPtr phantom
  type ConstPtr :: * -> *
  newtype ConstPtr a = ConstPtr {unConstPtr :: GHC.Ptr.Ptr a}

module Foreign.C.Error where
  -- Safety: Trustworthy
  type Errno :: *
  newtype Errno = Errno Foreign.C.Types.CInt
  e2BIG :: Errno
  eACCES :: Errno
  eADDRINUSE :: Errno
  eADDRNOTAVAIL :: Errno
  eADV :: Errno
  eAFNOSUPPORT :: Errno
  eAGAIN :: Errno
  eALREADY :: Errno
  eBADF :: Errno
  eBADMSG :: Errno
  eBADRPC :: Errno
  eBUSY :: Errno
  eCHILD :: Errno
  eCOMM :: Errno
  eCONNABORTED :: Errno
  eCONNREFUSED :: Errno
  eCONNRESET :: Errno
  eDEADLK :: Errno
  eDESTADDRREQ :: Errno
  eDIRTY :: Errno
  eDOM :: Errno
  eDQUOT :: Errno
  eEXIST :: Errno
  eFAULT :: Errno
  eFBIG :: Errno
  eFTYPE :: Errno
  eHOSTDOWN :: Errno
  eHOSTUNREACH :: Errno
  eIDRM :: Errno
  eILSEQ :: Errno
  eINPROGRESS :: Errno
  eINTR :: Errno
  eINVAL :: Errno
  eIO :: Errno
  eISCONN :: Errno
  eISDIR :: Errno
  eLOOP :: Errno
  eMFILE :: Errno
  eMLINK :: Errno
  eMSGSIZE :: Errno
  eMULTIHOP :: Errno
  eNAMETOOLONG :: Errno
  eNETDOWN :: Errno
  eNETRESET :: Errno
  eNETUNREACH :: Errno
  eNFILE :: Errno
  eNOBUFS :: Errno
  eNODATA :: Errno
  eNODEV :: Errno
  eNOENT :: Errno
  eNOEXEC :: Errno
  eNOLCK :: Errno
  eNOLINK :: Errno
  eNOMEM :: Errno
  eNOMSG :: Errno
  eNONET :: Errno
  eNOPROTOOPT :: Errno
  eNOSPC :: Errno
  eNOSR :: Errno
  eNOSTR :: Errno
  eNOSYS :: Errno
  eNOTBLK :: Errno
  eNOTCONN :: Errno
  eNOTDIR :: Errno
  eNOTEMPTY :: Errno
  eNOTSOCK :: Errno
  eNOTSUP :: Errno
  eNOTTY :: Errno
  eNXIO :: Errno
  eOK :: Errno
  eOPNOTSUPP :: Errno
  ePERM :: Errno
  ePFNOSUPPORT :: Errno
  ePIPE :: Errno
  ePROCLIM :: Errno
  ePROCUNAVAIL :: Errno
  ePROGMISMATCH :: Errno
  ePROGUNAVAIL :: Errno
  ePROTO :: Errno
  ePROTONOSUPPORT :: Errno
  ePROTOTYPE :: Errno
  eRANGE :: Errno
  eREMCHG :: Errno
  eREMOTE :: Errno
  eROFS :: Errno
  eRPCMISMATCH :: Errno
  eRREMOTE :: Errno
  eSHUTDOWN :: Errno
  eSOCKTNOSUPPORT :: Errno
  eSPIPE :: Errno
  eSRCH :: Errno
  eSRMNT :: Errno
  eSTALE :: Errno
  eTIME :: Errno
  eTIMEDOUT :: Errno
  eTOOMANYREFS :: Errno
  eTXTBSY :: Errno
  eUSERS :: Errno
  eWOULDBLOCK :: Errno
  eXDEV :: Errno
  errnoToIOError :: GHC.Base.String -> Errno -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.Base.String -> GHC.IO.Exception.IOError
  getErrno :: GHC.Types.IO Errno
  isValidErrno :: Errno -> GHC.Types.Bool
  resetErrno :: GHC.Types.IO ()
  throwErrno :: forall a. GHC.Base.String -> GHC.Types.IO a
  throwErrnoIf :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1 :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1Retry :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock :: forall a b. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfMinus1RetryMayBlock_ :: forall a b. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfMinus1Retry_ :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfMinus1_ :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetry :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfNullRetryMayBlock :: forall a b. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO b -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoIfRetry :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock :: forall a b. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO a
  throwErrnoIfRetryMayBlock_ :: forall a b. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO b -> GHC.Types.IO ()
  throwErrnoIfRetry_ :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoIf_ :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPath :: forall a. GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a
  throwErrnoPathIf :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1 :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO a
  throwErrnoPathIfMinus1_ :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()
  throwErrnoPathIfNull :: forall a. GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwErrnoPathIf_ :: forall a. (a -> GHC.Types.Bool) -> GHC.Base.String -> GHC.IO.FilePath -> GHC.Types.IO a -> GHC.Types.IO ()

module Foreign.C.String where
  -- Safety: Trustworthy
  type CString :: *
  type CString = GHC.Ptr.Ptr Foreign.C.Types.CChar
  type CStringLen :: *
  type CStringLen = (GHC.Ptr.Ptr Foreign.C.Types.CChar, GHC.Types.Int)
  type CWString :: *
  type CWString = GHC.Ptr.Ptr Foreign.C.Types.CWchar
  type CWStringLen :: *
  type CWStringLen = (GHC.Ptr.Ptr Foreign.C.Types.CWchar, GHC.Types.Int)
  castCCharToChar :: Foreign.C.Types.CChar -> GHC.Types.Char
  castCSCharToChar :: Foreign.C.Types.CSChar -> GHC.Types.Char
  castCUCharToChar :: Foreign.C.Types.CUChar -> GHC.Types.Char
  castCharToCChar :: GHC.Types.Char -> Foreign.C.Types.CChar
  castCharToCSChar :: GHC.Types.Char -> Foreign.C.Types.CSChar
  castCharToCUChar :: GHC.Types.Char -> Foreign.C.Types.CUChar
  charIsRepresentable :: GHC.Types.Char -> GHC.Types.IO GHC.Types.Bool
  newCAString :: GHC.Base.String -> GHC.Types.IO CString
  newCAStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCString :: GHC.Base.String -> GHC.Types.IO CString
  newCStringLen :: GHC.Base.String -> GHC.Types.IO CStringLen
  newCWString :: GHC.Base.String -> GHC.Types.IO CWString
  newCWStringLen :: GHC.Base.String -> GHC.Types.IO CWStringLen
  peekCAString :: CString -> GHC.Types.IO GHC.Base.String
  peekCAStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCString :: CString -> GHC.Types.IO GHC.Base.String
  peekCStringLen :: CStringLen -> GHC.Types.IO GHC.Base.String
  peekCWString :: CWString -> GHC.Types.IO GHC.Base.String
  peekCWStringLen :: CWStringLen -> GHC.Types.IO GHC.Base.String
  withCAString :: forall a. GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCAStringLen :: forall a. GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCString :: forall a. GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen :: forall a. GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWString :: forall a. GHC.Base.String -> (CWString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCWStringLen :: forall a. GHC.Base.String -> (CWStringLen -> GHC.Types.IO a) -> GHC.Types.IO a

module Foreign.C.Types where

-- ignored


module Foreign.Concurrent where
  -- Safety: Trustworthy
  addForeignPtrFinalizer :: forall a. GHC.ForeignPtr.ForeignPtr a -> GHC.Types.IO () -> GHC.Types.IO ()
  newForeignPtr :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO () -> GHC.Types.IO (GHC.ForeignPtr.ForeignPtr a)

module Foreign.ForeignPtr where
  -- Safety: Trustworthy
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  addForeignPtrFinalizer :: forall a. FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: forall env a. FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  castForeignPtr :: forall a b. ForeignPtr a -> ForeignPtr b
  finalizeForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  mallocForeignPtr :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr :: forall a. FinalizerPtr a -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: forall env a. FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  plusForeignPtr :: forall a b. ForeignPtr a -> GHC.Types.Int -> ForeignPtr b
  touchForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  withForeignPtr :: forall a b. ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.ForeignPtr.Safe where
  -- Safety: Trustworthy
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  addForeignPtrFinalizer :: forall a. FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: forall env a. FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  castForeignPtr :: forall a b. ForeignPtr a -> ForeignPtr b
  finalizeForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  mallocForeignPtr :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr :: forall a. FinalizerPtr a -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: forall env a. FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  touchForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  withForeignPtr :: forall a b. ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.ForeignPtr.Unsafe where
  -- Safety: Unsafe
  unsafeForeignPtrToPtr :: forall a. GHC.ForeignPtr.ForeignPtr a -> GHC.Ptr.Ptr a

module Foreign.Marshal where
  -- Safety: Safe
  type Pool :: *
  newtype Pool = ...
  advancePtr :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Ptr.Ptr a
  alloca :: forall a b. Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: forall a b. Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: forall a b. Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: forall a b. GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: forall a b. GHC.Types.Int -> GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  calloc :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  copyArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  copyBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  fillBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO ()
  finalizerFree :: forall a. GHC.ForeignPtr.FinalizerPtr a
  free :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  fromBool :: forall a. GHC.Num.Num a => GHC.Types.Bool -> a
  lengthArray0 :: forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO GHC.Types.Int
  malloc :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  maybeNew :: forall a b. (a -> GHC.Types.IO (GHC.Ptr.Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  maybePeek :: forall a b. (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: forall a b c. (a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  moveArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  moveBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  new :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray :: forall a. Foreign.Storable.Storable a => [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray0 :: forall a. Foreign.Storable.Storable a => a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newPool :: GHC.Types.IO Pool
  peekArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  peekArray0 :: forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  pokeArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: forall a. Foreign.Storable.Storable a => a -> GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pooledMalloc :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray0 :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocBytes :: forall a. Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNew :: forall a. Foreign.Storable.Storable a => Pool -> a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray :: forall a. Foreign.Storable.Storable a => Pool -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray0 :: forall a. Foreign.Storable.Storable a => Pool -> a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledRealloc :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray0 :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocBytes :: forall a. Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  realloc :: forall a b. Foreign.Storable.Storable b => GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  reallocArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf_ :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  void :: forall a. GHC.Types.IO a -> GHC.Types.IO ()
  with :: forall a b. Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: forall a b. Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: forall a b. Foreign.Storable.Storable a => a -> [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: forall a b. Foreign.Storable.Storable a => [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: forall a b. Foreign.Storable.Storable a => a -> [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: forall a b res. (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: forall b. (Pool -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Alloc where
  -- Safety: Trustworthy
  alloca :: forall a b. Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: forall a b. GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: forall a b. GHC.Types.Int -> GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  calloc :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  callocBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  finalizerFree :: forall a. GHC.ForeignPtr.FinalizerPtr a
  free :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO ()
  malloc :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  realloc :: forall a b. Foreign.Storable.Storable b => GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  reallocBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)

module Foreign.Marshal.Array where
  -- Safety: Trustworthy
  advancePtr :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Ptr.Ptr a
  allocaArray :: forall a b. Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: forall a b. Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  callocArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  copyArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  lengthArray0 :: forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO GHC.Types.Int
  mallocArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  moveArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  newArray :: forall a. Foreign.Storable.Storable a => [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray0 :: forall a. Foreign.Storable.Storable a => a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  peekArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  peekArray0 :: forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  pokeArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: forall a. Foreign.Storable.Storable a => a -> GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  reallocArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  withArray :: forall a b. Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: forall a b. Foreign.Storable.Storable a => a -> [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: forall a b. Foreign.Storable.Storable a => [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: forall a b. Foreign.Storable.Storable a => a -> [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Error where
  -- Safety: Trustworthy
  throwIf :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf_ :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  void :: forall a. GHC.Types.IO a -> GHC.Types.IO ()

module Foreign.Marshal.Pool where
  -- Safety: Trustworthy
  type Pool :: *
  newtype Pool = ...
  freePool :: Pool -> GHC.Types.IO ()
  newPool :: GHC.Types.IO Pool
  pooledMalloc :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray0 :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocBytes :: forall a. Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNew :: forall a. Foreign.Storable.Storable a => Pool -> a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray :: forall a. Foreign.Storable.Storable a => Pool -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray0 :: forall a. Foreign.Storable.Storable a => Pool -> a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledRealloc :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray0 :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocBytes :: forall a. Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  withPool :: forall b. (Pool -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Safe where
  -- Safety: Safe
  type Pool :: *
  newtype Pool = ...
  advancePtr :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Ptr.Ptr a
  alloca :: forall a b. Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: forall a b. Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: forall a b. Foreign.Storable.Storable a => GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: forall a b. GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: forall a b. GHC.Types.Int -> GHC.Types.Int -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  calloc :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  callocBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  copyArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  copyBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  fillBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO ()
  finalizerFree :: forall a. GHC.ForeignPtr.FinalizerPtr a
  free :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  fromBool :: forall a. GHC.Num.Num a => GHC.Types.Bool -> a
  lengthArray0 :: forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO GHC.Types.Int
  malloc :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  mallocBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  maybeNew :: forall a b. (a -> GHC.Types.IO (GHC.Ptr.Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  maybePeek :: forall a b. (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: forall a b c. (a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  moveArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  moveBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  new :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray :: forall a. Foreign.Storable.Storable a => [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newArray0 :: forall a. Foreign.Storable.Storable a => a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  newPool :: GHC.Types.IO Pool
  peekArray :: forall a. Foreign.Storable.Storable a => GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  peekArray0 :: forall a. (Foreign.Storable.Storable a, GHC.Classes.Eq a) => a -> GHC.Ptr.Ptr a -> GHC.Types.IO [a]
  pokeArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: forall a. Foreign.Storable.Storable a => a -> GHC.Ptr.Ptr a -> [a] -> GHC.Types.IO ()
  pooledMalloc :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocArray0 :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledMallocBytes :: forall a. Pool -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNew :: forall a. Foreign.Storable.Storable a => Pool -> a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray :: forall a. Foreign.Storable.Storable a => Pool -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledNewArray0 :: forall a. Foreign.Storable.Storable a => Pool -> a -> [a] -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledRealloc :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocArray0 :: forall a. Foreign.Storable.Storable a => Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  pooledReallocBytes :: forall a. Pool -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  realloc :: forall a b. Foreign.Storable.Storable b => GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  reallocArray :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocArray0 :: forall a. Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  reallocBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (GHC.Ptr.Ptr a) -> GHC.Types.IO (GHC.Ptr.Ptr a)
  throwIf_ :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  void :: forall a. GHC.Types.IO a -> GHC.Types.IO ()
  with :: forall a b. Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: forall a b. Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: forall a b. Foreign.Storable.Storable a => a -> [a] -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: forall a b. Foreign.Storable.Storable a => [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: forall a b. Foreign.Storable.Storable a => a -> [a] -> (GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: forall a b res. (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: forall b. (Pool -> GHC.Types.IO b) -> GHC.Types.IO b

module Foreign.Marshal.Unsafe where
  -- Safety: Unsafe
  unsafeLocalState :: forall a. GHC.Types.IO a -> a

module Foreign.Marshal.Utils where
  -- Safety: Trustworthy
  copyBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  fillBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO ()
  fromBool :: forall a. GHC.Num.Num a => GHC.Types.Bool -> a
  maybeNew :: forall a b. (a -> GHC.Types.IO (GHC.Ptr.Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (GHC.Ptr.Ptr b)
  maybePeek :: forall a b. (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: forall a b c. (a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (GHC.Ptr.Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  moveBytes :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  new :: forall a. Foreign.Storable.Storable a => a -> GHC.Types.IO (GHC.Ptr.Ptr a)
  toBool :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  with :: forall a b. Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: forall a b res. (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res

module Foreign.Ptr where
  -- Safety: Trustworthy
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  type IntPtr :: *
  newtype IntPtr = IntPtr GHC.Types.Int
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  type WordPtr :: *
  newtype WordPtr = WordPtr GHC.Types.Word
  alignPtr :: forall a. Ptr a -> GHC.Types.Int -> Ptr a
  castFunPtr :: forall a b. FunPtr a -> FunPtr b
  castFunPtrToPtr :: forall a b. FunPtr a -> Ptr b
  castPtr :: forall a b. Ptr a -> Ptr b
  castPtrToFunPtr :: forall a b. Ptr a -> FunPtr b
  freeHaskellFunPtr :: forall a. FunPtr a -> GHC.Types.IO ()
  intPtrToPtr :: forall a. IntPtr -> Ptr a
  minusPtr :: forall a b. Ptr a -> Ptr b -> GHC.Types.Int
  nullFunPtr :: forall a. FunPtr a
  nullPtr :: forall a. Ptr a
  plusPtr :: forall a b. Ptr a -> GHC.Types.Int -> Ptr b
  ptrToIntPtr :: forall a. Ptr a -> IntPtr
  ptrToWordPtr :: forall a. Ptr a -> WordPtr
  wordPtrToPtr :: forall a. WordPtr -> Ptr a

module Foreign.Safe where
  -- Safety: Safe
  (!<<.) :: forall a. Bits a => a -> Int -> a
  (!>>.) :: forall a. Bits a => a -> Int -> a
  (.<<.) :: forall a. Bits a => a -> Int -> a
  (.>>.) :: forall a. Bits a => a -> Int -> a
  (.^.) :: forall a. Bits a => a -> a -> a
  type And :: * -> *
  newtype And a = And {getAnd :: a}
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a where
    (.&.) :: a -> a -> a
    (.|.) :: a -> a -> a
    xor :: a -> a -> a
    complement :: a -> a
    shift :: a -> Int -> a
    rotate :: a -> Int -> a
    zeroBits :: a
    bit :: Int -> a
    setBit :: a -> Int -> a
    clearBit :: a -> Int -> a
    complementBit :: a -> Int -> a
    testBit :: a -> Int -> GHC.Types.Bool
    bitSizeMaybe :: a -> GHC.Maybe.Maybe Int
    bitSize :: a -> Int
    isSigned :: a -> GHC.Types.Bool
    shiftL :: a -> Int -> a
    unsafeShiftL :: a -> Int -> a
    shiftR :: a -> Int -> a
    unsafeShiftR :: a -> Int -> a
    rotateL :: a -> Int -> a
    rotateR :: a -> Int -> a
    popCount :: a -> Int
    {-# MINIMAL (.&.), (.|.), xor, complement, (shift | (shiftL, shiftR)), (rotate | (rotateL, rotateR)), bitSize, bitSizeMaybe, isSigned, testBit, bit, popCount #-}
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = FunPtr (Ptr env -> Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = FunPtr (Ptr a -> GHC.Types.IO ())
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b where
    finiteBitSize :: b -> Int
    countLeadingZeros :: b -> Int
    countTrailingZeros :: b -> Int
    {-# MINIMAL finiteBitSize #-}
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ...
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = ...
  type Iff :: * -> *
  newtype Iff a = Iff {getIff :: a}
  type Int :: *
  data Int = ...
  type Int16 :: *
  data Int16 = ...
  type Int32 :: *
  data Int32 = ...
  type Int64 :: *
  data Int64 = ...
  type Int8 :: *
  data Int8 = ...
  type IntPtr :: *
  newtype IntPtr = IntPtr Int
  type Ior :: * -> *
  newtype Ior a = Ior {getIor :: a}
  type Pool :: *
  newtype Pool = ...
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = ...
  type StablePtr :: * -> *
  data StablePtr a = ...
  type Storable :: * -> Constraint
  class Storable a where
    sizeOf :: a -> Int
    alignment :: a -> Int
    peekElemOff :: Ptr a -> Int -> GHC.Types.IO a
    pokeElemOff :: Ptr a -> Int -> a -> GHC.Types.IO ()
    peekByteOff :: forall b. Ptr b -> Int -> GHC.Types.IO a
    pokeByteOff :: forall b. Ptr b -> Int -> a -> GHC.Types.IO ()
    peek :: Ptr a -> GHC.Types.IO a
    poke :: Ptr a -> a -> GHC.Types.IO ()
    {-# MINIMAL sizeOf, alignment, (peek | peekElemOff | peekByteOff), (poke | pokeElemOff | pokeByteOff) #-}
  type Word :: *
  data Word = ...
  type Word16 :: *
  data Word16 = ...
  type Word32 :: *
  data Word32 = ...
  type Word64 :: *
  data Word64 = ...
  type Word8 :: *
  data Word8 = ...
  type WordPtr :: *
  newtype WordPtr = WordPtr Word
  type Xor :: * -> *
  newtype Xor a = Xor {getXor :: a}
  addForeignPtrFinalizer :: forall a. FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: forall env a. FinalizerEnvPtr env a -> Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  advancePtr :: forall a. Storable a => Ptr a -> Int -> Ptr a
  alignPtr :: forall a. Ptr a -> Int -> Ptr a
  alloca :: forall a b. Storable a => (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray :: forall a b. Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaArray0 :: forall a b. Storable a => Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytes :: forall a b. Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  allocaBytesAligned :: forall a b. Int -> Int -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  bitDefault :: forall a. (Bits a, GHC.Num.Num a) => Int -> a
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64
  calloc :: forall a. Storable a => GHC.Types.IO (Ptr a)
  callocArray :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  callocArray0 :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  callocBytes :: forall a. Int -> GHC.Types.IO (Ptr a)
  castForeignPtr :: forall a b. ForeignPtr a -> ForeignPtr b
  castFunPtr :: forall a b. FunPtr a -> FunPtr b
  castFunPtrToPtr :: forall a b. FunPtr a -> Ptr b
  castPtr :: forall a b. Ptr a -> Ptr b
  castPtrToFunPtr :: forall a b. Ptr a -> FunPtr b
  castPtrToStablePtr :: forall a. Ptr () -> StablePtr a
  castStablePtrToPtr :: forall a. StablePtr a -> Ptr ()
  copyArray :: forall a. Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  copyBytes :: forall a. Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  deRefStablePtr :: forall a. StablePtr a -> GHC.Types.IO a
  fillBytes :: forall a. Ptr a -> Word8 -> Int -> GHC.Types.IO ()
  finalizeForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  finalizerFree :: forall a. FinalizerPtr a
  free :: forall a. Ptr a -> GHC.Types.IO ()
  freeHaskellFunPtr :: forall a. FunPtr a -> GHC.Types.IO ()
  freePool :: Pool -> GHC.Types.IO ()
  freeStablePtr :: forall a. StablePtr a -> GHC.Types.IO ()
  fromBool :: forall a. GHC.Num.Num a => GHC.Types.Bool -> a
  intPtrToPtr :: forall a. IntPtr -> Ptr a
  lengthArray0 :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO Int
  malloc :: forall a. Storable a => GHC.Types.IO (Ptr a)
  mallocArray :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocArray0 :: forall a. Storable a => Int -> GHC.Types.IO (Ptr a)
  mallocBytes :: forall a. Int -> GHC.Types.IO (Ptr a)
  mallocForeignPtr :: forall a. Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray :: forall a. Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrArray0 :: forall a. Storable a => Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: forall a. Int -> GHC.Types.IO (ForeignPtr a)
  maybeNew :: forall a b. (a -> GHC.Types.IO (Ptr b)) -> GHC.Maybe.Maybe a -> GHC.Types.IO (Ptr b)
  maybePeek :: forall a b. (Ptr a -> GHC.Types.IO b) -> Ptr a -> GHC.Types.IO (GHC.Maybe.Maybe b)
  maybeWith :: forall a b c. (a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c) -> GHC.Maybe.Maybe a -> (Ptr b -> GHC.Types.IO c) -> GHC.Types.IO c
  minusPtr :: forall a b. Ptr a -> Ptr b -> Int
  moveArray :: forall a. Storable a => Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  moveBytes :: forall a. Ptr a -> Ptr a -> Int -> GHC.Types.IO ()
  new :: forall a. Storable a => a -> GHC.Types.IO (Ptr a)
  newArray :: forall a. Storable a => [a] -> GHC.Types.IO (Ptr a)
  newArray0 :: forall a. Storable a => a -> [a] -> GHC.Types.IO (Ptr a)
  newForeignPtr :: forall a. FinalizerPtr a -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtrEnv :: forall env a. FinalizerEnvPtr env a -> Ptr env -> Ptr a -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: forall a. Ptr a -> GHC.Types.IO (ForeignPtr a)
  newPool :: GHC.Types.IO Pool
  newStablePtr :: forall a. a -> GHC.Types.IO (StablePtr a)
  nullFunPtr :: forall a. FunPtr a
  nullPtr :: forall a. Ptr a
  oneBits :: forall a. FiniteBits a => a
  peekArray :: forall a. Storable a => Int -> Ptr a -> GHC.Types.IO [a]
  peekArray0 :: forall a. (Storable a, GHC.Classes.Eq a) => a -> Ptr a -> GHC.Types.IO [a]
  plusForeignPtr :: forall a b. ForeignPtr a -> Int -> ForeignPtr b
  plusPtr :: forall a b. Ptr a -> Int -> Ptr b
  pokeArray :: forall a. Storable a => Ptr a -> [a] -> GHC.Types.IO ()
  pokeArray0 :: forall a. Storable a => a -> Ptr a -> [a] -> GHC.Types.IO ()
  pooledMalloc :: forall a. Storable a => Pool -> GHC.Types.IO (Ptr a)
  pooledMallocArray :: forall a. Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocArray0 :: forall a. Storable a => Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledMallocBytes :: forall a. Pool -> Int -> GHC.Types.IO (Ptr a)
  pooledNew :: forall a. Storable a => Pool -> a -> GHC.Types.IO (Ptr a)
  pooledNewArray :: forall a. Storable a => Pool -> [a] -> GHC.Types.IO (Ptr a)
  pooledNewArray0 :: forall a. Storable a => Pool -> a -> [a] -> GHC.Types.IO (Ptr a)
  pooledRealloc :: forall a. Storable a => Pool -> Ptr a -> GHC.Types.IO (Ptr a)
  pooledReallocArray :: forall a. Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocArray0 :: forall a. Storable a => Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  pooledReallocBytes :: forall a. Pool -> Ptr a -> Int -> GHC.Types.IO (Ptr a)
  popCountDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> Int
  ptrToIntPtr :: forall a. Ptr a -> IntPtr
  ptrToWordPtr :: forall a. Ptr a -> WordPtr
  realloc :: forall a b. Storable b => Ptr a -> GHC.Types.IO (Ptr b)
  reallocArray :: forall a. Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocArray0 :: forall a. Storable a => Ptr a -> Int -> GHC.Types.IO (Ptr a)
  reallocBytes :: forall a. Ptr a -> Int -> GHC.Types.IO (Ptr a)
  testBitDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> Int -> GHC.Types.Bool
  throwIf :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO a
  throwIfNeg_ :: forall a. (GHC.Classes.Ord a, GHC.Num.Num a) => (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  throwIfNull :: forall a. GHC.Base.String -> GHC.Types.IO (Ptr a) -> GHC.Types.IO (Ptr a)
  throwIf_ :: forall a. (a -> GHC.Types.Bool) -> (a -> GHC.Base.String) -> GHC.Types.IO a -> GHC.Types.IO ()
  toBool :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => a -> GHC.Types.Bool
  toIntegralSized :: forall a b. (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b
  touchForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  void :: forall a. GHC.Types.IO a -> GHC.Types.IO ()
  with :: forall a b. Storable a => a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray :: forall a b. Storable a => [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArray0 :: forall a b. Storable a => a -> [a] -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen :: forall a b. Storable a => [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withArrayLen0 :: forall a b. Storable a => a -> [a] -> (Int -> Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withForeignPtr :: forall a b. ForeignPtr a -> (Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withMany :: forall a b res. (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
  withPool :: forall b. (Pool -> GHC.Types.IO b) -> GHC.Types.IO b
  wordPtrToPtr :: forall a. WordPtr -> Ptr a

module Foreign.StablePtr where
  -- Safety: Trustworthy
  type StablePtr :: * -> *
  data StablePtr a = ...
  castPtrToStablePtr :: forall a. GHC.Ptr.Ptr () -> StablePtr a
  castStablePtrToPtr :: forall a. StablePtr a -> GHC.Ptr.Ptr ()
  deRefStablePtr :: forall a. StablePtr a -> GHC.Types.IO a
  freeStablePtr :: forall a. StablePtr a -> GHC.Types.IO ()
  newStablePtr :: forall a. a -> GHC.Types.IO (StablePtr a)

module Foreign.Storable where
  -- Safety: Trustworthy
  type Storable :: * -> Constraint
  class Storable a where
    sizeOf :: a -> GHC.Types.Int
    alignment :: a -> GHC.Types.Int
    peekElemOff :: GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO a
    pokeElemOff :: GHC.Ptr.Ptr a -> GHC.Types.Int -> a -> GHC.Types.IO ()
    peekByteOff :: forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> GHC.Types.IO a
    pokeByteOff :: forall b. GHC.Ptr.Ptr b -> GHC.Types.Int -> a -> GHC.Types.IO ()
    peek :: GHC.Ptr.Ptr a -> GHC.Types.IO a
    poke :: GHC.Ptr.Ptr a -> a -> GHC.Types.IO ()
    {-# MINIMAL sizeOf, alignment, (peek | peekElemOff | peekByteOff), (poke | pokeElemOff | pokeByteOff) #-}

module GHC.Arr where
  -- Safety: Unsafe
  (!) :: forall i e. Ix i => Array i e -> i -> e
  (//) :: forall i e. Ix i => Array i e -> [(i, e)] -> Array i e
  type role Array nominal representational
  type Array :: * -> * -> *
  data Array i e = Array !i !i {-# UNPACK #-}GHC.Types.Int (GHC.Prim.Array# e)
  type Ix :: * -> Constraint
  class GHC.Classes.Ord a => Ix a where
    range :: (a, a) -> [a]
    index :: (a, a) -> a -> GHC.Types.Int
    unsafeIndex :: (a, a) -> a -> GHC.Types.Int
    inRange :: (a, a) -> a -> GHC.Types.Bool
    rangeSize :: (a, a) -> GHC.Types.Int
    unsafeRangeSize :: (a, a) -> GHC.Types.Int
    {-# MINIMAL range, (index | unsafeIndex), inRange #-}
  type role STArray nominal nominal representational
  type STArray :: * -> * -> * -> *
  data STArray s i e = STArray !i !i {-# UNPACK #-}GHC.Types.Int (GHC.Prim.MutableArray# s e)
  accum :: forall i e a. Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
  accumArray :: forall i e a. Ix i => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
  adjust :: forall e a s b. (e -> a -> e) -> GHC.Prim.MutableArray# s e -> (GHC.Types.Int, a) -> GHC.ST.STRep s b -> GHC.ST.STRep s b
  amap :: forall a b i. (a -> b) -> Array i a -> Array i b
  arrEleBottom :: forall a. a
  array :: forall i e. Ix i => (i, i) -> [(i, e)] -> Array i e
  assocs :: forall i e. Ix i => Array i e -> [(i, e)]
  badSafeIndex :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  bounds :: forall i e. Array i e -> (i, i)
  boundsSTArray :: forall s i e. STArray s i e -> (i, i)
  cmpArray :: forall i e. (Ix i, GHC.Classes.Ord e) => Array i e -> Array i e -> GHC.Types.Ordering
  cmpIntArray :: forall e. GHC.Classes.Ord e => Array GHC.Types.Int e -> Array GHC.Types.Int e -> GHC.Types.Ordering
  done :: forall i s e. i -> i -> GHC.Types.Int -> GHC.Prim.MutableArray# s e -> GHC.ST.STRep s (Array i e)
  elems :: forall i e. Array i e -> [e]
  eqArray :: forall i e. (Ix i, GHC.Classes.Eq e) => Array i e -> Array i e -> GHC.Types.Bool
  fill :: forall s e a. GHC.Prim.MutableArray# s e -> (GHC.Types.Int, e) -> GHC.ST.STRep s a -> GHC.ST.STRep s a
  foldl1Elems :: forall a i. (a -> a -> a) -> Array i a -> a
  foldlElems :: forall b a i. (b -> a -> b) -> b -> Array i a -> b
  foldlElems' :: forall b a i. (b -> a -> b) -> b -> Array i a -> b
  foldr1Elems :: forall a i. (a -> a -> a) -> Array i a -> a
  foldrElems :: forall a b i. (a -> b -> b) -> b -> Array i a -> b
  foldrElems' :: forall a b i. (a -> b -> b) -> b -> Array i a -> b
  freezeSTArray :: forall s i e. STArray s i e -> GHC.ST.ST s (Array i e)
  indices :: forall i e. Ix i => Array i e -> [i]
  ixmap :: forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
  lessSafeIndex :: forall i. Ix i => (i, i) -> GHC.Types.Int -> i -> GHC.Types.Int
  listArray :: forall i e. Ix i => (i, i) -> [e] -> Array i e
  negRange :: GHC.Types.Int
  newSTArray :: forall i e s. Ix i => (i, i) -> e -> GHC.ST.ST s (STArray s i e)
  numElements :: forall i e. Array i e -> GHC.Types.Int
  numElementsSTArray :: forall s i e. STArray s i e -> GHC.Types.Int
  readSTArray :: forall i s e. Ix i => STArray s i e -> i -> GHC.ST.ST s e
  safeIndex :: forall i. Ix i => (i, i) -> GHC.Types.Int -> i -> GHC.Types.Int
  safeRangeSize :: forall i. Ix i => (i, i) -> GHC.Types.Int
  thawSTArray :: forall i e s. Array i e -> GHC.ST.ST s (STArray s i e)
  unsafeAccum :: forall e a i. (e -> a -> e) -> Array i e -> [(GHC.Types.Int, a)] -> Array i e
  unsafeAccumArray :: forall i e a. Ix i => (e -> a -> e) -> e -> (i, i) -> [(GHC.Types.Int, a)] -> Array i e
  unsafeAccumArray' :: forall e a i. (e -> a -> e) -> e -> (i, i) -> GHC.Types.Int -> [(GHC.Types.Int, a)] -> Array i e
  unsafeArray :: forall i e. Ix i => (i, i) -> [(GHC.Types.Int, e)] -> Array i e
  unsafeArray' :: forall i e. (i, i) -> GHC.Types.Int -> [(GHC.Types.Int, e)] -> Array i e
  unsafeAt :: forall i e. Array i e -> GHC.Types.Int -> e
  unsafeFreezeSTArray :: forall s i e. STArray s i e -> GHC.ST.ST s (Array i e)
  unsafeReadSTArray :: forall s i e. STArray s i e -> GHC.Types.Int -> GHC.ST.ST s e
  unsafeReplace :: forall i e. Array i e -> [(GHC.Types.Int, e)] -> Array i e
  unsafeThawSTArray :: forall i e s. Array i e -> GHC.ST.ST s (STArray s i e)
  unsafeWriteSTArray :: forall s i e. STArray s i e -> GHC.Types.Int -> e -> GHC.ST.ST s ()
  writeSTArray :: forall i s e. Ix i => STArray s i e -> i -> e -> GHC.ST.ST s ()

module GHC.ArrayArray where
  -- Safety: Trustworthy
  type ArrayArray# :: GHC.Types.UnliftedType
  newtype ArrayArray# = ArrayArray# (GHC.Prim.Array# GHC.Prim.ByteArray#)
  type role MutableArrayArray# nominal
  type MutableArrayArray# :: * -> GHC.Types.UnliftedType
  newtype MutableArrayArray# s = MutableArrayArray# (GHC.Prim.MutableArray# s GHC.Prim.ByteArray#)
  copyArrayArray# :: forall s. ArrayArray# -> GHC.Prim.Int# -> MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.State# s -> GHC.Prim.State# s
  copyMutableArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.State# s -> GHC.Prim.State# s
  indexArrayArrayArray# :: ArrayArray# -> GHC.Prim.Int# -> ArrayArray#
  indexByteArrayArray# :: ArrayArray# -> GHC.Prim.Int# -> GHC.Prim.ByteArray#
  newArrayArray# :: forall s. GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, MutableArrayArray# s #)
  readArrayArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, ArrayArray# #)
  readByteArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.ByteArray# #)
  readMutableArrayArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, MutableArrayArray# s #)
  readMutableByteArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.MutableByteArray# s #)
  sameArrayArray# :: ArrayArray# -> ArrayArray# -> GHC.Prim.Int#
  sameMutableArrayArray# :: forall s. MutableArrayArray# s -> MutableArrayArray# s -> GHC.Prim.Int#
  sizeofArrayArray# :: ArrayArray# -> GHC.Prim.Int#
  sizeofMutableArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int#
  unsafeFreezeArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.State# s -> (# GHC.Prim.State# s, ArrayArray# #)
  writeArrayArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> ArrayArray# -> GHC.Prim.State# s -> GHC.Prim.State# s
  writeByteArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.ByteArray# -> GHC.Prim.State# s -> GHC.Prim.State# s
  writeMutableArrayArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> MutableArrayArray# s -> GHC.Prim.State# s -> GHC.Prim.State# s
  writeMutableByteArrayArray# :: forall s. MutableArrayArray# s -> GHC.Prim.Int# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.State# s -> GHC.Prim.State# s

module GHC.Base where
  -- Safety: Unsafe
  ($) :: forall (repa :: RuntimeRep) (repb :: RuntimeRep) (a :: TYPE repa) (b :: TYPE repb). (a -> b) -> a -> b
  ($!) :: forall (r :: RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
  (&&) :: Bool -> Bool -> Bool
  (*#) :: Int# -> Int# -> Int#
  (*##) :: Double# -> Double# -> Double#
  (**##) :: Double# -> Double# -> Double#
  (+#) :: Int# -> Int# -> Int#
  (+##) :: Double# -> Double# -> Double#
  (++) :: forall a. [a] -> [a] -> [a]
  (-#) :: Int# -> Int# -> Int#
  (-##) :: Double# -> Double# -> Double#
  (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
  (/##) :: Double# -> Double# -> Double#
  (/=#) :: Int# -> Int# -> Int#
  (/=##) :: Double# -> Double# -> Int#
  (<#) :: Int# -> Int# -> Int#
  (<##) :: Double# -> Double# -> Int#
  (<**>) :: forall (f :: * -> *) a b. Applicative f => f a -> f (a -> b) -> f b
  (<=#) :: Int# -> Int# -> Int#
  (<=##) :: Double# -> Double# -> Int#
  (=<<) :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> m a -> m b
  (==#) :: Int# -> Int# -> Int#
  (==##) :: Double# -> Double# -> Int#
  (>#) :: Int# -> Int# -> Int#
  (>##) :: Double# -> Double# -> Int#
  (>=#) :: Int# -> Int# -> Int#
  (>=##) :: Double# -> Double# -> Int#
  type Addr# :: TYPE AddrRep
  data Addr#
  type Alternative :: (* -> *) -> Constraint
  class Applicative f => Alternative f where
    empty :: forall a. f a
    (<|>) :: forall a. f a -> f a -> f a
    some :: forall a. f a -> f [a]
    many :: forall a. f a -> f [a]
    {-# MINIMAL empty, (<|>) #-}
  type Any :: forall k. k
  type family Any where
  type Applicative :: (* -> *) -> Constraint
  class Functor f => Applicative f where
    pure :: forall a. a -> f a
    (<*>) :: forall a b. f (a -> b) -> f a -> f b
    liftA2 :: forall a b c. (a -> b -> c) -> f a -> f b -> f c
    (*>) :: forall a b. f a -> f b -> f b
    (<*) :: forall a b. f a -> f b -> f a
    {-# MINIMAL pure, ((<*>) | liftA2) #-}
  type Array# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data Array# a
  type BCO :: *
  data BCO
  type Bool :: *
  data Bool = False | True
  type ByteArray# :: UnliftedType
  data ByteArray#
  type role CONSTRAINT nominal
  type CONSTRAINT :: RuntimeRep -> *
  data CONSTRAINT a
  type Char :: *
  data Char = C# Char#
  type Char# :: TYPE WordRep
  data Char#
  type role Coercible representational representational
  type Coercible :: forall k. k -> k -> Constraint
  class Coercible a b => Coercible a b
    {-# MINIMAL #-}
  type Compact# :: UnliftedType
  data Compact#
  type Constraint :: *
  type Constraint = CONSTRAINT LiftedRep
  type DictBox :: Constraint -> *
  data DictBox a = a => MkDictBox
  type Double :: *
  data Double = D# Double#
  type Double# :: TYPE DoubleRep
  data Double#
  type DoubleBox :: TYPE DoubleRep -> *
  data DoubleBox a = MkDoubleBox a
  type DoubleX2# :: TYPE (VecRep Vec2 DoubleElemRep)
  data DoubleX2#
  type DoubleX4# :: TYPE (VecRep Vec4 DoubleElemRep)
  data DoubleX4#
  type DoubleX8# :: TYPE (VecRep Vec8 DoubleElemRep)
  data DoubleX8#
  type Eq :: * -> Constraint
  class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    {-# MINIMAL (==) | (/=) #-}
  type role FUN nominal representational representational
  type FUN :: forall (n :: Multiplicity) -> forall {q :: RuntimeRep} {r :: RuntimeRep}. TYPE q -> TYPE r -> *
  data FUN n a b
  type Float :: *
  data Float = F# Float#
  type Float# :: TYPE FloatRep
  data Float#
  type FloatBox :: TYPE FloatRep -> *
  data FloatBox a = MkFloatBox a
  type FloatX16# :: TYPE (VecRep Vec16 FloatElemRep)
  data FloatX16#
  type FloatX4# :: TYPE (VecRep Vec4 FloatElemRep)
  data FloatX4#
  type FloatX8# :: TYPE (VecRep Vec8 FloatElemRep)
  data FloatX8#
  type Functor :: (* -> *) -> Constraint
  class Functor f where
    fmap :: forall a b. (a -> b) -> f a -> f b
    (<$) :: forall a b. a -> f b -> f a
    {-# MINIMAL fmap #-}
  type IO :: * -> *
  newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
  type role IOPort# nominal representational
  type IOPort# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data IOPort# a b
  type IP :: Symbol -> * -> Constraint
  class IP x a | x -> a where
    ip :: a
    {-# MINIMAL ip #-}
  type Int :: *
  data Int = I# Int#
  type Int# :: TYPE IntRep
  data Int#
  type Int16# :: TYPE Int16Rep
  data Int16#
  type Int16X16# :: TYPE (VecRep Vec16 Int16ElemRep)
  data Int16X16#
  type Int16X32# :: TYPE (VecRep Vec32 Int16ElemRep)
  data Int16X32#
  type Int16X8# :: TYPE (VecRep Vec8 Int16ElemRep)
  data Int16X8#
  type Int32# :: TYPE Int32Rep
  data Int32#
  type Int32X16# :: TYPE (VecRep Vec16 Int32ElemRep)
  data Int32X16#
  type Int32X4# :: TYPE (VecRep Vec4 Int32ElemRep)
  data Int32X4#
  type Int32X8# :: TYPE (VecRep Vec8 Int32ElemRep)
  data Int32X8#
  type Int64# :: TYPE Int64Rep
  data Int64#
  type Int64X2# :: TYPE (VecRep Vec2 Int64ElemRep)
  data Int64X2#
  type Int64X4# :: TYPE (VecRep Vec4 Int64ElemRep)
  data Int64X4#
  type Int64X8# :: TYPE (VecRep Vec8 Int64ElemRep)
  data Int64X8#
  type Int8# :: TYPE Int8Rep
  data Int8#
  type Int8X16# :: TYPE (VecRep Vec16 Int8ElemRep)
  data Int8X16#
  type Int8X32# :: TYPE (VecRep Vec32 Int8ElemRep)
  data Int8X32#
  type Int8X64# :: TYPE (VecRep Vec64 Int8ElemRep)
  data Int8X64#
  type IntBox :: TYPE IntRep -> *
  data IntBox a = MkIntBox a
  type KindBndr :: *
  type KindBndr = Int
  type KindRep :: *
  data KindRep = KindRepTyConApp TyCon [KindRep] | KindRepVar {-# UNPACK #-}KindBndr | KindRepApp KindRep KindRep | KindRepFun KindRep KindRep | KindRepTYPE !RuntimeRep | KindRepTypeLitS TypeLitSort Addr# | KindRepTypeLitD TypeLitSort [Char]
  type Levity :: *
  data Levity = Lifted | Unlifted
  type LiftedRep :: RuntimeRep
  type LiftedRep = BoxedRep Lifted :: RuntimeRep
  type List :: * -> *
  data List a = ...
  type role MVar# nominal representational
  type MVar# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data MVar# a b
  type Maybe :: * -> *
  data Maybe a = Nothing | Just a
  type Module :: *
  data Module = Module TrName TrName
  type Monad :: (* -> *) -> Constraint
  class Applicative m => Monad m where
    (>>=) :: forall a b. m a -> (a -> m b) -> m b
    (>>) :: forall a b. m a -> m b -> m b
    return :: forall a. a -> m a
    {-# MINIMAL (>>=) #-}
  type MonadPlus :: (* -> *) -> Constraint
  class (Alternative m, Monad m) => MonadPlus m where
    mzero :: forall a. m a
    mplus :: forall a. m a -> m a -> m a
    {-# MINIMAL #-}
  type Monoid :: * -> Constraint
  class Semigroup a => Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    mconcat :: [a] -> a
    {-# MINIMAL mempty | mconcat #-}
  type MultMul :: Multiplicity -> Multiplicity -> Multiplicity
  type family MultMul a b where
    forall (x :: Multiplicity). MultMul One x = x
    forall (x :: Multiplicity). MultMul x One = x
    forall (x :: Multiplicity). MultMul Many x = Many
    forall (x :: Multiplicity). MultMul x Many = Many
  type Multiplicity :: *
  data Multiplicity = One | Many
  type role MutVar# nominal representational
  type MutVar# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data MutVar# a b
  type role MutableArray# nominal representational
  type MutableArray# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data MutableArray# a b
  type role MutableByteArray# nominal
  type MutableByteArray# :: * -> UnliftedType
  data MutableByteArray# a
  type NonEmpty :: * -> *
  data NonEmpty a = a :| [a]
  type Opaque :: *
  data Opaque = forall a. O a
  type Ord :: * -> Constraint
  class Eq a => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (>=) :: a -> a -> Bool
    max :: a -> a -> a
    min :: a -> a -> a
    {-# MINIMAL compare | (<=) #-}
  type Ordering :: *
  data Ordering = LT | EQ | GT
  type PromptTag# :: * -> UnliftedType
  data PromptTag# a
  type role Proxy# phantom
  type Proxy# :: forall k. k -> ZeroBitType
  data Proxy# a
  type RealWorld :: *
  data RealWorld
  type RuntimeRep :: *
  data RuntimeRep = VecRep VecCount VecElem | TupleRep [RuntimeRep] | SumRep [RuntimeRep] | BoxedRep Levity | IntRep | Int8Rep | Int16Rep | Int32Rep | Int64Rep | WordRep | Word8Rep | Word16Rep | Word32Rep | Word64Rep | AddrRep | FloatRep | DoubleRep
  type SPEC :: *
  data SPEC = SPEC | SPEC2
  type Semigroup :: * -> Constraint
  class Semigroup a where
    (<>) :: a -> a -> a
    sconcat :: NonEmpty a -> a
    stimes :: forall b. GHC.Real.Integral b => b -> a -> a
    {-# MINIMAL (<>) | sconcat #-}
  type SmallArray# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data SmallArray# a
  type role SmallMutableArray# nominal representational
  type SmallMutableArray# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data SmallMutableArray# a b
  type role StableName# phantom
  type StableName# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data StableName# a
  type StablePtr# :: forall {l :: Levity}. TYPE (BoxedRep l) -> TYPE AddrRep
  data StablePtr# a
  type StackSnapshot# :: UnliftedType
  data StackSnapshot#
  type role State# nominal
  type State# :: * -> ZeroBitType
  data State# a
  type String :: *
  type String = [Char]
  type Symbol :: *
  data Symbol
  type role TVar# nominal representational
  type TVar# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data TVar# a b
  type role TYPE nominal
  type TYPE :: RuntimeRep -> *
  data TYPE a
  type ThreadId# :: UnliftedType
  data ThreadId#
  type TrName :: *
  data TrName = TrNameS Addr# | TrNameD [Char]
  type TyCon :: *
  data TyCon = TyCon Word64# Word64# Module TrName Int# KindRep
  type Type :: *
  type Type = TYPE LiftedRep
  type TypeLitSort :: *
  data TypeLitSort = TypeLitSymbol | TypeLitNat | TypeLitChar
  type UnliftedRep :: RuntimeRep
  type UnliftedRep = BoxedRep Unlifted :: RuntimeRep
  type UnliftedType :: *
  type UnliftedType = TYPE UnliftedRep
  type VecCount :: *
  data VecCount = Vec2 | Vec4 | Vec8 | Vec16 | Vec32 | Vec64
  type VecElem :: *
  data VecElem = Int8ElemRep | Int16ElemRep | Int32ElemRep | Int64ElemRep | Word8ElemRep | Word16ElemRep | Word32ElemRep | Word64ElemRep | FloatElemRep | DoubleElemRep
  type Void :: *
  data Void
  type Void# :: ZeroBitType
  type Void# = (# #) :: ZeroBitType
  type Weak# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data Weak# a
  type WithDict :: Constraint -> * -> Constraint
  class WithDict cls meth where
    withDict :: forall {rr :: RuntimeRep} (r :: TYPE rr). meth -> (cls => r) -> r
    {-# MINIMAL withDict #-}
  type Word :: *
  data Word = W# Word#
  type Word# :: TYPE WordRep
  data Word#
  type Word16# :: TYPE Word16Rep
  data Word16#
  type Word16X16# :: TYPE (VecRep Vec16 Word16ElemRep)
  data Word16X16#
  type Word16X32# :: TYPE (VecRep Vec32 Word16ElemRep)
  data Word16X32#
  type Word16X8# :: TYPE (VecRep Vec8 Word16ElemRep)
  data Word16X8#
  type Word32# :: TYPE Word32Rep
  data Word32#
  type Word32X16# :: TYPE (VecRep Vec16 Word32ElemRep)
  data Word32X16#
  type Word32X4# :: TYPE (VecRep Vec4 Word32ElemRep)
  data Word32X4#
  type Word32X8# :: TYPE (VecRep Vec8 Word32ElemRep)
  data Word32X8#
  type Word64# :: TYPE Word64Rep
  data Word64#
  type Word64X2# :: TYPE (VecRep Vec2 Word64ElemRep)
  data Word64X2#
  type Word64X4# :: TYPE (VecRep Vec4 Word64ElemRep)
  data Word64X4#
  type Word64X8# :: TYPE (VecRep Vec8 Word64ElemRep)
  data Word64X8#
  type Word8# :: TYPE Word8Rep
  data Word8#
  type Word8X16# :: TYPE (VecRep Vec16 Word8ElemRep)
  data Word8X16#
  type Word8X32# :: TYPE (VecRep Vec32 Word8ElemRep)
  data Word8X32#
  type Word8X64# :: TYPE (VecRep Vec64 Word8ElemRep)
  data Word8X64#
  type WordBox :: TYPE WordRep -> *
  data WordBox a = MkWordBox a
  type ZeroBitRep :: RuntimeRep
  type ZeroBitRep = TupleRep '[] :: RuntimeRep
  type ZeroBitType :: *
  type ZeroBitType = TYPE ZeroBitRep
  absentErr :: forall a. a
  absurd :: forall a. Void -> a
  acosDouble# :: Double# -> Double#
  acosFloat# :: Float# -> Float#
  acoshDouble# :: Double# -> Double#
  acoshFloat# :: Float# -> Float#
  addCFinalizerToWeak# :: forall {k :: Levity} (b :: TYPE (BoxedRep k)). Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
  addIntC# :: Int# -> Int# -> (# Int#, Int# #)
  addWordC# :: Word# -> Word# -> (# Word#, Int# #)
  addr2Int# :: Addr# -> Int#
  addrToAny# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Addr# -> (# a #)
  and# :: Word# -> Word# -> Word#
  and64# :: Word64# -> Word64# -> Word64#
  andI# :: Int# -> Int# -> Int#
  andWord16# :: Word16# -> Word16# -> Word16#
  andWord32# :: Word32# -> Word32# -> Word32#
  andWord8# :: Word8# -> Word8# -> Word8#
  anyToAddr# :: forall a. a -> State# RealWorld -> (# State# RealWorld, Addr# #)
  ap :: forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
  asTypeOf :: forall a. a -> a -> a
  asinDouble# :: Double# -> Double#
  asinFloat# :: Float# -> Float#
  asinhDouble# :: Double# -> Double#
  asinhFloat# :: Float# -> Float#
  assert :: forall a. Bool -> a -> a
  atanDouble# :: Double# -> Double#
  atanFloat# :: Float# -> Float#
  atanhDouble# :: Double# -> Double#
  atanhFloat# :: Float# -> Float#
  atomicCasAddrAddr# :: forall d. Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicCasWord16Addr# :: forall d. Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)
  atomicCasWord32Addr# :: forall d. Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)
  atomicCasWord64Addr# :: forall d. Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)
  atomicCasWord8Addr# :: forall d. Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)
  atomicCasWordAddr# :: forall d. Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)
  atomicExchangeAddrAddr# :: forall d. Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicExchangeWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  atomicModifyMutVar2# :: forall d a c. MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)
  atomicModifyMutVar_# :: forall d a. MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)
  atomicReadIntArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  atomicReadWordAddr# :: forall d. Addr# -> State# d -> (# State# d, Word# #)
  atomicSwapMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> a -> State# d -> (# State# d, a #)
  atomicWriteIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  atomicWriteWordAddr# :: forall d. Addr# -> Word# -> State# d -> State# d
  atomically# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
  bindIO :: forall a b. IO a -> (a -> IO b) -> IO b
  bitReverse# :: Word# -> Word#
  bitReverse16# :: Word# -> Word#
  bitReverse32# :: Word# -> Word#
  bitReverse64# :: Word64# -> Word64#
  bitReverse8# :: Word# -> Word#
  breakpoint :: forall a. a -> a
  breakpointCond :: forall a. Bool -> a -> a
  broadcastDoubleX2# :: Double# -> DoubleX2#
  broadcastDoubleX4# :: Double# -> DoubleX4#
  broadcastDoubleX8# :: Double# -> DoubleX8#
  broadcastFloatX16# :: Float# -> FloatX16#
  broadcastFloatX4# :: Float# -> FloatX4#
  broadcastFloatX8# :: Float# -> FloatX8#
  broadcastInt16X16# :: Int16# -> Int16X16#
  broadcastInt16X32# :: Int16# -> Int16X32#
  broadcastInt16X8# :: Int16# -> Int16X8#
  broadcastInt32X16# :: Int32# -> Int32X16#
  broadcastInt32X4# :: Int32# -> Int32X4#
  broadcastInt32X8# :: Int32# -> Int32X8#
  broadcastInt64X2# :: Int64# -> Int64X2#
  broadcastInt64X4# :: Int64# -> Int64X4#
  broadcastInt64X8# :: Int64# -> Int64X8#
  broadcastInt8X16# :: Int8# -> Int8X16#
  broadcastInt8X32# :: Int8# -> Int8X32#
  broadcastInt8X64# :: Int8# -> Int8X64#
  broadcastWord16X16# :: Word16# -> Word16X16#
  broadcastWord16X32# :: Word16# -> Word16X32#
  broadcastWord16X8# :: Word16# -> Word16X8#
  broadcastWord32X16# :: Word32# -> Word32X16#
  broadcastWord32X4# :: Word32# -> Word32X4#
  broadcastWord32X8# :: Word32# -> Word32X8#
  broadcastWord64X2# :: Word64# -> Word64X2#
  broadcastWord64X4# :: Word64# -> Word64X4#
  broadcastWord64X8# :: Word64# -> Word64X8#
  broadcastWord8X16# :: Word8# -> Word8X16#
  broadcastWord8X32# :: Word8# -> Word8X32#
  broadcastWord8X64# :: Word8# -> Word8X64#
  build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
  byteArrayContents# :: ByteArray# -> Addr#
  byteSwap# :: Word# -> Word#
  byteSwap16# :: Word# -> Word#
  byteSwap32# :: Word# -> Word#
  byteSwap64# :: Word64# -> Word64#
  casArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  casInt16Array# :: forall d. MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)
  casInt32Array# :: forall d. MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)
  casInt64Array# :: forall d. MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)
  casInt8Array# :: forall d. MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)
  casIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  casMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)
  casSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  catch# :: forall {q :: RuntimeRep} {k :: Levity} (a :: TYPE q) (b :: TYPE (BoxedRep k)). (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchRetry# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchSTM# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) b. (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  chr# :: Int# -> Char#
  clearCCS# :: forall d a. (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)
  cloneArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Int# -> Int# -> Array# a
  cloneMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  cloneSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> Int# -> Int# -> SmallArray# a
  cloneSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  closureSize# :: forall a. a -> Int#
  clz# :: Word# -> Word#
  clz16# :: Word# -> Word#
  clz32# :: Word# -> Word#
  clz64# :: Word64# -> Word#
  clz8# :: Word# -> Word#
  coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b
  compactAdd# :: forall a. Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAddWithSharing# :: forall a. Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
  compactContains# :: forall a. Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactContainsAny# :: forall a. a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
  compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
  compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
  compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
  compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
  compareInt :: Int -> Int -> Ordering
  compareInt# :: Int# -> Int# -> Ordering
  compareWord :: Word -> Word -> Ordering
  compareWord# :: Word# -> Word# -> Ordering
  const :: forall a b. a -> b -> a
  control0# :: forall {r :: RuntimeRep} a (b :: TYPE r). PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)
  copyAddrToAddr# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld
  copyAddrToAddrNonOverlapping# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld
  copyAddrToByteArray# :: forall d. Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyByteArray# :: forall d. ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyByteArrayToAddr# :: forall d. ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d
  copyMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArray# :: forall d. MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArrayNonOverlapping# :: forall d. MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArrayToAddr# :: forall d. MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d
  copySmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copySmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  cosDouble# :: Double# -> Double#
  cosFloat# :: Float# -> Float#
  coshDouble# :: Double# -> Double#
  coshFloat# :: Float# -> Float#
  cstringLength# :: Addr# -> Int#
  ctz# :: Word# -> Word#
  ctz16# :: Word# -> Word#
  ctz32# :: Word# -> Word#
  ctz64# :: Word64# -> Word#
  ctz8# :: Word# -> Word#
  dataToTag# :: forall a. a -> Int#
  deRefStablePtr# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
  deRefWeak# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
  decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
  decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
  decodeFloat_Int# :: Float# -> (# Int#, Int# #)
  delay# :: forall d. Int# -> State# d -> State# d
  divInt :: Int -> Int -> Int
  divInt# :: Int# -> Int# -> Int#
  divInt16# :: Int16# -> Int16# -> Int16#
  divInt32# :: Int32# -> Int32# -> Int32#
  divInt8# :: Int8# -> Int8# -> Int8#
  divModInt :: Int -> Int -> (Int, Int)
  divModInt# :: Int# -> Int# -> (# Int#, Int# #)
  divModInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
  divModInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
  divModInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
  divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  divideFloat# :: Float# -> Float# -> Float#
  divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  double2Float# :: Double# -> Float#
  double2Int# :: Double# -> Int#
  eqAddr# :: Addr# -> Addr# -> Int#
  eqChar :: Char -> Char -> Bool
  eqChar# :: Char# -> Char# -> Int#
  eqDouble :: Double -> Double -> Bool
  eqFloat :: Float -> Float -> Bool
  eqFloat# :: Float# -> Float# -> Int#
  eqInt :: Int -> Int -> Bool
  eqInt16# :: Int16# -> Int16# -> Int#
  eqInt32# :: Int32# -> Int32# -> Int#
  eqInt64# :: Int64# -> Int64# -> Int#
  eqInt8# :: Int8# -> Int8# -> Int#
  eqStableName# :: forall {k :: Levity} {l :: Levity} (a :: TYPE (BoxedRep k)) (b :: TYPE (BoxedRep l)). StableName# a -> StableName# b -> Int#
  eqStablePtr# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). StablePtr# a -> StablePtr# a -> Int#
  eqString :: String -> String -> Bool
  eqWord :: Word -> Word -> Bool
  eqWord# :: Word# -> Word# -> Int#
  eqWord16# :: Word16# -> Word16# -> Int#
  eqWord32# :: Word32# -> Word32# -> Int#
  eqWord64# :: Word64# -> Word64# -> Int#
  eqWord8# :: Word8# -> Word8# -> Int#
  error :: forall (r :: RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => [Char] -> a
  errorWithoutStackTrace :: forall (r :: RuntimeRep) (a :: TYPE r). [Char] -> a
  expDouble# :: Double# -> Double#
  expFloat# :: Float# -> Float#
  expm1Double# :: Double# -> Double#
  expm1Float# :: Float# -> Float#
  fabsDouble# :: Double# -> Double#
  fabsFloat# :: Float# -> Float#
  failIO :: forall a. String -> IO a
  fetchAddIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAddWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchAndIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAndWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchNandIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchNandWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchOrIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchOrWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchSubIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchSubWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchXorIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchXorWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  finalizeWeak# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) b. Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
  flip :: forall a b c. (a -> b -> c) -> b -> a -> c
  float2Double# :: Float# -> Double#
  float2Int# :: Float# -> Int#
  fmaddDouble# :: Double# -> Double# -> Double# -> Double#
  fmaddFloat# :: Float# -> Float# -> Float# -> Float#
  fmsubDouble# :: Double# -> Double# -> Double# -> Double#
  fmsubFloat# :: Float# -> Float# -> Float# -> Float#
  fnmaddDouble# :: Double# -> Double# -> Double# -> Double#
  fnmaddFloat# :: Float# -> Float# -> Float# -> Float#
  fnmsubDouble# :: Double# -> Double# -> Double# -> Double#
  fnmsubFloat# :: Float# -> Float# -> Float# -> Float#
  foldr :: forall a b. (a -> b -> b) -> b -> [a] -> b
  fork# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  forkOn# :: forall {q :: RuntimeRep} (a :: TYPE q). Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  freezeArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)
  freezeSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
  geAddr# :: Addr# -> Addr# -> Int#
  geChar# :: Char# -> Char# -> Int#
  geFloat# :: Float# -> Float# -> Int#
  geInt :: Int -> Int -> Bool
  geInt16# :: Int16# -> Int16# -> Int#
  geInt32# :: Int32# -> Int32# -> Int#
  geInt64# :: Int64# -> Int64# -> Int#
  geInt8# :: Int8# -> Int8# -> Int#
  geWord :: Word -> Word -> Bool
  geWord# :: Word# -> Word# -> Int#
  geWord16# :: Word16# -> Word16# -> Int#
  geWord32# :: Word32# -> Word32# -> Int#
  geWord64# :: Word64# -> Word64# -> Int#
  geWord8# :: Word8# -> Word8# -> Int#
  getApStackVal# :: forall a b. a -> Int# -> (# Int#, b #)
  getCCSOf# :: forall a d. a -> State# d -> (# State# d, Addr# #)
  getCurrentCCS# :: forall a d. a -> State# d -> (# State# d, Addr# #)
  getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
  getSizeofMutableByteArray# :: forall d. MutableByteArray# d -> State# d -> (# State# d, Int# #)
  getSizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, Int# #)
  getSpark# :: forall d a. State# d -> (# State# d, Int#, a #)
  getTag :: forall a. a -> Int#
  getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int64# #)
  gtAddr# :: Addr# -> Addr# -> Int#
  gtChar# :: Char# -> Char# -> Int#
  gtFloat# :: Float# -> Float# -> Int#
  gtInt :: Int -> Int -> Bool
  gtInt16# :: Int16# -> Int16# -> Int#
  gtInt32# :: Int32# -> Int32# -> Int#
  gtInt64# :: Int64# -> Int64# -> Int#
  gtInt8# :: Int8# -> Int8# -> Int#
  gtWord :: Word -> Word -> Bool
  gtWord# :: Word# -> Word# -> Int#
  gtWord16# :: Word16# -> Word16# -> Int#
  gtWord32# :: Word32# -> Word32# -> Int#
  gtWord64# :: Word64# -> Word64# -> Int#
  gtWord8# :: Word8# -> Word8# -> Int#
  iShiftL# :: Int# -> Int# -> Int#
  iShiftRA# :: Int# -> Int# -> Int#
  iShiftRL# :: Int# -> Int# -> Int#
  id :: forall a. a -> a
  indexAddrArray# :: ByteArray# -> Int# -> Addr#
  indexAddrOffAddr# :: Addr# -> Int# -> Addr#
  indexArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Int# -> (# a #)
  indexCharArray# :: ByteArray# -> Int# -> Char#
  indexCharOffAddr# :: Addr# -> Int# -> Char#
  indexDoubleArray# :: ByteArray# -> Int# -> Double#
  indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleOffAddr# :: Addr# -> Int# -> Double#
  indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#
  indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#
  indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#
  indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#
  indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#
  indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#
  indexFloatArray# :: ByteArray# -> Int# -> Float#
  indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#
  indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#
  indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#
  indexFloatOffAddr# :: Addr# -> Int# -> Float#
  indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#
  indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#
  indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#
  indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#
  indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#
  indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#
  indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#
  indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#
  indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#
  indexInt16Array# :: ByteArray# -> Int# -> Int16#
  indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#
  indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#
  indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#
  indexInt16OffAddr# :: Addr# -> Int# -> Int16#
  indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#
  indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#
  indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#
  indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#
  indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#
  indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#
  indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#
  indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#
  indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#
  indexInt32Array# :: ByteArray# -> Int# -> Int32#
  indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#
  indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#
  indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#
  indexInt32OffAddr# :: Addr# -> Int# -> Int32#
  indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#
  indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#
  indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#
  indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#
  indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#
  indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#
  indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#
  indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#
  indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#
  indexInt64Array# :: ByteArray# -> Int# -> Int64#
  indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#
  indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#
  indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#
  indexInt64OffAddr# :: Addr# -> Int# -> Int64#
  indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#
  indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#
  indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#
  indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#
  indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#
  indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#
  indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#
  indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#
  indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#
  indexInt8Array# :: ByteArray# -> Int# -> Int8#
  indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#
  indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#
  indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#
  indexInt8OffAddr# :: Addr# -> Int# -> Int8#
  indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#
  indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#
  indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#
  indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#
  indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#
  indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#
  indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#
  indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#
  indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#
  indexIntArray# :: ByteArray# -> Int# -> Int#
  indexIntOffAddr# :: Addr# -> Int# -> Int#
  indexSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> Int# -> (# a #)
  indexStablePtrArray# :: forall a. ByteArray# -> Int# -> StablePtr# a
  indexStablePtrOffAddr# :: forall a. Addr# -> Int# -> StablePtr# a
  indexWideCharArray# :: ByteArray# -> Int# -> Char#
  indexWideCharOffAddr# :: Addr# -> Int# -> Char#
  indexWord16Array# :: ByteArray# -> Int# -> Word16#
  indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#
  indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#
  indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#
  indexWord16OffAddr# :: Addr# -> Int# -> Word16#
  indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#
  indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#
  indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#
  indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#
  indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#
  indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#
  indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#
  indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#
  indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#
  indexWord32Array# :: ByteArray# -> Int# -> Word32#
  indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#
  indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#
  indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#
  indexWord32OffAddr# :: Addr# -> Int# -> Word32#
  indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#
  indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#
  indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#
  indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#
  indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#
  indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#
  indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#
  indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#
  indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#
  indexWord64Array# :: ByteArray# -> Int# -> Word64#
  indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#
  indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#
  indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#
  indexWord64OffAddr# :: Addr# -> Int# -> Word64#
  indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#
  indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#
  indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#
  indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#
  indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#
  indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#
  indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#
  indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#
  indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#
  indexWord8Array# :: ByteArray# -> Int# -> Word8#
  indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
  indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
  indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
  indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
  indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#
  indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#
  indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#
  indexWord8ArrayAsStablePtr# :: forall a. ByteArray# -> Int# -> StablePtr# a
  indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
  indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#
  indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#
  indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#
  indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#
  indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#
  indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#
  indexWord8OffAddr# :: Addr# -> Int# -> Word8#
  indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#
  indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#
  indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#
  indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#
  indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#
  indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#
  indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#
  indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#
  indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#
  indexWordArray# :: ByteArray# -> Int# -> Word#
  indexWordOffAddr# :: Addr# -> Int# -> Word#
  inline :: forall a. a -> a
  insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#
  insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#
  insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#
  insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#
  insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#
  insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#
  insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#
  insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#
  insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#
  insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#
  insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#
  insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#
  insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#
  insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#
  insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#
  insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#
  insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#
  insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#
  insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#
  insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#
  insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#
  insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#
  insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#
  insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#
  insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#
  insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#
  insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#
  insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#
  insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#
  insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#
  int16ToInt# :: Int16# -> Int#
  int16ToWord16# :: Int16# -> Word16#
  int2Addr# :: Int# -> Addr#
  int2Double# :: Int# -> Double#
  int2Float# :: Int# -> Float#
  int2Word# :: Int# -> Word#
  int32ToInt# :: Int32# -> Int#
  int32ToWord32# :: Int32# -> Word32#
  int64ToInt# :: Int64# -> Int#
  int64ToWord64# :: Int64# -> Word64#
  int8ToInt# :: Int8# -> Int#
  int8ToWord8# :: Int8# -> Word8#
  intToInt16# :: Int# -> Int16#
  intToInt32# :: Int# -> Int32#
  intToInt64# :: Int# -> Int64#
  intToInt8# :: Int# -> Int8#
  isByteArrayPinned# :: ByteArray# -> Int#
  isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
  isEmptyMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int# #)
  isMutableByteArrayPinned# :: forall d. MutableByteArray# d -> Int#
  isTrue# :: Int# -> Bool
  join :: forall (m :: * -> *) a. Monad m => m (m a) -> m a
  keepAlive# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE (BoxedRep l)) d (b :: TYPE r). a -> State# d -> (State# d -> b) -> b
  killThread# :: forall a. ThreadId# -> a -> State# RealWorld -> State# RealWorld
  labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
  lazy :: forall a. a -> a
  leAddr# :: Addr# -> Addr# -> Int#
  leChar# :: Char# -> Char# -> Int#
  leFloat# :: Float# -> Float# -> Int#
  leInt :: Int -> Int -> Bool
  leInt16# :: Int16# -> Int16# -> Int#
  leInt32# :: Int32# -> Int32# -> Int#
  leInt64# :: Int64# -> Int64# -> Int#
  leInt8# :: Int8# -> Int8# -> Int#
  leWord :: Word -> Word -> Bool
  leWord# :: Word# -> Word# -> Int#
  leWord16# :: Word16# -> Word16# -> Int#
  leWord32# :: Word32# -> Word32# -> Int#
  leWord64# :: Word64# -> Word64# -> Int#
  leWord8# :: Word8# -> Word8# -> Int#
  leftSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b
  liftA :: forall (f :: * -> *) a b. Applicative f => (a -> b) -> f a -> f b
  liftA3 :: forall (f :: * -> *) a b c d. Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  liftM :: forall (m :: * -> *) a1 r. Monad m => (a1 -> r) -> m a1 -> m r
  liftM2 :: forall (m :: * -> *) a1 a2 r. Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
  liftM3 :: forall (m :: * -> *) a1 a2 a3 r. Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
  liftM4 :: forall (m :: * -> *) a1 a2 a3 a4 r. Monad m => (a1 -> a2 -> a3 -> a4 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m r
  liftM5 :: forall (m :: * -> *) a1 a2 a3 a4 a5 r. Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
  listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
  log1pDouble# :: Double# -> Double#
  log1pFloat# :: Float# -> Float#
  logDouble# :: Double# -> Double#
  logFloat# :: Float# -> Float#
  ltAddr# :: Addr# -> Addr# -> Int#
  ltChar# :: Char# -> Char# -> Int#
  ltFloat# :: Float# -> Float# -> Int#
  ltInt :: Int -> Int -> Bool
  ltInt16# :: Int16# -> Int16# -> Int#
  ltInt32# :: Int32# -> Int32# -> Int#
  ltInt64# :: Int64# -> Int64# -> Int#
  ltInt8# :: Int8# -> Int8# -> Int#
  ltWord :: Word -> Word -> Bool
  ltWord# :: Word# -> Word# -> Int#
  ltWord16# :: Word16# -> Word16# -> Int#
  ltWord32# :: Word32# -> Word32# -> Int#
  ltWord64# :: Word64# -> Word64# -> Int#
  ltWord8# :: Word8# -> Word8# -> Int#
  makeStableName# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
  makeStablePtr# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
  map :: forall a b. (a -> b) -> [a] -> [b]
  mapFB :: forall elt lst a. (elt -> lst -> lst) -> (a -> elt) -> a -> lst -> lst
  mapM :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
  maskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maskUninterruptible# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maxInt :: Int
  minInt :: Int
  minusAddr# :: Addr# -> Addr# -> Int#
  minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  minusFloat# :: Float# -> Float# -> Float#
  minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  minusWord# :: Word# -> Word# -> Word#
  minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  mkApUpd0# :: forall a. BCO -> (# a #)
  mkWeak# :: forall {l :: Levity} {k :: Levity} (a :: TYPE (BoxedRep l)) (b :: TYPE (BoxedRep k)) c. a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  mkWeakNoFinalizer# :: forall {l :: Levity} {k :: Levity} (a :: TYPE (BoxedRep l)) (b :: TYPE (BoxedRep k)). a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  modInt :: Int -> Int -> Int
  modInt# :: Int# -> Int# -> Int#
  modInt16# :: Int16# -> Int16# -> Int16#
  modInt32# :: Int32# -> Int32# -> Int32#
  modInt8# :: Int8# -> Int8# -> Int8#
  mulIntMayOflo# :: Int# -> Int# -> Int#
  mutableByteArrayContents# :: forall d. MutableByteArray# d -> Addr#
  myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
  narrow16Int# :: Int# -> Int#
  narrow16Word# :: Word# -> Word#
  narrow32Int# :: Int# -> Int#
  narrow32Word# :: Word# -> Word#
  narrow8Int# :: Int# -> Int#
  narrow8Word# :: Word# -> Word#
  neAddr# :: Addr# -> Addr# -> Int#
  neChar :: Char -> Char -> Bool
  neChar# :: Char# -> Char# -> Int#
  neFloat# :: Float# -> Float# -> Int#
  neInt :: Int -> Int -> Bool
  neInt16# :: Int16# -> Int16# -> Int#
  neInt32# :: Int32# -> Int32# -> Int#
  neInt64# :: Int64# -> Int64# -> Int#
  neInt8# :: Int8# -> Int8# -> Int#
  neWord :: Word -> Word -> Bool
  neWord# :: Word# -> Word# -> Int#
  neWord16# :: Word16# -> Word16# -> Int#
  neWord32# :: Word32# -> Word32# -> Int#
  neWord64# :: Word64# -> Word64# -> Int#
  neWord8# :: Word8# -> Word8# -> Int#
  negateDouble# :: Double# -> Double#
  negateDoubleX2# :: DoubleX2# -> DoubleX2#
  negateDoubleX4# :: DoubleX4# -> DoubleX4#
  negateDoubleX8# :: DoubleX8# -> DoubleX8#
  negateFloat# :: Float# -> Float#
  negateFloatX16# :: FloatX16# -> FloatX16#
  negateFloatX4# :: FloatX4# -> FloatX4#
  negateFloatX8# :: FloatX8# -> FloatX8#
  negateInt# :: Int# -> Int#
  negateInt16# :: Int16# -> Int16#
  negateInt16X16# :: Int16X16# -> Int16X16#
  negateInt16X32# :: Int16X32# -> Int16X32#
  negateInt16X8# :: Int16X8# -> Int16X8#
  negateInt32# :: Int32# -> Int32#
  negateInt32X16# :: Int32X16# -> Int32X16#
  negateInt32X4# :: Int32X4# -> Int32X4#
  negateInt32X8# :: Int32X8# -> Int32X8#
  negateInt64# :: Int64# -> Int64#
  negateInt64X2# :: Int64X2# -> Int64X2#
  negateInt64X4# :: Int64X4# -> Int64X4#
  negateInt64X8# :: Int64X8# -> Int64X8#
  negateInt8# :: Int8# -> Int8#
  negateInt8X16# :: Int8X16# -> Int8X16#
  negateInt8X32# :: Int8X32# -> Int8X32#
  negateInt8X64# :: Int8X64# -> Int8X64#
  newAlignedPinnedByteArray# :: forall d. Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, MutableArray# d a #)
  newBCO# :: forall a d. ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)
  newByteArray# :: forall d. Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newIOPort# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). State# d -> (# State# d, IOPort# d a #)
  newMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). State# d -> (# State# d, MVar# d a #)
  newMutVar# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. a -> State# d -> (# State# d, MutVar# d a #)
  newPinnedByteArray# :: forall d. Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newPromptTag# :: forall a. State# RealWorld -> (# State# RealWorld, PromptTag# a #)
  newSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)
  newTVar# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. a -> State# d -> (# State# d, TVar# d a #)
  noDuplicate# :: forall d. State# d -> State# d
  noinline :: forall a. a -> a
  not :: Bool -> Bool
  not# :: Word# -> Word#
  not64# :: Word64# -> Word64#
  notI# :: Int# -> Int#
  notWord16# :: Word16# -> Word16#
  notWord32# :: Word32# -> Word32#
  notWord8# :: Word8# -> Word8#
  nullAddr# :: Addr#
  numSparks# :: forall d. State# d -> (# State# d, Int# #)
  oneShot :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b
  or# :: Word# -> Word# -> Word#
  or64# :: Word64# -> Word64# -> Word64#
  orI# :: Int# -> Int# -> Int#
  orWord16# :: Word16# -> Word16# -> Word16#
  orWord32# :: Word32# -> Word32# -> Word32#
  orWord8# :: Word8# -> Word8# -> Word8#
  ord :: Char -> Int
  ord# :: Char# -> Int#
  otherwise :: Bool
  packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#
  packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#
  packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#
  packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#
  packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#
  packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#
  packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#
  packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#
  packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#
  packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#
  packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#
  packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#
  packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#
  packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#
  packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#
  packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#
  packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#
  packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#
  packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#
  packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#
  packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#
  packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#
  packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#
  packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#
  packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#
  packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#
  packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#
  packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#
  packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#
  packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#
  par# :: forall a. a -> Int#
  pdep# :: Word# -> Word# -> Word#
  pdep16# :: Word# -> Word# -> Word#
  pdep32# :: Word# -> Word# -> Word#
  pdep64# :: Word64# -> Word64# -> Word64#
  pdep8# :: Word# -> Word# -> Word#
  pext# :: Word# -> Word# -> Word#
  pext16# :: Word# -> Word# -> Word#
  pext32# :: Word# -> Word# -> Word#
  pext64# :: Word64# -> Word64# -> Word64#
  pext8# :: Word# -> Word# -> Word#
  plusAddr# :: Addr# -> Int# -> Addr#
  plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  plusFloat# :: Float# -> Float# -> Float#
  plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  plusInt16# :: Int16# -> Int16# -> Int16#
  plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  plusInt32# :: Int32# -> Int32# -> Int32#
  plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  plusInt64# :: Int64# -> Int64# -> Int64#
  plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  plusInt8# :: Int8# -> Int8# -> Int8#
  plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  plusWord# :: Word# -> Word# -> Word#
  plusWord16# :: Word16# -> Word16# -> Word16#
  plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
  plusWord32# :: Word32# -> Word32# -> Word32#
  plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  plusWord64# :: Word64# -> Word64# -> Word64#
  plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  plusWord8# :: Word8# -> Word8# -> Word8#
  plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  popCnt# :: Word# -> Word#
  popCnt16# :: Word# -> Word#
  popCnt32# :: Word# -> Word#
  popCnt64# :: Word64# -> Word#
  popCnt8# :: Word# -> Word#
  powerFloat# :: Float# -> Float# -> Float#
  prefetchAddr0# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchAddr1# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchAddr2# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchAddr3# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchByteArray0# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray1# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray2# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray3# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchMutableByteArray0# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray1# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray2# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray3# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchValue0# :: forall a d. a -> State# d -> State# d
  prefetchValue1# :: forall a d. a -> State# d -> State# d
  prefetchValue2# :: forall a d. a -> State# d -> State# d
  prefetchValue3# :: forall a d. a -> State# d -> State# d
  prompt# :: forall a. PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  proxy# :: forall {k} (a :: k). Proxy# a
  putMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> a -> State# d -> State# d
  quotInt :: Int -> Int -> Int
  quotInt# :: Int# -> Int# -> Int#
  quotInt16# :: Int16# -> Int16# -> Int16#
  quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  quotInt32# :: Int32# -> Int32# -> Int32#
  quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  quotInt64# :: Int64# -> Int64# -> Int64#
  quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  quotInt8# :: Int8# -> Int8# -> Int8#
  quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  quotRemInt :: Int -> Int -> (Int, Int)
  quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
  quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
  quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
  quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
  quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
  quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
  quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
  quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
  quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
  quotWord# :: Word# -> Word# -> Word#
  quotWord16# :: Word16# -> Word16# -> Word16#
  quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  quotWord32# :: Word32# -> Word32# -> Word32#
  quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  quotWord64# :: Word64# -> Word64# -> Word64#
  quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  quotWord8# :: Word8# -> Word8# -> Word8#
  quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  raise# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE (BoxedRep l)) (b :: TYPE r). a -> b
  raiseDivZero# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
  raiseIO# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE (BoxedRep l)) (b :: TYPE r). a -> State# RealWorld -> (# State# RealWorld, b #)
  raiseOverflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
  raiseUnderflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
  readAddrArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readAddrOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Addr# #)
  readArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readCharArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readCharOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readDoubleArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleArrayAsDoubleX2# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleArrayAsDoubleX4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleArrayAsDoubleX8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleOffAddrAsDoubleX2# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleOffAddrAsDoubleX4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleOffAddrAsDoubleX8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX2Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX2OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readFloatArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readFloatArrayAsFloatX16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatArrayAsFloatX4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatArrayAsFloatX8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Float# #)
  readFloatOffAddrAsFloatX16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatOffAddrAsFloatX4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatOffAddrAsFloatX8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readIOPort# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). IOPort# d a -> State# d -> (# State# d, a #)
  readInt16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16ArrayAsInt16X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16ArrayAsInt16X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16ArrayAsInt16X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16OffAddrAsInt16X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16OffAddrAsInt16X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16OffAddrAsInt16X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32ArrayAsInt32X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32ArrayAsInt32X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32ArrayAsInt32X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32OffAddrAsInt32X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32OffAddrAsInt32X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32OffAddrAsInt32X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64ArrayAsInt64X2# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64ArrayAsInt64X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64ArrayAsInt64X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64OffAddrAsInt64X2# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64OffAddrAsInt64X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64OffAddrAsInt64X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X2Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X2OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8ArrayAsInt8X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8ArrayAsInt8X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8ArrayAsInt8X64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8OffAddrAsInt8X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8OffAddrAsInt8X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8OffAddrAsInt8X64# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readIntArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readIntOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int# #)
  readMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)
  readMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> State# d -> (# State# d, a #)
  readSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readStablePtrArray# :: forall d a. MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readStablePtrOffAddr# :: forall d a. Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readTVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)
  readTVarIO# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)
  readWideCharArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWideCharOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readWord16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16ArrayAsWord16X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16ArrayAsWord16X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16ArrayAsWord16X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16OffAddrAsWord16X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16OffAddrAsWord16X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16OffAddrAsWord16X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32ArrayAsWord32X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32ArrayAsWord32X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32ArrayAsWord32X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32OffAddrAsWord32X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32OffAddrAsWord32X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32OffAddrAsWord32X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64ArrayAsWord64X2# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64ArrayAsWord64X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64ArrayAsWord64X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64OffAddrAsWord64X2# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64OffAddrAsWord64X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64OffAddrAsWord64X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X2Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X2OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8ArrayAsAddr# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readWord8ArrayAsChar# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsDouble# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readWord8ArrayAsFloat# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readWord8ArrayAsInt# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readWord8ArrayAsInt16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readWord8ArrayAsInt32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readWord8ArrayAsInt64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readWord8ArrayAsStablePtr# :: forall d a. MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readWord8ArrayAsWideChar# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsWord# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWord8ArrayAsWord16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord8ArrayAsWord32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord8ArrayAsWord64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord8ArrayAsWord8X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8ArrayAsWord8X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8ArrayAsWord8X64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8OffAddrAsWord8X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8OffAddrAsWord8X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8OffAddrAsWord8X64# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWordArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWordOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word# #)
  realWorld# :: State# RealWorld
  reallyUnsafePtrEquality :: forall a. a -> a -> Int#
  reallyUnsafePtrEquality# :: forall {l :: Levity} {k :: Levity} (a :: TYPE (BoxedRep l)) (b :: TYPE (BoxedRep k)). a -> b -> Int#
  remAddr# :: Addr# -> Int# -> Int#
  remInt :: Int -> Int -> Int
  remInt# :: Int# -> Int# -> Int#
  remInt16# :: Int16# -> Int16# -> Int16#
  remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  remInt32# :: Int32# -> Int32# -> Int32#
  remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  remInt64# :: Int64# -> Int64# -> Int64#
  remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  remInt8# :: Int8# -> Int8# -> Int8#
  remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  remWord# :: Word# -> Word# -> Word#
  remWord16# :: Word16# -> Word16# -> Word16#
  remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  remWord32# :: Word32# -> Word32# -> Word32#
  remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  remWord64# :: Word64# -> Word64# -> Word64#
  remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  remWord8# :: Word8# -> Word8# -> Word8#
  remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  resizeMutableByteArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  retry# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). State# RealWorld -> (# State# RealWorld, a #)
  returnIO :: forall a. a -> IO a
  rightSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} {s :: RuntimeRep} (a :: TYPE q) (b :: TYPE r) (c :: TYPE s). (a -> b -> c) -> b -> a -> c
  runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o
  sameArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Array# a -> Int#
  sameByteArray# :: ByteArray# -> ByteArray# -> Int#
  sameIOPort# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). IOPort# s a -> IOPort# s a -> Int#
  sameMVar# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). MVar# s a -> MVar# s a -> Int#
  sameMutVar# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). MutVar# s a -> MutVar# s a -> Int#
  sameMutableArray# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). MutableArray# s a -> MutableArray# s a -> Int#
  sameMutableByteArray# :: forall s. MutableByteArray# s -> MutableByteArray# s -> Int#
  samePromptTag# :: forall a. PromptTag# a -> PromptTag# a -> Int#
  sameSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> SmallArray# a -> Int#
  sameSmallMutableArray# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
  sameTVar# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). TVar# s a -> TVar# s a -> Int#
  seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
  seq# :: forall a d. a -> State# d -> (# State# d, a #)
  sequence :: forall (m :: * -> *) a. Monad m => [m a] -> m [a]
  setAddrRange# :: Addr# -> Int# -> Int# -> State# RealWorld -> State# RealWorld
  setByteArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d
  setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld
  shiftL# :: Word# -> Int# -> Word#
  shiftRL# :: Word# -> Int# -> Word#
  shift_mask :: Int# -> Int# -> Int#
  shrinkMutableByteArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  shrinkSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> State# d
  sinDouble# :: Double# -> Double#
  sinFloat# :: Float# -> Float#
  sinhDouble# :: Double# -> Double#
  sinhFloat# :: Float# -> Float#
  sizeofArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Int#
  sizeofByteArray# :: ByteArray# -> Int#
  sizeofMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int#
  sizeofMutableByteArray# :: forall d. MutableByteArray# d -> Int#
  sizeofSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> Int#
  sizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int#
  spark# :: forall a d. a -> State# d -> (# State# d, a #)
  sqrtDouble# :: Double# -> Double#
  sqrtFloat# :: Float# -> Float#
  stableNameToInt# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). StableName# a -> Int#
  subInt16# :: Int16# -> Int16# -> Int16#
  subInt32# :: Int32# -> Int32# -> Int32#
  subInt64# :: Int64# -> Int64# -> Int64#
  subInt8# :: Int8# -> Int8# -> Int8#
  subIntC# :: Int# -> Int# -> (# Int#, Int# #)
  subWord16# :: Word16# -> Word16# -> Word16#
  subWord32# :: Word32# -> Word32# -> Word32#
  subWord64# :: Word64# -> Word64# -> Word64#
  subWord8# :: Word8# -> Word8# -> Word8#
  subWordC# :: Word# -> Word# -> (# Word#, Int# #)
  tagToEnum# :: forall a. Int# -> a
  takeMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)
  tanDouble# :: Double# -> Double#
  tanFloat# :: Float# -> Float#
  tanhDouble# :: Double# -> Double#
  tanhFloat# :: Float# -> Float#
  thawArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  thawSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  thenIO :: forall a b. IO a -> IO b -> IO b
  threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
  threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
  timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  timesFloat# :: Float# -> Float# -> Float#
  timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  timesInt16# :: Int16# -> Int16# -> Int16#
  timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
  timesInt32# :: Int32# -> Int32# -> Int32#
  timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  timesInt64# :: Int64# -> Int64# -> Int64#
  timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  timesInt8# :: Int8# -> Int8# -> Int8#
  timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  timesWord# :: Word# -> Word# -> Word#
  timesWord16# :: Word16# -> Word16# -> Word16#
  timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
  timesWord32# :: Word32# -> Word32# -> Word32#
  timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  timesWord64# :: Word64# -> Word64# -> Word64#
  timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  timesWord8# :: Word8# -> Word8# -> Word8#
  timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  touch# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. a -> State# d -> State# d
  traceBinaryEvent# :: forall d. Addr# -> Int# -> State# d -> State# d
  traceEvent# :: forall d. Addr# -> State# d -> State# d
  traceMarker# :: forall d. Addr# -> State# d -> State# d
  tryPutMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> a -> State# d -> (# State# d, Int# #)
  tryReadMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)
  tryTakeMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)
  unIO :: forall a. IO a -> State# RealWorld -> (# State# RealWorld, a #)
  uncheckedIShiftL# :: Int# -> Int# -> Int#
  uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRA# :: Int# -> Int# -> Int#
  uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRL# :: Int# -> Int# -> Int#
  uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
  uncheckedShiftL# :: Word# -> Int# -> Word#
  uncheckedShiftL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
  uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRL# :: Word# -> Int# -> Word#
  uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
  undefined :: forall (r :: RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
  unmaskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  unpackAppendCString# :: Addr# -> [Char] -> [Char]
  unpackAppendCStringUtf8# :: Addr# -> [Char] -> [Char]
  unpackCString# :: Addr# -> [Char]
  unpackCStringUtf8# :: Addr# -> [Char]
  unpackClosure# :: forall a b. a -> (# Addr#, ByteArray#, Array# b #)
  unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)
  unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)
  unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)
  unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)
  unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFoldrCString# :: forall a. Addr# -> (Char -> a -> a) -> a -> a
  unpackFoldrCStringUtf8# :: forall a. Addr# -> (Char -> a -> a) -> a -> a
  unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)
  unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)
  unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)
  unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackNBytes# :: Addr# -> Int# -> [Char]
  unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)
  unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)
  unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)
  unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unsafeChr :: Int -> Char
  unsafeFreezeArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> State# d -> (# State# d, Array# a #)
  unsafeFreezeByteArray# :: forall d. MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)
  unsafeFreezeSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)
  unsafePtrEquality# :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b -> Int#
  unsafeThawArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Array# a -> State# d -> (# State# d, MutableArray# d a #)
  unsafeThawByteArray# :: forall d. ByteArray# -> State# d -> (# State# d, MutableByteArray# d #)
  unsafeThawSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)
  until :: forall a. (a -> Bool) -> (a -> a) -> a -> a
  vacuous :: forall (f :: * -> *) a. Functor f => f Void -> f a
  void# :: (# #)
  waitRead# :: forall d. Int# -> State# d -> State# d
  waitWrite# :: forall d. Int# -> State# d -> State# d
  when :: forall (f :: * -> *). Applicative f => Bool -> f () -> f ()
  whereFrom# :: forall a d. a -> State# d -> (# State# d, Addr# #)
  word16ToInt16# :: Word16# -> Int16#
  word16ToWord# :: Word16# -> Word#
  word2Double# :: Word# -> Double#
  word2Float# :: Word# -> Float#
  word2Int# :: Word# -> Int#
  word32ToInt32# :: Word32# -> Int32#
  word32ToWord# :: Word32# -> Word#
  word64ToInt64# :: Word64# -> Int64#
  word64ToWord# :: Word64# -> Word#
  word8ToInt8# :: Word8# -> Int8#
  word8ToWord# :: Word8# -> Word#
  wordToWord16# :: Word# -> Word16#
  wordToWord32# :: Word# -> Word32#
  wordToWord64# :: Word# -> Word64#
  wordToWord8# :: Word# -> Word8#
  writeAddrArray# :: forall d. MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeAddrOffAddr# :: forall d. Addr# -> Int# -> Addr# -> State# d -> State# d
  writeArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> a -> State# d -> State# d
  writeCharArray# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeCharOffAddr# :: forall d. Addr# -> Int# -> Char# -> State# d -> State# d
  writeDoubleArray# :: forall d. MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeDoubleArrayAsDoubleX2# :: forall d. MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleArrayAsDoubleX4# :: forall d. MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleArrayAsDoubleX8# :: forall d. MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleOffAddr# :: forall d. Addr# -> Int# -> Double# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX2# :: forall d. Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX4# :: forall d. Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX8# :: forall d. Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX2Array# :: forall d. MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX2OffAddr# :: forall d. Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX4Array# :: forall d. MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX4OffAddr# :: forall d. Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX8Array# :: forall d. MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX8OffAddr# :: forall d. Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeFloatArray# :: forall d. MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeFloatArrayAsFloatX16# :: forall d. MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatArrayAsFloatX4# :: forall d. MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatArrayAsFloatX8# :: forall d. MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatOffAddr# :: forall d. Addr# -> Int# -> Float# -> State# d -> State# d
  writeFloatOffAddrAsFloatX16# :: forall d. Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatOffAddrAsFloatX4# :: forall d. Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatOffAddrAsFloatX8# :: forall d. Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX16Array# :: forall d. MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX16OffAddr# :: forall d. Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX4Array# :: forall d. MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX4OffAddr# :: forall d. Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX8Array# :: forall d. MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX8OffAddr# :: forall d. Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeIOPort# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). IOPort# d a -> a -> State# d -> (# State# d, Int# #)
  writeInt16Array# :: forall d. MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeInt16ArrayAsInt16X16# :: forall d. MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16ArrayAsInt16X32# :: forall d. MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16ArrayAsInt16X8# :: forall d. MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16OffAddr# :: forall d. Addr# -> Int# -> Int16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X16# :: forall d. Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X32# :: forall d. Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16OffAddrAsInt16X8# :: forall d. Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X16Array# :: forall d. MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X16OffAddr# :: forall d. Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X32Array# :: forall d. MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X32OffAddr# :: forall d. Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X8Array# :: forall d. MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X8OffAddr# :: forall d. Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt32Array# :: forall d. MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeInt32ArrayAsInt32X16# :: forall d. MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32ArrayAsInt32X4# :: forall d. MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32ArrayAsInt32X8# :: forall d. MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32OffAddr# :: forall d. Addr# -> Int# -> Int32# -> State# d -> State# d
  writeInt32OffAddrAsInt32X16# :: forall d. Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32OffAddrAsInt32X4# :: forall d. Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32OffAddrAsInt32X8# :: forall d. Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X16Array# :: forall d. MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X16OffAddr# :: forall d. Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X4Array# :: forall d. MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X4OffAddr# :: forall d. Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X8Array# :: forall d. MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X8OffAddr# :: forall d. Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt64Array# :: forall d. MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeInt64ArrayAsInt64X2# :: forall d. MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64ArrayAsInt64X4# :: forall d. MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64ArrayAsInt64X8# :: forall d. MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64OffAddr# :: forall d. Addr# -> Int# -> Int64# -> State# d -> State# d
  writeInt64OffAddrAsInt64X2# :: forall d. Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64OffAddrAsInt64X4# :: forall d. Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64OffAddrAsInt64X8# :: forall d. Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X2Array# :: forall d. MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X2OffAddr# :: forall d. Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X4Array# :: forall d. MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X4OffAddr# :: forall d. Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X8Array# :: forall d. MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X8OffAddr# :: forall d. Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt8Array# :: forall d. MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d
  writeInt8ArrayAsInt8X16# :: forall d. MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8ArrayAsInt8X32# :: forall d. MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8ArrayAsInt8X64# :: forall d. MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8OffAddr# :: forall d. Addr# -> Int# -> Int8# -> State# d -> State# d
  writeInt8OffAddrAsInt8X16# :: forall d. Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8OffAddrAsInt8X32# :: forall d. Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8OffAddrAsInt8X64# :: forall d. Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X16Array# :: forall d. MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X16OffAddr# :: forall d. Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X32Array# :: forall d. MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X32OffAddr# :: forall d. Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X64Array# :: forall d. MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X64OffAddr# :: forall d. Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeIntOffAddr# :: forall d. Addr# -> Int# -> Int# -> State# d -> State# d
  writeMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> a -> State# d -> State# d
  writeSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> State# d -> State# d
  writeStablePtrArray# :: forall d a. MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeStablePtrOffAddr# :: forall a d. Addr# -> Int# -> StablePtr# a -> State# d -> State# d
  writeTVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). TVar# d a -> a -> State# d -> State# d
  writeWideCharArray# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWideCharOffAddr# :: forall d. Addr# -> Int# -> Char# -> State# d -> State# d
  writeWord16Array# :: forall d. MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord16ArrayAsWord16X16# :: forall d. MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16ArrayAsWord16X32# :: forall d. MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16ArrayAsWord16X8# :: forall d. MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16OffAddr# :: forall d. Addr# -> Int# -> Word16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X16# :: forall d. Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X32# :: forall d. Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16OffAddrAsWord16X8# :: forall d. Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X16Array# :: forall d. MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X16OffAddr# :: forall d. Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X32Array# :: forall d. MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X32OffAddr# :: forall d. Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X8Array# :: forall d. MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X8OffAddr# :: forall d. Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord32Array# :: forall d. MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord32ArrayAsWord32X16# :: forall d. MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32ArrayAsWord32X4# :: forall d. MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32ArrayAsWord32X8# :: forall d. MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32OffAddr# :: forall d. Addr# -> Int# -> Word32# -> State# d -> State# d
  writeWord32OffAddrAsWord32X16# :: forall d. Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32OffAddrAsWord32X4# :: forall d. Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32OffAddrAsWord32X8# :: forall d. Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X16Array# :: forall d. MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X16OffAddr# :: forall d. Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X4Array# :: forall d. MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X4OffAddr# :: forall d. Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X8Array# :: forall d. MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X8OffAddr# :: forall d. Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord64Array# :: forall d. MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord64ArrayAsWord64X2# :: forall d. MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64ArrayAsWord64X4# :: forall d. MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64ArrayAsWord64X8# :: forall d. MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64OffAddr# :: forall d. Addr# -> Int# -> Word64# -> State# d -> State# d
  writeWord64OffAddrAsWord64X2# :: forall d. Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64OffAddrAsWord64X4# :: forall d. Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64OffAddrAsWord64X8# :: forall d. Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X2Array# :: forall d. MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X2OffAddr# :: forall d. Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X4Array# :: forall d. MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X4OffAddr# :: forall d. Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X8Array# :: forall d. MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X8OffAddr# :: forall d. Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord8Array# :: forall d. MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d
  writeWord8ArrayAsAddr# :: forall d. MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeWord8ArrayAsChar# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsDouble# :: forall d. MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeWord8ArrayAsFloat# :: forall d. MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeWord8ArrayAsInt# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeWord8ArrayAsInt16# :: forall d. MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeWord8ArrayAsInt32# :: forall d. MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeWord8ArrayAsInt64# :: forall d. MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeWord8ArrayAsStablePtr# :: forall d a. MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeWord8ArrayAsWideChar# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsWord# :: forall d. MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWord8ArrayAsWord16# :: forall d. MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord8ArrayAsWord32# :: forall d. MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord8ArrayAsWord64# :: forall d. MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord8ArrayAsWord8X16# :: forall d. MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8ArrayAsWord8X32# :: forall d. MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8ArrayAsWord8X64# :: forall d. MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8OffAddr# :: forall d. Addr# -> Int# -> Word8# -> State# d -> State# d
  writeWord8OffAddrAsWord8X16# :: forall d. Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8OffAddrAsWord8X32# :: forall d. Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8OffAddrAsWord8X64# :: forall d. Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X16Array# :: forall d. MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X16OffAddr# :: forall d. Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X32Array# :: forall d. MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X32OffAddr# :: forall d. Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X64Array# :: forall d. MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X64OffAddr# :: forall d. Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWordArray# :: forall d. MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWordOffAddr# :: forall d. Addr# -> Int# -> Word# -> State# d -> State# d
  xor# :: Word# -> Word# -> Word#
  xor64# :: Word64# -> Word64# -> Word64#
  xorI# :: Int# -> Int# -> Int#
  xorWord16# :: Word16# -> Word16# -> Word16#
  xorWord32# :: Word32# -> Word32# -> Word32#
  xorWord8# :: Word8# -> Word8# -> Word8#
  yield# :: State# RealWorld -> State# RealWorld
  (||) :: Bool -> Bool -> Bool
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
    {-# MINIMAL #-}
  type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
  class (a ~~ b) => (~~) a b
    {-# MINIMAL #-}

module GHC.Bits where
  -- Safety: Trustworthy
  type Bits :: * -> Constraint
  class GHC.Classes.Eq a => Bits a where
    (.&.) :: a -> a -> a
    (.|.) :: a -> a -> a
    xor :: a -> a -> a
    complement :: a -> a
    shift :: a -> GHC.Types.Int -> a
    rotate :: a -> GHC.Types.Int -> a
    zeroBits :: a
    bit :: GHC.Types.Int -> a
    setBit :: a -> GHC.Types.Int -> a
    clearBit :: a -> GHC.Types.Int -> a
    complementBit :: a -> GHC.Types.Int -> a
    testBit :: a -> GHC.Types.Int -> GHC.Types.Bool
    bitSizeMaybe :: a -> GHC.Maybe.Maybe GHC.Types.Int
    bitSize :: a -> GHC.Types.Int
    isSigned :: a -> GHC.Types.Bool
    shiftL :: a -> GHC.Types.Int -> a
    unsafeShiftL :: a -> GHC.Types.Int -> a
    shiftR :: a -> GHC.Types.Int -> a
    unsafeShiftR :: a -> GHC.Types.Int -> a
    rotateL :: a -> GHC.Types.Int -> a
    rotateR :: a -> GHC.Types.Int -> a
    popCount :: a -> GHC.Types.Int
    {-# MINIMAL (.&.), (.|.), xor, complement, (shift | (shiftL, shiftR)), (rotate | (rotateL, rotateR)), bitSize, bitSizeMaybe, isSigned, testBit, bit, popCount #-}
  type FiniteBits :: * -> Constraint
  class Bits b => FiniteBits b where
    finiteBitSize :: b -> GHC.Types.Int
    countLeadingZeros :: b -> GHC.Types.Int
    countTrailingZeros :: b -> GHC.Types.Int
    {-# MINIMAL finiteBitSize #-}
  bitDefault :: forall a. (Bits a, GHC.Num.Num a) => GHC.Types.Int -> a
  popCountDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int
  testBitDefault :: forall a. (Bits a, GHC.Num.Num a) => a -> GHC.Types.Int -> GHC.Types.Bool
  toIntegralSized :: forall a b. (GHC.Real.Integral a, GHC.Real.Integral b, Bits a, Bits b) => a -> GHC.Maybe.Maybe b

module GHC.ByteOrder where
  -- Safety: Safe-Inferred
  type ByteOrder :: *
  data ByteOrder = BigEndian | LittleEndian
  targetByteOrder :: ByteOrder

module GHC.Char where
  -- Safety: Trustworthy
  chr :: GHC.Types.Int -> GHC.Types.Char
  eqChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Bool
  neChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Bool

module GHC.Clock where
  -- Safety: Trustworthy
  getMonotonicTime :: GHC.Types.IO GHC.Types.Double
  getMonotonicTimeNSec :: GHC.Types.IO GHC.Word.Word64

module GHC.Conc where
  -- Safety: Unsafe
  type BlockReason :: *
  data BlockReason = BlockedOnMVar | BlockedOnBlackHole | BlockedOnException | BlockedOnSTM | BlockedOnForeignCall | BlockedOnOther
  type HandlerFun :: *
  type HandlerFun = GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.IO ()
  type PrimMVar :: *
  data PrimMVar
  type STM :: * -> *
  newtype STM a = STM (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
  type Signal :: *
  type Signal = Foreign.C.Types.CInt
  type TVar :: * -> *
  data TVar a = TVar (GHC.Prim.TVar# GHC.Prim.RealWorld a)
  type ThreadId :: *
  data ThreadId = ThreadId GHC.Prim.ThreadId#
  type ThreadStatus :: *
  data ThreadStatus = ThreadRunning | ThreadFinished | ThreadBlocked BlockReason | ThreadDied
  atomically :: forall a. STM a -> GHC.Types.IO a
  catchSTM :: forall e a. GHC.Exception.Type.Exception e => STM a -> (e -> STM a) -> STM a
  childHandler :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  closeFdWith :: (System.Posix.Types.Fd -> GHC.Types.IO ()) -> System.Posix.Types.Fd -> GHC.Types.IO ()
  disableAllocationLimit :: GHC.Types.IO ()
  enableAllocationLimit :: GHC.Types.IO ()
  ensureIOManagerIsRunning :: GHC.Types.IO ()
  forkIO :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkIOWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOn :: GHC.Types.Int -> GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOnWithUnmask :: GHC.Types.Int -> ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  getAllocationCounter :: GHC.Types.IO GHC.Int.Int64
  getNumCapabilities :: GHC.Types.IO GHC.Types.Int
  getNumProcessors :: GHC.Types.IO GHC.Types.Int
  getUncaughtExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  ioManagerCapabilitiesChanged :: GHC.Types.IO ()
  killThread :: ThreadId -> GHC.Types.IO ()
  labelThread :: ThreadId -> GHC.Base.String -> GHC.Types.IO ()
  listThreads :: GHC.Types.IO [ThreadId]
  mkWeakThreadId :: ThreadId -> GHC.Types.IO (GHC.Weak.Weak ThreadId)
  myThreadId :: GHC.Types.IO ThreadId
  newStablePtrPrimMVar :: forall a. GHC.MVar.MVar a -> GHC.Types.IO (GHC.Stable.StablePtr PrimMVar)
  newTVar :: forall a. a -> STM (TVar a)
  newTVarIO :: forall a. a -> GHC.Types.IO (TVar a)
  numCapabilities :: GHC.Types.Int
  numSparks :: GHC.Types.IO GHC.Types.Int
  orElse :: forall a. STM a -> STM a -> STM a
  par :: forall a b. a -> b -> b
  pseq :: forall a b. a -> b -> b
  readTVar :: forall a. TVar a -> STM a
  readTVarIO :: forall a. TVar a -> GHC.Types.IO a
  registerDelay :: GHC.Types.Int -> GHC.Types.IO (TVar GHC.Types.Bool)
  reportError :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  reportHeapOverflow :: GHC.Types.IO ()
  reportStackOverflow :: GHC.Types.IO ()
  retry :: forall a. STM a
  runHandlers :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> Signal -> GHC.Types.IO ()
  runSparks :: GHC.Types.IO ()
  setAllocationCounter :: GHC.Int.Int64 -> GHC.Types.IO ()
  setHandler :: Signal -> GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic) -> GHC.Types.IO (GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic))
  setNumCapabilities :: GHC.Types.Int -> GHC.Types.IO ()
  setUncaughtExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()
  threadCapability :: ThreadId -> GHC.Types.IO (GHC.Types.Int, GHC.Types.Bool)
  threadDelay :: GHC.Types.Int -> GHC.Types.IO ()
  threadStatus :: ThreadId -> GHC.Types.IO ThreadStatus
  threadWaitRead :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitReadSTM :: System.Posix.Types.Fd -> GHC.Types.IO (STM (), GHC.Types.IO ())
  threadWaitWrite :: System.Posix.Types.Fd -> GHC.Types.IO ()
  threadWaitWriteSTM :: System.Posix.Types.Fd -> GHC.Types.IO (STM (), GHC.Types.IO ())
  throwSTM :: forall e a. GHC.Exception.Type.Exception e => e -> STM a
  throwTo :: forall e. GHC.Exception.Type.Exception e => ThreadId -> e -> GHC.Types.IO ()
  unsafeIOToSTM :: forall a. GHC.Types.IO a -> STM a
  withMVar :: forall a b. GHC.MVar.MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  writeTVar :: forall a. TVar a -> a -> STM ()
  yield :: GHC.Types.IO ()

module GHC.Conc.IO where

-- ignored


module GHC.Conc.Signal where
  -- Safety: Trustworthy
  type HandlerFun :: *
  type HandlerFun = GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.IO ()
  type Signal :: *
  type Signal = Foreign.C.Types.CInt
  runHandlers :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> Signal -> GHC.Types.IO ()
  runHandlersPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> Signal -> GHC.Types.IO ()
  setHandler :: Signal -> GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic) -> GHC.Types.IO (GHC.Maybe.Maybe (HandlerFun, Data.Dynamic.Dynamic))

module GHC.Conc.Sync where
  -- Safety: Unsafe
  type BlockReason :: *
  data BlockReason = BlockedOnMVar | BlockedOnBlackHole | BlockedOnException | BlockedOnSTM | BlockedOnForeignCall | BlockedOnOther
  type PrimMVar :: *
  data PrimMVar
  type STM :: * -> *
  newtype STM a = STM (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
  type TVar :: * -> *
  data TVar a = TVar (GHC.Prim.TVar# GHC.Prim.RealWorld a)
  type ThreadId :: *
  data ThreadId = ThreadId GHC.Prim.ThreadId#
  type ThreadStatus :: *
  data ThreadStatus = ThreadRunning | ThreadFinished | ThreadBlocked BlockReason | ThreadDied
  atomically :: forall a. STM a -> GHC.Types.IO a
  catchSTM :: forall e a. GHC.Exception.Type.Exception e => STM a -> (e -> STM a) -> STM a
  childHandler :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  disableAllocationLimit :: GHC.Types.IO ()
  enableAllocationLimit :: GHC.Types.IO ()
  forkIO :: GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkIOWithUnmask :: ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  forkOn :: GHC.Types.Int -> GHC.Types.IO () -> GHC.Types.IO ThreadId
  forkOnWithUnmask :: GHC.Types.Int -> ((forall a. GHC.Types.IO a -> GHC.Types.IO a) -> GHC.Types.IO ()) -> GHC.Types.IO ThreadId
  fromThreadId :: ThreadId -> GHC.Word.Word64
  getAllocationCounter :: GHC.Types.IO GHC.Int.Int64
  getNumCapabilities :: GHC.Types.IO GHC.Types.Int
  getNumProcessors :: GHC.Types.IO GHC.Types.Int
  getUncaughtExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  killThread :: ThreadId -> GHC.Types.IO ()
  labelThread :: ThreadId -> GHC.Base.String -> GHC.Types.IO ()
  labelThreadByteArray# :: ThreadId -> GHC.Prim.ByteArray# -> GHC.Types.IO ()
  listThreads :: GHC.Types.IO [ThreadId]
  mkWeakThreadId :: ThreadId -> GHC.Types.IO (GHC.Weak.Weak ThreadId)
  modifyMVar_ :: forall a. GHC.MVar.MVar a -> (a -> GHC.Types.IO a) -> GHC.Types.IO ()
  myThreadId :: GHC.Types.IO ThreadId
  newStablePtrPrimMVar :: forall a. GHC.MVar.MVar a -> GHC.Types.IO (GHC.Stable.StablePtr PrimMVar)
  newTVar :: forall a. a -> STM (TVar a)
  newTVarIO :: forall a. a -> GHC.Types.IO (TVar a)
  numCapabilities :: GHC.Types.Int
  numSparks :: GHC.Types.IO GHC.Types.Int
  orElse :: forall a. STM a -> STM a -> STM a
  par :: forall a b. a -> b -> b
  pseq :: forall a b. a -> b -> b
  readTVar :: forall a. TVar a -> STM a
  readTVarIO :: forall a. TVar a -> GHC.Types.IO a
  reportError :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  reportHeapOverflow :: GHC.Types.IO ()
  reportStackOverflow :: GHC.Types.IO ()
  retry :: forall a. STM a
  runSparks :: GHC.Types.IO ()
  setAllocationCounter :: GHC.Int.Int64 -> GHC.Types.IO ()
  setNumCapabilities :: GHC.Types.Int -> GHC.Types.IO ()
  setUncaughtExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()
  sharedCAF :: forall a. a -> (GHC.Ptr.Ptr a -> GHC.Types.IO (GHC.Ptr.Ptr a)) -> GHC.Types.IO a
  showThreadId :: ThreadId -> GHC.Base.String
  threadCapability :: ThreadId -> GHC.Types.IO (GHC.Types.Int, GHC.Types.Bool)
  threadLabel :: ThreadId -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  threadStatus :: ThreadId -> GHC.Types.IO ThreadStatus
  throwSTM :: forall e a. GHC.Exception.Type.Exception e => e -> STM a
  throwTo :: forall e. GHC.Exception.Type.Exception e => ThreadId -> e -> GHC.Types.IO ()
  unsafeIOToSTM :: forall a. GHC.Types.IO a -> STM a
  withMVar :: forall a b. GHC.MVar.MVar a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  writeTVar :: forall a. TVar a -> a -> STM ()
  yield :: GHC.Types.IO ()

module GHC.ConsoleHandler where
  -- Safety: Trustworthy

module GHC.Constants where
  -- Safety: Trustworthy

module GHC.Desugar where
  -- Safety: Trustworthy
  (>>>) :: forall (arr :: * -> * -> *) a b c. Control.Arrow.Arrow arr => arr a b -> arr b c -> arr a c
  type AnnotationWrapper :: *
  data AnnotationWrapper = forall a. Data.Data.Data a => AnnotationWrapper a
  toAnnotationWrapper :: forall a. Data.Data.Data a => a -> AnnotationWrapper

module GHC.Encoding.UTF8 where
  -- Safety: None
  utf8CompareByteArray# :: GHC.Prim.ByteArray# -> GHC.Prim.ByteArray# -> GHC.Types.Ordering
  utf8CountCharsByteArray# :: GHC.Prim.ByteArray# -> GHC.Types.Int
  utf8DecodeByteArray# :: GHC.Prim.ByteArray# -> [GHC.Types.Char]
  utf8DecodeCharAddr# :: GHC.Prim.Addr# -> GHC.Prim.Int# -> (# GHC.Prim.Char#, GHC.Prim.Int# #)
  utf8DecodeCharByteArray# :: GHC.Prim.ByteArray# -> GHC.Prim.Int# -> (# GHC.Prim.Char#, GHC.Prim.Int# #)
  utf8DecodeCharPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> (GHC.Types.Char, GHC.Types.Int)
  utf8DecodeForeignPtr :: GHC.ForeignPtr.ForeignPtr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.Int -> [GHC.Types.Char]
  utf8EncodeByteArray# :: GHC.Base.String -> GHC.Prim.ByteArray#
  utf8EncodePtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Base.String -> GHC.Types.IO ()
  utf8EncodedLength :: GHC.Base.String -> GHC.Types.Int

module GHC.Enum where
  -- Safety: Trustworthy
  type Bounded :: * -> Constraint
  class Bounded a where
    minBound :: a
    maxBound :: a
    {-# MINIMAL minBound, maxBound #-}
  type Enum :: * -> Constraint
  class Enum a where
    succ :: a -> a
    pred :: a -> a
    toEnum :: GHC.Types.Int -> a
    fromEnum :: a -> GHC.Types.Int
    enumFrom :: a -> [a]
    enumFromThen :: a -> a -> [a]
    enumFromTo :: a -> a -> [a]
    enumFromThenTo :: a -> a -> a -> [a]
    {-# MINIMAL toEnum, fromEnum #-}
  boundedEnumFrom :: forall a. (Enum a, Bounded a) => a -> [a]
  boundedEnumFromThen :: forall a. (Enum a, Bounded a) => a -> a -> [a]
  fromEnumError :: forall a b. GHC.Show.Show a => GHC.Base.String -> a -> b
  predError :: forall a. GHC.Base.String -> a
  succError :: forall a. GHC.Base.String -> a
  toEnumError :: forall a b. GHC.Show.Show a => GHC.Base.String -> GHC.Types.Int -> (a, a) -> b

module GHC.Environment where
  -- Safety: Trustworthy
  getFullArgs :: GHC.Types.IO [GHC.Base.String]

module GHC.Err where
  -- Safety: Trustworthy
  absentErr :: forall a. a
  error :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => [GHC.Types.Char] -> a
  errorWithoutStackTrace :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r). [GHC.Types.Char] -> a
  undefined :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => a

module GHC.Event where
  -- Safety: Trustworthy
  type Event :: *
  newtype Event = ...
  type EventManager :: *
  data EventManager = ...
  type FdKey :: *
  data FdKey
    = base-4.18.0.0:GHC.Event.Manager.FdKey {keyFd :: ! {-# UNPACK #-}(System.Posix.Types.N:Fd[0]
                                                                       ; Foreign.C.Types.N:CInt[0])System.Posix.Types.Fd,
                                             ...}
  type IOCallback :: *
  type IOCallback = FdKey -> Event -> GHC.Types.IO ()
  type Lifetime :: *
  data Lifetime = OneShot | MultiShot
  type TimeoutCallback :: *
  type TimeoutCallback = GHC.Types.IO ()
  type TimeoutKey :: *
  newtype TimeoutKey = ...
  type TimerManager :: *
  data TimerManager = ...
  closeFd :: EventManager -> (System.Posix.Types.Fd -> GHC.Types.IO ()) -> System.Posix.Types.Fd -> GHC.Types.IO ()
  evtRead :: Event
  evtWrite :: Event
  getSystemEventManager :: GHC.Types.IO (GHC.Maybe.Maybe EventManager)
  getSystemTimerManager :: GHC.Types.IO TimerManager
  new :: GHC.Types.IO EventManager
  registerFd :: EventManager -> IOCallback -> System.Posix.Types.Fd -> Event -> Lifetime -> GHC.Types.IO FdKey
  registerTimeout :: TimerManager -> GHC.Types.Int -> TimeoutCallback -> GHC.Types.IO TimeoutKey
  unregisterFd :: EventManager -> FdKey -> GHC.Types.IO ()
  unregisterFd_ :: EventManager -> FdKey -> GHC.Types.IO GHC.Types.Bool
  unregisterTimeout :: TimerManager -> TimeoutKey -> GHC.Types.IO ()
  updateTimeout :: TimerManager -> TimeoutKey -> GHC.Types.Int -> GHC.Types.IO ()

module GHC.Event.TimeOut where
  -- Safety: None
  type TimeoutCallback :: *
  type TimeoutCallback = GHC.Types.IO ()
  type TimeoutEdit :: *
  type TimeoutEdit = TimeoutQueue -> TimeoutQueue
  type TimeoutKey :: *
  newtype TimeoutKey = TK base-4.18.0.0:GHC.Event.Unique.Unique
  type TimeoutQueue :: *
  type TimeoutQueue = base-4.18.0.0:GHC.Event.PSQ.PSQ TimeoutCallback

module GHC.Exception where
  -- Safety: Trustworthy
  type ArithException :: *
  data ArithException = Overflow | Underflow | LossOfPrecision | DivideByZero | Denormal | RatioZeroDenominator
  type CallStack :: *
  data CallStack = ...
  pattern ErrorCall :: GHC.Base.String -> ErrorCall
  type ErrorCall :: *
  data ErrorCall = ErrorCallWithLocation GHC.Base.String GHC.Base.String
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e where
    toException :: e -> SomeException
    fromException :: SomeException -> GHC.Maybe.Maybe e
    displayException :: e -> GHC.Base.String
    {-# MINIMAL #-}
  type SomeException :: *
  data SomeException = forall e. Exception e => SomeException e
  type SrcLoc :: *
  data SrcLoc = SrcLoc {srcLocPackage :: [GHC.Types.Char], srcLocModule :: [GHC.Types.Char], srcLocFile :: [GHC.Types.Char], srcLocStartLine :: GHC.Types.Int, srcLocStartCol :: GHC.Types.Int, srcLocEndLine :: GHC.Types.Int, srcLocEndCol :: GHC.Types.Int}
  divZeroException :: SomeException
  errorCallException :: GHC.Base.String -> SomeException
  errorCallWithCallStackException :: GHC.Base.String -> CallStack -> SomeException
  fromCallSiteList :: [([GHC.Types.Char], SrcLoc)] -> CallStack
  getCallStack :: CallStack -> [([GHC.Types.Char], SrcLoc)]
  overflowException :: SomeException
  prettyCallStack :: CallStack -> GHC.Base.String
  prettyCallStackLines :: CallStack -> [GHC.Base.String]
  prettySrcLoc :: SrcLoc -> GHC.Base.String
  ratioZeroDenomException :: SomeException
  showCCSStack :: [GHC.Base.String] -> [GHC.Base.String]
  throw :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r) e. Exception e => e -> a
  underflowException :: SomeException

module GHC.Exception.Type where
  -- Safety: Trustworthy
  type ArithException :: *
  data ArithException = Overflow | Underflow | LossOfPrecision | DivideByZero | Denormal | RatioZeroDenominator
  type Exception :: * -> Constraint
  class (base-4.18.0.0:Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => Exception e where
    toException :: e -> SomeException
    fromException :: SomeException -> GHC.Maybe.Maybe e
    displayException :: e -> GHC.Base.String
    {-# MINIMAL #-}
  type SomeException :: *
  data SomeException = forall e. Exception e => SomeException e
  divZeroException :: SomeException
  overflowException :: SomeException
  ratioZeroDenomException :: SomeException
  underflowException :: SomeException

module GHC.ExecutionStack where
  -- Safety: None
  type Location :: *
  data Location = Location {objectName :: GHC.Base.String, functionName :: GHC.Base.String, srcLoc :: GHC.Maybe.Maybe SrcLoc}
  type SrcLoc :: *
  data SrcLoc = SrcLoc {sourceFile :: GHC.Base.String, sourceLine :: GHC.Types.Int, sourceColumn :: GHC.Types.Int}
  getStackTrace :: GHC.Types.IO (GHC.Maybe.Maybe [Location])
  showStackTrace :: GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)

module GHC.ExecutionStack.Internal where
  -- Safety: None
  type Location :: *
  data Location = Location {objectName :: GHC.Base.String, functionName :: GHC.Base.String, srcLoc :: GHC.Maybe.Maybe SrcLoc}
  type SrcLoc :: *
  data SrcLoc = SrcLoc {sourceFile :: GHC.Base.String, sourceLine :: GHC.Types.Int, sourceColumn :: GHC.Types.Int}
  type StackTrace :: *
  newtype StackTrace = ...
  collectStackTrace :: GHC.Types.IO (GHC.Maybe.Maybe StackTrace)
  invalidateDebugCache :: GHC.Types.IO ()
  showStackFrames :: [Location] -> GHC.Show.ShowS
  stackDepth :: StackTrace -> GHC.Types.Int
  stackFrames :: StackTrace -> GHC.Maybe.Maybe [Location]

module GHC.Exts where
  -- Safety: Unsafe
  (*#) :: Int# -> Int# -> Int#
  (*##) :: Double# -> Double# -> Double#
  (**##) :: Double# -> Double# -> Double#
  (+#) :: Int# -> Int# -> Int#
  (+##) :: Double# -> Double# -> Double#
  (-#) :: Int# -> Int# -> Int#
  (-##) :: Double# -> Double# -> Double#
  (/##) :: Double# -> Double# -> Double#
  (/=#) :: Int# -> Int# -> Int#
  (/=##) :: Double# -> Double# -> Int#
  (<#) :: Int# -> Int# -> Int#
  (<##) :: Double# -> Double# -> Int#
  (<=#) :: Int# -> Int# -> Int#
  (<=##) :: Double# -> Double# -> Int#
  (==#) :: Int# -> Int# -> Int#
  (==##) :: Double# -> Double# -> Int#
  (>#) :: Int# -> Int# -> Int#
  (>##) :: Double# -> Double# -> Int#
  (>=#) :: Int# -> Int# -> Int#
  (>=##) :: Double# -> Double# -> Int#
  type Addr# :: TYPE AddrRep
  data Addr#
  type Any :: forall k. k
  type family Any where
  type Array# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data Array# a
  type ArrayArray# :: UnliftedType
  newtype ArrayArray# = ArrayArray# (Array# ByteArray#)
  type BCO :: *
  data BCO
  type Bool :: *
  data Bool = False | True
  type ByteArray# :: UnliftedType
  data ByteArray#
  type role CONSTRAINT nominal
  type CONSTRAINT :: RuntimeRep -> *
  data CONSTRAINT a
  type Char :: *
  data Char = C# Char#
  type Char# :: TYPE WordRep
  data Char#
  type role Coercible representational representational
  type Coercible :: forall k. k -> k -> Constraint
  class Coercible a b => Coercible a b
    {-# MINIMAL #-}
  type Compact# :: UnliftedType
  data Compact#
  type Constraint :: *
  type Constraint = CONSTRAINT LiftedRep
  type DictBox :: Constraint -> *
  data DictBox a = a => MkDictBox
  type Double :: *
  data Double = D# Double#
  type Double# :: TYPE DoubleRep
  data Double#
  type DoubleBox :: TYPE DoubleRep -> *
  data DoubleBox a = MkDoubleBox a
  type DoubleX2# :: TYPE (VecRep Vec2 DoubleElemRep)
  data DoubleX2#
  type DoubleX4# :: TYPE (VecRep Vec4 DoubleElemRep)
  data DoubleX4#
  type DoubleX8# :: TYPE (VecRep Vec8 DoubleElemRep)
  data DoubleX8#
  type Down :: * -> *
  newtype Down a = Down {getDown :: a}
  type role FUN nominal representational representational
  type FUN :: forall (n :: Multiplicity) -> forall {q :: RuntimeRep} {r :: RuntimeRep}. TYPE q -> TYPE r -> *
  data FUN n a b
  type Float :: *
  data Float = F# Float#
  type Float# :: TYPE FloatRep
  data Float#
  type FloatBox :: TYPE FloatRep -> *
  data FloatBox a = MkFloatBox a
  type FloatX16# :: TYPE (VecRep Vec16 FloatElemRep)
  data FloatX16#
  type FloatX4# :: TYPE (VecRep Vec4 FloatElemRep)
  data FloatX4#
  type FloatX8# :: TYPE (VecRep Vec8 FloatElemRep)
  data FloatX8#
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = FunPtr Addr#
  type role IOPort# nominal representational
  type IOPort# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data IOPort# a b
  type Int :: *
  data Int = I# Int#
  type Int# :: TYPE IntRep
  data Int#
  type Int16# :: TYPE Int16Rep
  data Int16#
  type Int16X16# :: TYPE (VecRep Vec16 Int16ElemRep)
  data Int16X16#
  type Int16X32# :: TYPE (VecRep Vec32 Int16ElemRep)
  data Int16X32#
  type Int16X8# :: TYPE (VecRep Vec8 Int16ElemRep)
  data Int16X8#
  type Int32# :: TYPE Int32Rep
  data Int32#
  type Int32X16# :: TYPE (VecRep Vec16 Int32ElemRep)
  data Int32X16#
  type Int32X4# :: TYPE (VecRep Vec4 Int32ElemRep)
  data Int32X4#
  type Int32X8# :: TYPE (VecRep Vec8 Int32ElemRep)
  data Int32X8#
  type Int64# :: TYPE Int64Rep
  data Int64#
  type Int64X2# :: TYPE (VecRep Vec2 Int64ElemRep)
  data Int64X2#
  type Int64X4# :: TYPE (VecRep Vec4 Int64ElemRep)
  data Int64X4#
  type Int64X8# :: TYPE (VecRep Vec8 Int64ElemRep)
  data Int64X8#
  type Int8# :: TYPE Int8Rep
  data Int8#
  type Int8X16# :: TYPE (VecRep Vec16 Int8ElemRep)
  data Int8X16#
  type Int8X32# :: TYPE (VecRep Vec32 Int8ElemRep)
  data Int8X32#
  type Int8X64# :: TYPE (VecRep Vec64 Int8ElemRep)
  data Int8X64#
  type IntBox :: TYPE IntRep -> *
  data IntBox a = MkIntBox a
  type IsList :: * -> Constraint
  class IsList l where
    type Item :: * -> *
    type family Item l
    fromList :: [Item l] -> l
    fromListN :: Int -> [Item l] -> l
    toList :: l -> [Item l]
    {-# MINIMAL fromList, toList #-}
  type IsString :: * -> Constraint
  class IsString a where
    fromString :: GHC.Base.String -> a
    {-# MINIMAL fromString #-}
  KindRepApp :: GHC.Types.KindRep -> GHC.Types.KindRep -> GHC.Types.KindRep
  KindRepFun :: GHC.Types.KindRep -> GHC.Types.KindRep -> GHC.Types.KindRep
  KindRepTYPE :: RuntimeRep -> GHC.Types.KindRep
  KindRepTyConApp :: GHC.Types.TyCon -> [GHC.Types.KindRep] -> GHC.Types.KindRep
  KindRepTypeLitD :: GHC.Types.TypeLitSort -> [Char] -> GHC.Types.KindRep
  KindRepTypeLitS :: GHC.Types.TypeLitSort -> Addr# -> GHC.Types.KindRep
  KindRepVar :: GHC.Types.KindBndr -> GHC.Types.KindRep
  type Levity :: *
  data Levity = Lifted | Unlifted
  type LiftedRep :: RuntimeRep
  type LiftedRep = BoxedRep Lifted :: RuntimeRep
  type List :: * -> *
  data List a = ...
  type role MVar# nominal representational
  type MVar# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data MVar# a b
  type MultMul :: Multiplicity -> Multiplicity -> Multiplicity
  type family MultMul a b where
    forall (x :: Multiplicity). MultMul One x = x
    forall (x :: Multiplicity). MultMul x One = x
    forall (x :: Multiplicity). MultMul Many x = Many
    forall (x :: Multiplicity). MultMul x Many = Many
  type Multiplicity :: *
  data Multiplicity = One | Many
  type role MutVar# nominal representational
  type MutVar# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data MutVar# a b
  type role MutableArray# nominal representational
  type MutableArray# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data MutableArray# a b
  type role MutableArrayArray# nominal
  type MutableArrayArray# :: * -> UnliftedType
  newtype MutableArrayArray# s = MutableArrayArray# (MutableArray# s ByteArray#)
  type role MutableByteArray# nominal
  type MutableByteArray# :: * -> UnliftedType
  data MutableByteArray# a
  type Ordering :: *
  data Ordering = LT | EQ | GT
  type PromptTag# :: * -> UnliftedType
  data PromptTag# a
  type role Proxy# phantom
  type Proxy# :: forall k. k -> ZeroBitType
  data Proxy# a
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = Ptr Addr#
  type RealWorld :: *
  data RealWorld
  type RuntimeRep :: *
  data RuntimeRep = VecRep VecCount VecElem | TupleRep [RuntimeRep] | SumRep [RuntimeRep] | BoxedRep Levity | IntRep | Int8Rep | Int16Rep | Int32Rep | Int64Rep | WordRep | Word8Rep | Word16Rep | Word32Rep | Word64Rep | AddrRep | FloatRep | DoubleRep
  type SPEC :: *
  data SPEC = SPEC | SPEC2
  type SmallArray# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data SmallArray# a
  type role SmallMutableArray# nominal representational
  type SmallMutableArray# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data SmallMutableArray# a b
  type SpecConstrAnnotation :: *
  data SpecConstrAnnotation = NoSpecConstr | ForceSpecConstr
  type role StableName# phantom
  type StableName# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data StableName# a
  type StablePtr# :: forall {l :: Levity}. TYPE (BoxedRep l) -> TYPE AddrRep
  data StablePtr# a
  type StackSnapshot# :: UnliftedType
  data StackSnapshot#
  type role State# nominal
  type State# :: * -> ZeroBitType
  data State# a
  type Symbol :: *
  data Symbol
  type role TVar# nominal representational
  type TVar# :: forall {l :: Levity}. * -> TYPE (BoxedRep l) -> UnliftedType
  data TVar# a b
  type role TYPE nominal
  type TYPE :: RuntimeRep -> *
  data TYPE a
  type ThreadId# :: UnliftedType
  data ThreadId#
  TrNameD :: [Char] -> GHC.Types.TrName
  TrNameS :: Addr# -> GHC.Types.TrName
  TypeLitChar :: GHC.Types.TypeLitSort
  TypeLitNat :: GHC.Types.TypeLitSort
  TypeLitSymbol :: GHC.Types.TypeLitSort
  type UnliftedRep :: RuntimeRep
  type UnliftedRep = BoxedRep Unlifted :: RuntimeRep
  type UnliftedType :: *
  type UnliftedType = TYPE UnliftedRep
  type VecCount :: *
  data VecCount = Vec2 | Vec4 | Vec8 | Vec16 | Vec32 | Vec64
  type VecElem :: *
  data VecElem = Int8ElemRep | Int16ElemRep | Int32ElemRep | Int64ElemRep | Word8ElemRep | Word16ElemRep | Word32ElemRep | Word64ElemRep | FloatElemRep | DoubleElemRep
  type Void# :: ZeroBitType
  type Void# = (# #) :: ZeroBitType
  type Weak# :: forall {l :: Levity}. TYPE (BoxedRep l) -> UnliftedType
  data Weak# a
  type WithDict :: Constraint -> * -> Constraint
  class WithDict cls meth where
    withDict :: forall {rr :: RuntimeRep} (r :: TYPE rr). meth -> (cls => r) -> r
    {-# MINIMAL withDict #-}
  type Word :: *
  data Word = W# Word#
  type Word# :: TYPE WordRep
  data Word#
  type Word16# :: TYPE Word16Rep
  data Word16#
  type Word16X16# :: TYPE (VecRep Vec16 Word16ElemRep)
  data Word16X16#
  type Word16X32# :: TYPE (VecRep Vec32 Word16ElemRep)
  data Word16X32#
  type Word16X8# :: TYPE (VecRep Vec8 Word16ElemRep)
  data Word16X8#
  type Word32# :: TYPE Word32Rep
  data Word32#
  type Word32X16# :: TYPE (VecRep Vec16 Word32ElemRep)
  data Word32X16#
  type Word32X4# :: TYPE (VecRep Vec4 Word32ElemRep)
  data Word32X4#
  type Word32X8# :: TYPE (VecRep Vec8 Word32ElemRep)
  data Word32X8#
  type Word64# :: TYPE Word64Rep
  data Word64#
  type Word64X2# :: TYPE (VecRep Vec2 Word64ElemRep)
  data Word64X2#
  type Word64X4# :: TYPE (VecRep Vec4 Word64ElemRep)
  data Word64X4#
  type Word64X8# :: TYPE (VecRep Vec8 Word64ElemRep)
  data Word64X8#
  type Word8# :: TYPE Word8Rep
  data Word8#
  type Word8X16# :: TYPE (VecRep Vec16 Word8ElemRep)
  data Word8X16#
  type Word8X32# :: TYPE (VecRep Vec32 Word8ElemRep)
  data Word8X32#
  type Word8X64# :: TYPE (VecRep Vec64 Word8ElemRep)
  data Word8X64#
  type WordBox :: TYPE WordRep -> *
  data WordBox a = MkWordBox a
  type ZeroBitRep :: RuntimeRep
  type ZeroBitRep = TupleRep '[] :: RuntimeRep
  type ZeroBitType :: *
  type ZeroBitType = TYPE ZeroBitRep
  acosDouble# :: Double# -> Double#
  acosFloat# :: Float# -> Float#
  acoshDouble# :: Double# -> Double#
  acoshFloat# :: Float# -> Float#
  addCFinalizerToWeak# :: forall {k :: Levity} (b :: TYPE (BoxedRep k)). Addr# -> Addr# -> Int# -> Addr# -> Weak# b -> State# RealWorld -> (# State# RealWorld, Int# #)
  addIntC# :: Int# -> Int# -> (# Int#, Int# #)
  addWordC# :: Word# -> Word# -> (# Word#, Int# #)
  addr2Int# :: Addr# -> Int#
  addrToAny# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Addr# -> (# a #)
  and# :: Word# -> Word# -> Word#
  and64# :: Word64# -> Word64# -> Word64#
  andI# :: Int# -> Int# -> Int#
  andWord16# :: Word16# -> Word16# -> Word16#
  andWord32# :: Word32# -> Word32# -> Word32#
  andWord8# :: Word8# -> Word8# -> Word8#
  anyToAddr# :: forall a. a -> State# RealWorld -> (# State# RealWorld, Addr# #)
  asinDouble# :: Double# -> Double#
  asinFloat# :: Float# -> Float#
  asinhDouble# :: Double# -> Double#
  asinhFloat# :: Float# -> Float#
  atanDouble# :: Double# -> Double#
  atanFloat# :: Float# -> Float#
  atanhDouble# :: Double# -> Double#
  atanhFloat# :: Float# -> Float#
  atomicCasAddrAddr# :: forall d. Addr# -> Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicCasWord16Addr# :: forall d. Addr# -> Word16# -> Word16# -> State# d -> (# State# d, Word16# #)
  atomicCasWord32Addr# :: forall d. Addr# -> Word32# -> Word32# -> State# d -> (# State# d, Word32# #)
  atomicCasWord64Addr# :: forall d. Addr# -> Word64# -> Word64# -> State# d -> (# State# d, Word64# #)
  atomicCasWord8Addr# :: forall d. Addr# -> Word8# -> Word8# -> State# d -> (# State# d, Word8# #)
  atomicCasWordAddr# :: forall d. Addr# -> Word# -> Word# -> State# d -> (# State# d, Word# #)
  atomicExchangeAddrAddr# :: forall d. Addr# -> Addr# -> State# d -> (# State# d, Addr# #)
  atomicExchangeWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  atomicModifyMutVar# :: forall s a b c. MutVar# s a -> (a -> b) -> State# s -> (# State# s, c #)
  atomicModifyMutVar2# :: forall d a c. MutVar# d a -> (a -> c) -> State# d -> (# State# d, a, c #)
  atomicModifyMutVar_# :: forall d a. MutVar# d a -> (a -> a) -> State# d -> (# State# d, a, a #)
  atomicReadIntArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  atomicReadWordAddr# :: forall d. Addr# -> State# d -> (# State# d, Word# #)
  atomicSwapMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> a -> State# d -> (# State# d, a #)
  atomicWriteIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  atomicWriteWordAddr# :: forall d. Addr# -> Word# -> State# d -> State# d
  atomically# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
  bitReverse# :: Word# -> Word#
  bitReverse16# :: Word# -> Word#
  bitReverse32# :: Word# -> Word#
  bitReverse64# :: Word64# -> Word64#
  bitReverse8# :: Word# -> Word#
  breakpoint :: forall a. a -> a
  breakpointCond :: forall a. Bool -> a -> a
  broadcastDoubleX2# :: Double# -> DoubleX2#
  broadcastDoubleX4# :: Double# -> DoubleX4#
  broadcastDoubleX8# :: Double# -> DoubleX8#
  broadcastFloatX16# :: Float# -> FloatX16#
  broadcastFloatX4# :: Float# -> FloatX4#
  broadcastFloatX8# :: Float# -> FloatX8#
  broadcastInt16X16# :: Int16# -> Int16X16#
  broadcastInt16X32# :: Int16# -> Int16X32#
  broadcastInt16X8# :: Int16# -> Int16X8#
  broadcastInt32X16# :: Int32# -> Int32X16#
  broadcastInt32X4# :: Int32# -> Int32X4#
  broadcastInt32X8# :: Int32# -> Int32X8#
  broadcastInt64X2# :: Int64# -> Int64X2#
  broadcastInt64X4# :: Int64# -> Int64X4#
  broadcastInt64X8# :: Int64# -> Int64X8#
  broadcastInt8X16# :: Int8# -> Int8X16#
  broadcastInt8X32# :: Int8# -> Int8X32#
  broadcastInt8X64# :: Int8# -> Int8X64#
  broadcastWord16X16# :: Word16# -> Word16X16#
  broadcastWord16X32# :: Word16# -> Word16X32#
  broadcastWord16X8# :: Word16# -> Word16X8#
  broadcastWord32X16# :: Word32# -> Word32X16#
  broadcastWord32X4# :: Word32# -> Word32X4#
  broadcastWord32X8# :: Word32# -> Word32X8#
  broadcastWord64X2# :: Word64# -> Word64X2#
  broadcastWord64X4# :: Word64# -> Word64X4#
  broadcastWord64X8# :: Word64# -> Word64X8#
  broadcastWord8X16# :: Word8# -> Word8X16#
  broadcastWord8X32# :: Word8# -> Word8X32#
  broadcastWord8X64# :: Word8# -> Word8X64#
  build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
  byteArrayContents# :: ByteArray# -> Addr#
  byteSwap# :: Word# -> Word#
  byteSwap16# :: Word# -> Word#
  byteSwap32# :: Word# -> Word#
  byteSwap64# :: Word64# -> Word64#
  casArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  casInt16Array# :: forall d. MutableByteArray# d -> Int# -> Int16# -> Int16# -> State# d -> (# State# d, Int16# #)
  casInt32Array# :: forall d. MutableByteArray# d -> Int# -> Int32# -> Int32# -> State# d -> (# State# d, Int32# #)
  casInt64Array# :: forall d. MutableByteArray# d -> Int# -> Int64# -> Int64# -> State# d -> (# State# d, Int64# #)
  casInt8Array# :: forall d. MutableByteArray# d -> Int# -> Int8# -> Int8# -> State# d -> (# State# d, Int8# #)
  casIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  casMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> a -> a -> State# d -> (# State# d, Int#, a #)
  casSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> a -> State# d -> (# State# d, Int#, a #)
  catch# :: forall {q :: RuntimeRep} {k :: Levity} (a :: TYPE q) (b :: TYPE (BoxedRep k)). (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchRetry# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). (State# RealWorld -> (# State# RealWorld, a #)) -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  catchSTM# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) b. (State# RealWorld -> (# State# RealWorld, a #)) -> (b -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  chr# :: Int# -> Char#
  clearCCS# :: forall d a. (State# d -> (# State# d, a #)) -> State# d -> (# State# d, a #)
  cloneArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Int# -> Int# -> Array# a
  cloneMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  cloneSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> Int# -> Int# -> SmallArray# a
  cloneSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  closureSize# :: forall a. a -> Int#
  clz# :: Word# -> Word#
  clz16# :: Word# -> Word#
  clz32# :: Word# -> Word#
  clz64# :: Word64# -> Word#
  clz8# :: Word# -> Word#
  coerce :: forall {k :: RuntimeRep} (a :: TYPE k) (b :: TYPE k). Coercible a b => a -> b
  compactAdd# :: forall a. Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAddWithSharing# :: forall a. Compact# -> a -> State# RealWorld -> (# State# RealWorld, a #)
  compactAllocateBlock# :: Word# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr# #)
  compactContains# :: forall a. Compact# -> a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactContainsAny# :: forall a. a -> State# RealWorld -> (# State# RealWorld, Int# #)
  compactFixupPointers# :: Addr# -> Addr# -> State# RealWorld -> (# State# RealWorld, Compact#, Addr# #)
  compactGetFirstBlock# :: Compact# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactGetNextBlock# :: Compact# -> Addr# -> State# RealWorld -> (# State# RealWorld, Addr#, Word# #)
  compactNew# :: Word# -> State# RealWorld -> (# State# RealWorld, Compact# #)
  compactResize# :: Compact# -> Word# -> State# RealWorld -> State# RealWorld
  compactSize# :: Compact# -> State# RealWorld -> (# State# RealWorld, Word# #)
  compareByteArrays# :: ByteArray# -> Int# -> ByteArray# -> Int# -> Int# -> Int#
  considerAccessible :: Bool
  control0# :: forall {r :: RuntimeRep} a (b :: TYPE r). PromptTag# a -> (((State# RealWorld -> (# State# RealWorld, b #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, b #)
  copyAddrToAddr# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld
  copyAddrToAddrNonOverlapping# :: Addr# -> Addr# -> Int# -> State# RealWorld -> State# RealWorld
  copyAddrToByteArray# :: forall d. Addr# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Array# a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyArrayArray# :: forall s. ArrayArray# -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
  copyByteArray# :: forall d. ByteArray# -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyByteArrayToAddr# :: forall d. ByteArray# -> Int# -> Addr# -> Int# -> State# d -> State# d
  copyMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> MutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copyMutableArrayArray# :: forall s. MutableArrayArray# s -> Int# -> MutableArrayArray# s -> Int# -> Int# -> State# s -> State# s
  copyMutableByteArray# :: forall d. MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArrayNonOverlapping# :: forall d. MutableByteArray# d -> Int# -> MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  copyMutableByteArrayToAddr# :: forall d. MutableByteArray# d -> Int# -> Addr# -> Int# -> State# d -> State# d
  copySmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. SmallArray# a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  copySmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> SmallMutableArray# d a -> Int# -> Int# -> State# d -> State# d
  cosDouble# :: Double# -> Double#
  cosFloat# :: Float# -> Float#
  coshDouble# :: Double# -> Double#
  coshFloat# :: Float# -> Float#
  cstringLength# :: Addr# -> Int#
  ctz# :: Word# -> Word#
  ctz16# :: Word# -> Word#
  ctz32# :: Word# -> Word#
  ctz64# :: Word64# -> Word#
  ctz8# :: Word# -> Word#
  currentCallStack :: GHC.Types.IO [GHC.Base.String]
  dataToTag# :: forall a. a -> Int#
  deRefStablePtr# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
  deRefWeak# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
  decodeDouble_2Int# :: Double# -> (# Int#, Word#, Word#, Int# #)
  decodeDouble_Int64# :: Double# -> (# Int64#, Int# #)
  decodeFloat_Int# :: Float# -> (# Int#, Int# #)
  delay# :: forall d. Int# -> State# d -> State# d
  divideDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  divideDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  divideDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  divideFloat# :: Float# -> Float# -> Float#
  divideFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  divideFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  divideFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  double2Float# :: Double# -> Float#
  double2Int# :: Double# -> Int#
  eqAddr# :: Addr# -> Addr# -> Int#
  eqChar# :: Char# -> Char# -> Int#
  eqFloat# :: Float# -> Float# -> Int#
  eqInt16# :: Int16# -> Int16# -> Int#
  eqInt32# :: Int32# -> Int32# -> Int#
  eqInt64# :: Int64# -> Int64# -> Int#
  eqInt8# :: Int8# -> Int8# -> Int#
  eqStableName# :: forall {k :: Levity} {l :: Levity} (a :: TYPE (BoxedRep k)) (b :: TYPE (BoxedRep l)). StableName# a -> StableName# b -> Int#
  eqStablePtr# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). StablePtr# a -> StablePtr# a -> Int#
  eqWord# :: Word# -> Word# -> Int#
  eqWord16# :: Word16# -> Word16# -> Int#
  eqWord32# :: Word32# -> Word32# -> Int#
  eqWord64# :: Word64# -> Word64# -> Int#
  eqWord8# :: Word8# -> Word8# -> Int#
  expDouble# :: Double# -> Double#
  expFloat# :: Float# -> Float#
  expm1Double# :: Double# -> Double#
  expm1Float# :: Float# -> Float#
  fabsDouble# :: Double# -> Double#
  fabsFloat# :: Float# -> Float#
  fetchAddIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAddWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchAndIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchAndWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchNandIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchNandWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchOrIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchOrWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchSubIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchSubWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  fetchXorIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> (# State# d, Int# #)
  fetchXorWordAddr# :: forall d. Addr# -> Word# -> State# d -> (# State# d, Word# #)
  finalizeWeak# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) b. Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, State# RealWorld -> (# State# RealWorld, b #) #)
  float2Double# :: Float# -> Double#
  float2Int# :: Float# -> Int#
  fmaddDouble# :: Double# -> Double# -> Double# -> Double#
  fmaddFloat# :: Float# -> Float# -> Float# -> Float#
  fmsubDouble# :: Double# -> Double# -> Double# -> Double#
  fmsubFloat# :: Float# -> Float# -> Float# -> Float#
  fnmaddDouble# :: Double# -> Double# -> Double# -> Double#
  fnmaddFloat# :: Float# -> Float# -> Float# -> Float#
  fnmsubDouble# :: Double# -> Double# -> Double# -> Double#
  fnmsubFloat# :: Float# -> Float# -> Float# -> Float#
  fork# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  forkOn# :: forall {q :: RuntimeRep} (a :: TYPE q). Int# -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
  freezeArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, Array# a #)
  freezeSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> Int# -> State# d -> (# State# d, SmallArray# a #)
  geAddr# :: Addr# -> Addr# -> Int#
  geChar# :: Char# -> Char# -> Int#
  geFloat# :: Float# -> Float# -> Int#
  geInt16# :: Int16# -> Int16# -> Int#
  geInt32# :: Int32# -> Int32# -> Int#
  geInt64# :: Int64# -> Int64# -> Int#
  geInt8# :: Int8# -> Int8# -> Int#
  geWord# :: Word# -> Word# -> Int#
  geWord16# :: Word16# -> Word16# -> Int#
  geWord32# :: Word32# -> Word32# -> Int#
  geWord64# :: Word64# -> Word64# -> Int#
  geWord8# :: Word8# -> Word8# -> Int#
  getApStackVal# :: forall a b. a -> Int# -> (# Int#, b #)
  getCCSOf# :: forall a d. a -> State# d -> (# State# d, Addr# #)
  getCurrentCCS# :: forall a d. a -> State# d -> (# State# d, Addr# #)
  getMaskingState# :: State# RealWorld -> (# State# RealWorld, Int# #)
  getSizeofMutableByteArray# :: forall d. MutableByteArray# d -> State# d -> (# State# d, Int# #)
  getSizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, Int# #)
  getSpark# :: forall d a. State# d -> (# State# d, Int#, a #)
  getThreadAllocationCounter# :: State# RealWorld -> (# State# RealWorld, Int64# #)
  groupWith :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [[a]]
  gtAddr# :: Addr# -> Addr# -> Int#
  gtChar# :: Char# -> Char# -> Int#
  gtFloat# :: Float# -> Float# -> Int#
  gtInt16# :: Int16# -> Int16# -> Int#
  gtInt32# :: Int32# -> Int32# -> Int#
  gtInt64# :: Int64# -> Int64# -> Int#
  gtInt8# :: Int8# -> Int8# -> Int#
  gtWord# :: Word# -> Word# -> Int#
  gtWord16# :: Word16# -> Word16# -> Int#
  gtWord32# :: Word32# -> Word32# -> Int#
  gtWord64# :: Word64# -> Word64# -> Int#
  gtWord8# :: Word8# -> Word8# -> Int#
  iShiftL# :: Int# -> Int# -> Int#
  iShiftRA# :: Int# -> Int# -> Int#
  iShiftRL# :: Int# -> Int# -> Int#
  indexAddrArray# :: ByteArray# -> Int# -> Addr#
  indexAddrOffAddr# :: Addr# -> Int# -> Addr#
  indexArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Int# -> (# a #)
  indexArrayArrayArray# :: ArrayArray# -> Int# -> ArrayArray#
  indexByteArrayArray# :: ArrayArray# -> Int# -> ByteArray#
  indexCharArray# :: ByteArray# -> Int# -> Char#
  indexCharOffAddr# :: Addr# -> Int# -> Char#
  indexDoubleArray# :: ByteArray# -> Int# -> Double#
  indexDoubleArrayAsDoubleX2# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleArrayAsDoubleX4# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleArrayAsDoubleX8# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleOffAddr# :: Addr# -> Int# -> Double#
  indexDoubleOffAddrAsDoubleX2# :: Addr# -> Int# -> DoubleX2#
  indexDoubleOffAddrAsDoubleX4# :: Addr# -> Int# -> DoubleX4#
  indexDoubleOffAddrAsDoubleX8# :: Addr# -> Int# -> DoubleX8#
  indexDoubleX2Array# :: ByteArray# -> Int# -> DoubleX2#
  indexDoubleX2OffAddr# :: Addr# -> Int# -> DoubleX2#
  indexDoubleX4Array# :: ByteArray# -> Int# -> DoubleX4#
  indexDoubleX4OffAddr# :: Addr# -> Int# -> DoubleX4#
  indexDoubleX8Array# :: ByteArray# -> Int# -> DoubleX8#
  indexDoubleX8OffAddr# :: Addr# -> Int# -> DoubleX8#
  indexFloatArray# :: ByteArray# -> Int# -> Float#
  indexFloatArrayAsFloatX16# :: ByteArray# -> Int# -> FloatX16#
  indexFloatArrayAsFloatX4# :: ByteArray# -> Int# -> FloatX4#
  indexFloatArrayAsFloatX8# :: ByteArray# -> Int# -> FloatX8#
  indexFloatOffAddr# :: Addr# -> Int# -> Float#
  indexFloatOffAddrAsFloatX16# :: Addr# -> Int# -> FloatX16#
  indexFloatOffAddrAsFloatX4# :: Addr# -> Int# -> FloatX4#
  indexFloatOffAddrAsFloatX8# :: Addr# -> Int# -> FloatX8#
  indexFloatX16Array# :: ByteArray# -> Int# -> FloatX16#
  indexFloatX16OffAddr# :: Addr# -> Int# -> FloatX16#
  indexFloatX4Array# :: ByteArray# -> Int# -> FloatX4#
  indexFloatX4OffAddr# :: Addr# -> Int# -> FloatX4#
  indexFloatX8Array# :: ByteArray# -> Int# -> FloatX8#
  indexFloatX8OffAddr# :: Addr# -> Int# -> FloatX8#
  indexInt16Array# :: ByteArray# -> Int# -> Int16#
  indexInt16ArrayAsInt16X16# :: ByteArray# -> Int# -> Int16X16#
  indexInt16ArrayAsInt16X32# :: ByteArray# -> Int# -> Int16X32#
  indexInt16ArrayAsInt16X8# :: ByteArray# -> Int# -> Int16X8#
  indexInt16OffAddr# :: Addr# -> Int# -> Int16#
  indexInt16OffAddrAsInt16X16# :: Addr# -> Int# -> Int16X16#
  indexInt16OffAddrAsInt16X32# :: Addr# -> Int# -> Int16X32#
  indexInt16OffAddrAsInt16X8# :: Addr# -> Int# -> Int16X8#
  indexInt16X16Array# :: ByteArray# -> Int# -> Int16X16#
  indexInt16X16OffAddr# :: Addr# -> Int# -> Int16X16#
  indexInt16X32Array# :: ByteArray# -> Int# -> Int16X32#
  indexInt16X32OffAddr# :: Addr# -> Int# -> Int16X32#
  indexInt16X8Array# :: ByteArray# -> Int# -> Int16X8#
  indexInt16X8OffAddr# :: Addr# -> Int# -> Int16X8#
  indexInt32Array# :: ByteArray# -> Int# -> Int32#
  indexInt32ArrayAsInt32X16# :: ByteArray# -> Int# -> Int32X16#
  indexInt32ArrayAsInt32X4# :: ByteArray# -> Int# -> Int32X4#
  indexInt32ArrayAsInt32X8# :: ByteArray# -> Int# -> Int32X8#
  indexInt32OffAddr# :: Addr# -> Int# -> Int32#
  indexInt32OffAddrAsInt32X16# :: Addr# -> Int# -> Int32X16#
  indexInt32OffAddrAsInt32X4# :: Addr# -> Int# -> Int32X4#
  indexInt32OffAddrAsInt32X8# :: Addr# -> Int# -> Int32X8#
  indexInt32X16Array# :: ByteArray# -> Int# -> Int32X16#
  indexInt32X16OffAddr# :: Addr# -> Int# -> Int32X16#
  indexInt32X4Array# :: ByteArray# -> Int# -> Int32X4#
  indexInt32X4OffAddr# :: Addr# -> Int# -> Int32X4#
  indexInt32X8Array# :: ByteArray# -> Int# -> Int32X8#
  indexInt32X8OffAddr# :: Addr# -> Int# -> Int32X8#
  indexInt64Array# :: ByteArray# -> Int# -> Int64#
  indexInt64ArrayAsInt64X2# :: ByteArray# -> Int# -> Int64X2#
  indexInt64ArrayAsInt64X4# :: ByteArray# -> Int# -> Int64X4#
  indexInt64ArrayAsInt64X8# :: ByteArray# -> Int# -> Int64X8#
  indexInt64OffAddr# :: Addr# -> Int# -> Int64#
  indexInt64OffAddrAsInt64X2# :: Addr# -> Int# -> Int64X2#
  indexInt64OffAddrAsInt64X4# :: Addr# -> Int# -> Int64X4#
  indexInt64OffAddrAsInt64X8# :: Addr# -> Int# -> Int64X8#
  indexInt64X2Array# :: ByteArray# -> Int# -> Int64X2#
  indexInt64X2OffAddr# :: Addr# -> Int# -> Int64X2#
  indexInt64X4Array# :: ByteArray# -> Int# -> Int64X4#
  indexInt64X4OffAddr# :: Addr# -> Int# -> Int64X4#
  indexInt64X8Array# :: ByteArray# -> Int# -> Int64X8#
  indexInt64X8OffAddr# :: Addr# -> Int# -> Int64X8#
  indexInt8Array# :: ByteArray# -> Int# -> Int8#
  indexInt8ArrayAsInt8X16# :: ByteArray# -> Int# -> Int8X16#
  indexInt8ArrayAsInt8X32# :: ByteArray# -> Int# -> Int8X32#
  indexInt8ArrayAsInt8X64# :: ByteArray# -> Int# -> Int8X64#
  indexInt8OffAddr# :: Addr# -> Int# -> Int8#
  indexInt8OffAddrAsInt8X16# :: Addr# -> Int# -> Int8X16#
  indexInt8OffAddrAsInt8X32# :: Addr# -> Int# -> Int8X32#
  indexInt8OffAddrAsInt8X64# :: Addr# -> Int# -> Int8X64#
  indexInt8X16Array# :: ByteArray# -> Int# -> Int8X16#
  indexInt8X16OffAddr# :: Addr# -> Int# -> Int8X16#
  indexInt8X32Array# :: ByteArray# -> Int# -> Int8X32#
  indexInt8X32OffAddr# :: Addr# -> Int# -> Int8X32#
  indexInt8X64Array# :: ByteArray# -> Int# -> Int8X64#
  indexInt8X64OffAddr# :: Addr# -> Int# -> Int8X64#
  indexIntArray# :: ByteArray# -> Int# -> Int#
  indexIntOffAddr# :: Addr# -> Int# -> Int#
  indexSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> Int# -> (# a #)
  indexStablePtrArray# :: forall a. ByteArray# -> Int# -> StablePtr# a
  indexStablePtrOffAddr# :: forall a. Addr# -> Int# -> StablePtr# a
  indexWideCharArray# :: ByteArray# -> Int# -> Char#
  indexWideCharOffAddr# :: Addr# -> Int# -> Char#
  indexWord16Array# :: ByteArray# -> Int# -> Word16#
  indexWord16ArrayAsWord16X16# :: ByteArray# -> Int# -> Word16X16#
  indexWord16ArrayAsWord16X32# :: ByteArray# -> Int# -> Word16X32#
  indexWord16ArrayAsWord16X8# :: ByteArray# -> Int# -> Word16X8#
  indexWord16OffAddr# :: Addr# -> Int# -> Word16#
  indexWord16OffAddrAsWord16X16# :: Addr# -> Int# -> Word16X16#
  indexWord16OffAddrAsWord16X32# :: Addr# -> Int# -> Word16X32#
  indexWord16OffAddrAsWord16X8# :: Addr# -> Int# -> Word16X8#
  indexWord16X16Array# :: ByteArray# -> Int# -> Word16X16#
  indexWord16X16OffAddr# :: Addr# -> Int# -> Word16X16#
  indexWord16X32Array# :: ByteArray# -> Int# -> Word16X32#
  indexWord16X32OffAddr# :: Addr# -> Int# -> Word16X32#
  indexWord16X8Array# :: ByteArray# -> Int# -> Word16X8#
  indexWord16X8OffAddr# :: Addr# -> Int# -> Word16X8#
  indexWord32Array# :: ByteArray# -> Int# -> Word32#
  indexWord32ArrayAsWord32X16# :: ByteArray# -> Int# -> Word32X16#
  indexWord32ArrayAsWord32X4# :: ByteArray# -> Int# -> Word32X4#
  indexWord32ArrayAsWord32X8# :: ByteArray# -> Int# -> Word32X8#
  indexWord32OffAddr# :: Addr# -> Int# -> Word32#
  indexWord32OffAddrAsWord32X16# :: Addr# -> Int# -> Word32X16#
  indexWord32OffAddrAsWord32X4# :: Addr# -> Int# -> Word32X4#
  indexWord32OffAddrAsWord32X8# :: Addr# -> Int# -> Word32X8#
  indexWord32X16Array# :: ByteArray# -> Int# -> Word32X16#
  indexWord32X16OffAddr# :: Addr# -> Int# -> Word32X16#
  indexWord32X4Array# :: ByteArray# -> Int# -> Word32X4#
  indexWord32X4OffAddr# :: Addr# -> Int# -> Word32X4#
  indexWord32X8Array# :: ByteArray# -> Int# -> Word32X8#
  indexWord32X8OffAddr# :: Addr# -> Int# -> Word32X8#
  indexWord64Array# :: ByteArray# -> Int# -> Word64#
  indexWord64ArrayAsWord64X2# :: ByteArray# -> Int# -> Word64X2#
  indexWord64ArrayAsWord64X4# :: ByteArray# -> Int# -> Word64X4#
  indexWord64ArrayAsWord64X8# :: ByteArray# -> Int# -> Word64X8#
  indexWord64OffAddr# :: Addr# -> Int# -> Word64#
  indexWord64OffAddrAsWord64X2# :: Addr# -> Int# -> Word64X2#
  indexWord64OffAddrAsWord64X4# :: Addr# -> Int# -> Word64X4#
  indexWord64OffAddrAsWord64X8# :: Addr# -> Int# -> Word64X8#
  indexWord64X2Array# :: ByteArray# -> Int# -> Word64X2#
  indexWord64X2OffAddr# :: Addr# -> Int# -> Word64X2#
  indexWord64X4Array# :: ByteArray# -> Int# -> Word64X4#
  indexWord64X4OffAddr# :: Addr# -> Int# -> Word64X4#
  indexWord64X8Array# :: ByteArray# -> Int# -> Word64X8#
  indexWord64X8OffAddr# :: Addr# -> Int# -> Word64X8#
  indexWord8Array# :: ByteArray# -> Int# -> Word8#
  indexWord8ArrayAsAddr# :: ByteArray# -> Int# -> Addr#
  indexWord8ArrayAsChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsDouble# :: ByteArray# -> Int# -> Double#
  indexWord8ArrayAsFloat# :: ByteArray# -> Int# -> Float#
  indexWord8ArrayAsInt# :: ByteArray# -> Int# -> Int#
  indexWord8ArrayAsInt16# :: ByteArray# -> Int# -> Int16#
  indexWord8ArrayAsInt32# :: ByteArray# -> Int# -> Int32#
  indexWord8ArrayAsInt64# :: ByteArray# -> Int# -> Int64#
  indexWord8ArrayAsStablePtr# :: forall a. ByteArray# -> Int# -> StablePtr# a
  indexWord8ArrayAsWideChar# :: ByteArray# -> Int# -> Char#
  indexWord8ArrayAsWord# :: ByteArray# -> Int# -> Word#
  indexWord8ArrayAsWord16# :: ByteArray# -> Int# -> Word16#
  indexWord8ArrayAsWord32# :: ByteArray# -> Int# -> Word32#
  indexWord8ArrayAsWord64# :: ByteArray# -> Int# -> Word64#
  indexWord8ArrayAsWord8X16# :: ByteArray# -> Int# -> Word8X16#
  indexWord8ArrayAsWord8X32# :: ByteArray# -> Int# -> Word8X32#
  indexWord8ArrayAsWord8X64# :: ByteArray# -> Int# -> Word8X64#
  indexWord8OffAddr# :: Addr# -> Int# -> Word8#
  indexWord8OffAddrAsWord8X16# :: Addr# -> Int# -> Word8X16#
  indexWord8OffAddrAsWord8X32# :: Addr# -> Int# -> Word8X32#
  indexWord8OffAddrAsWord8X64# :: Addr# -> Int# -> Word8X64#
  indexWord8X16Array# :: ByteArray# -> Int# -> Word8X16#
  indexWord8X16OffAddr# :: Addr# -> Int# -> Word8X16#
  indexWord8X32Array# :: ByteArray# -> Int# -> Word8X32#
  indexWord8X32OffAddr# :: Addr# -> Int# -> Word8X32#
  indexWord8X64Array# :: ByteArray# -> Int# -> Word8X64#
  indexWord8X64OffAddr# :: Addr# -> Int# -> Word8X64#
  indexWordArray# :: ByteArray# -> Int# -> Word#
  indexWordOffAddr# :: Addr# -> Int# -> Word#
  inline :: forall a. a -> a
  insertDoubleX2# :: DoubleX2# -> Double# -> Int# -> DoubleX2#
  insertDoubleX4# :: DoubleX4# -> Double# -> Int# -> DoubleX4#
  insertDoubleX8# :: DoubleX8# -> Double# -> Int# -> DoubleX8#
  insertFloatX16# :: FloatX16# -> Float# -> Int# -> FloatX16#
  insertFloatX4# :: FloatX4# -> Float# -> Int# -> FloatX4#
  insertFloatX8# :: FloatX8# -> Float# -> Int# -> FloatX8#
  insertInt16X16# :: Int16X16# -> Int16# -> Int# -> Int16X16#
  insertInt16X32# :: Int16X32# -> Int16# -> Int# -> Int16X32#
  insertInt16X8# :: Int16X8# -> Int16# -> Int# -> Int16X8#
  insertInt32X16# :: Int32X16# -> Int32# -> Int# -> Int32X16#
  insertInt32X4# :: Int32X4# -> Int32# -> Int# -> Int32X4#
  insertInt32X8# :: Int32X8# -> Int32# -> Int# -> Int32X8#
  insertInt64X2# :: Int64X2# -> Int64# -> Int# -> Int64X2#
  insertInt64X4# :: Int64X4# -> Int64# -> Int# -> Int64X4#
  insertInt64X8# :: Int64X8# -> Int64# -> Int# -> Int64X8#
  insertInt8X16# :: Int8X16# -> Int8# -> Int# -> Int8X16#
  insertInt8X32# :: Int8X32# -> Int8# -> Int# -> Int8X32#
  insertInt8X64# :: Int8X64# -> Int8# -> Int# -> Int8X64#
  insertWord16X16# :: Word16X16# -> Word16# -> Int# -> Word16X16#
  insertWord16X32# :: Word16X32# -> Word16# -> Int# -> Word16X32#
  insertWord16X8# :: Word16X8# -> Word16# -> Int# -> Word16X8#
  insertWord32X16# :: Word32X16# -> Word32# -> Int# -> Word32X16#
  insertWord32X4# :: Word32X4# -> Word32# -> Int# -> Word32X4#
  insertWord32X8# :: Word32X8# -> Word32# -> Int# -> Word32X8#
  insertWord64X2# :: Word64X2# -> Word64# -> Int# -> Word64X2#
  insertWord64X4# :: Word64X4# -> Word64# -> Int# -> Word64X4#
  insertWord64X8# :: Word64X8# -> Word64# -> Int# -> Word64X8#
  insertWord8X16# :: Word8X16# -> Word8# -> Int# -> Word8X16#
  insertWord8X32# :: Word8X32# -> Word8# -> Int# -> Word8X32#
  insertWord8X64# :: Word8X64# -> Word8# -> Int# -> Word8X64#
  int16ToInt# :: Int16# -> Int#
  int16ToWord16# :: Int16# -> Word16#
  int2Addr# :: Int# -> Addr#
  int2Double# :: Int# -> Double#
  int2Float# :: Int# -> Float#
  int2Word# :: Int# -> Word#
  int32ToInt# :: Int32# -> Int#
  int32ToWord32# :: Int32# -> Word32#
  int64ToInt# :: Int64# -> Int#
  int64ToWord64# :: Int64# -> Word64#
  int8ToInt# :: Int8# -> Int#
  int8ToWord8# :: Int8# -> Word8#
  intToInt16# :: Int# -> Int16#
  intToInt32# :: Int# -> Int32#
  intToInt64# :: Int# -> Int64#
  intToInt8# :: Int# -> Int8#
  isByteArrayPinned# :: ByteArray# -> Int#
  isCurrentThreadBound# :: State# RealWorld -> (# State# RealWorld, Int# #)
  isEmptyMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int# #)
  isMutableByteArrayPinned# :: forall d. MutableByteArray# d -> Int#
  isTrue# :: Int# -> Bool
  keepAlive# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE (BoxedRep l)) d (b :: TYPE r). a -> State# d -> (State# d -> b) -> b
  killThread# :: forall a. ThreadId# -> a -> State# RealWorld -> State# RealWorld
  labelThread# :: ThreadId# -> ByteArray# -> State# RealWorld -> State# RealWorld
  lazy :: forall a. a -> a
  leAddr# :: Addr# -> Addr# -> Int#
  leChar# :: Char# -> Char# -> Int#
  leFloat# :: Float# -> Float# -> Int#
  leInt16# :: Int16# -> Int16# -> Int#
  leInt32# :: Int32# -> Int32# -> Int#
  leInt64# :: Int64# -> Int64# -> Int#
  leInt8# :: Int8# -> Int8# -> Int#
  leWord# :: Word# -> Word# -> Int#
  leWord16# :: Word16# -> Word16# -> Int#
  leWord32# :: Word32# -> Word32# -> Int#
  leWord64# :: Word64# -> Word64# -> Int#
  leWord8# :: Word8# -> Word8# -> Int#
  leftSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b
  listThreads# :: State# RealWorld -> (# State# RealWorld, Array# ThreadId# #)
  log1pDouble# :: Double# -> Double#
  log1pFloat# :: Float# -> Float#
  logDouble# :: Double# -> Double#
  logFloat# :: Float# -> Float#
  ltAddr# :: Addr# -> Addr# -> Int#
  ltChar# :: Char# -> Char# -> Int#
  ltFloat# :: Float# -> Float# -> Int#
  ltInt16# :: Int16# -> Int16# -> Int#
  ltInt32# :: Int32# -> Int32# -> Int#
  ltInt64# :: Int64# -> Int64# -> Int#
  ltInt8# :: Int8# -> Int8# -> Int#
  ltWord# :: Word# -> Word# -> Int#
  ltWord16# :: Word16# -> Word16# -> Int#
  ltWord32# :: Word32# -> Word32# -> Int#
  ltWord64# :: Word64# -> Word64# -> Int#
  ltWord8# :: Word8# -> Word8# -> Int#
  makeStableName# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
  makeStablePtr# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
  maskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maskUninterruptible# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  maxTupleSize :: Int
  minusAddr# :: Addr# -> Addr# -> Int#
  minusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  minusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  minusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  minusFloat# :: Float# -> Float# -> Float#
  minusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  minusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  minusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  minusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  minusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  minusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  minusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  minusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  minusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  minusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  minusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  minusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  minusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  minusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  minusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  minusWord# :: Word# -> Word# -> Word#
  minusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  minusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  minusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  minusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  minusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  minusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  minusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  minusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  minusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  minusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  minusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  minusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  mkApUpd0# :: forall a. BCO -> (# a #)
  mkWeak# :: forall {l :: Levity} {k :: Levity} (a :: TYPE (BoxedRep l)) (b :: TYPE (BoxedRep k)) c. a -> b -> (State# RealWorld -> (# State# RealWorld, c #)) -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  mkWeakNoFinalizer# :: forall {l :: Levity} {k :: Levity} (a :: TYPE (BoxedRep l)) (b :: TYPE (BoxedRep k)). a -> b -> State# RealWorld -> (# State# RealWorld, Weak# b #)
  mulIntMayOflo# :: Int# -> Int# -> Int#
  mutableByteArrayContents# :: forall d. MutableByteArray# d -> Addr#
  myThreadId# :: State# RealWorld -> (# State# RealWorld, ThreadId# #)
  narrow16Int# :: Int# -> Int#
  narrow16Word# :: Word# -> Word#
  narrow32Int# :: Int# -> Int#
  narrow32Word# :: Word# -> Word#
  narrow8Int# :: Int# -> Int#
  narrow8Word# :: Word# -> Word#
  neAddr# :: Addr# -> Addr# -> Int#
  neChar# :: Char# -> Char# -> Int#
  neFloat# :: Float# -> Float# -> Int#
  neInt16# :: Int16# -> Int16# -> Int#
  neInt32# :: Int32# -> Int32# -> Int#
  neInt64# :: Int64# -> Int64# -> Int#
  neInt8# :: Int8# -> Int8# -> Int#
  neWord# :: Word# -> Word# -> Int#
  neWord16# :: Word16# -> Word16# -> Int#
  neWord32# :: Word32# -> Word32# -> Int#
  neWord64# :: Word64# -> Word64# -> Int#
  neWord8# :: Word8# -> Word8# -> Int#
  negateDouble# :: Double# -> Double#
  negateDoubleX2# :: DoubleX2# -> DoubleX2#
  negateDoubleX4# :: DoubleX4# -> DoubleX4#
  negateDoubleX8# :: DoubleX8# -> DoubleX8#
  negateFloat# :: Float# -> Float#
  negateFloatX16# :: FloatX16# -> FloatX16#
  negateFloatX4# :: FloatX4# -> FloatX4#
  negateFloatX8# :: FloatX8# -> FloatX8#
  negateInt# :: Int# -> Int#
  negateInt16# :: Int16# -> Int16#
  negateInt16X16# :: Int16X16# -> Int16X16#
  negateInt16X32# :: Int16X32# -> Int16X32#
  negateInt16X8# :: Int16X8# -> Int16X8#
  negateInt32# :: Int32# -> Int32#
  negateInt32X16# :: Int32X16# -> Int32X16#
  negateInt32X4# :: Int32X4# -> Int32X4#
  negateInt32X8# :: Int32X8# -> Int32X8#
  negateInt64# :: Int64# -> Int64#
  negateInt64X2# :: Int64X2# -> Int64X2#
  negateInt64X4# :: Int64X4# -> Int64X4#
  negateInt64X8# :: Int64X8# -> Int64X8#
  negateInt8# :: Int8# -> Int8#
  negateInt8X16# :: Int8X16# -> Int8X16#
  negateInt8X32# :: Int8X32# -> Int8X32#
  negateInt8X64# :: Int8X64# -> Int8X64#
  newAlignedPinnedByteArray# :: forall d. Int# -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, MutableArray# d a #)
  newArrayArray# :: forall s. Int# -> State# s -> (# State# s, MutableArrayArray# s #)
  newBCO# :: forall a d. ByteArray# -> ByteArray# -> Array# a -> Int# -> ByteArray# -> State# d -> (# State# d, BCO #)
  newByteArray# :: forall d. Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newIOPort# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). State# d -> (# State# d, IOPort# d a #)
  newMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). State# d -> (# State# d, MVar# d a #)
  newMutVar# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. a -> State# d -> (# State# d, MutVar# d a #)
  newPinnedByteArray# :: forall d. Int# -> State# d -> (# State# d, MutableByteArray# d #)
  newPromptTag# :: forall a. State# RealWorld -> (# State# RealWorld, PromptTag# a #)
  newSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Int# -> a -> State# d -> (# State# d, SmallMutableArray# d a #)
  newTVar# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. a -> State# d -> (# State# d, TVar# d a #)
  noDuplicate# :: forall d. State# d -> State# d
  noinline :: forall a. a -> a
  not# :: Word# -> Word#
  not64# :: Word64# -> Word64#
  notI# :: Int# -> Int#
  notWord16# :: Word16# -> Word16#
  notWord32# :: Word32# -> Word32#
  notWord8# :: Word8# -> Word8#
  nullAddr# :: Addr#
  numSparks# :: forall d. State# d -> (# State# d, Int# #)
  oneShot :: forall {q :: RuntimeRep} {r :: RuntimeRep} (a :: TYPE q) (b :: TYPE r). (a -> b) -> a -> b
  or# :: Word# -> Word# -> Word#
  or64# :: Word64# -> Word64# -> Word64#
  orI# :: Int# -> Int# -> Int#
  orWord16# :: Word16# -> Word16# -> Word16#
  orWord32# :: Word32# -> Word32# -> Word32#
  orWord8# :: Word8# -> Word8# -> Word8#
  ord# :: Char# -> Int#
  packDoubleX2# :: (# Double#, Double# #) -> DoubleX2#
  packDoubleX4# :: (# Double#, Double#, Double#, Double# #) -> DoubleX4#
  packDoubleX8# :: (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #) -> DoubleX8#
  packFloatX16# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX16#
  packFloatX4# :: (# Float#, Float#, Float#, Float# #) -> FloatX4#
  packFloatX8# :: (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #) -> FloatX8#
  packInt16X16# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X16#
  packInt16X32# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X32#
  packInt16X8# :: (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #) -> Int16X8#
  packInt32X16# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X16#
  packInt32X4# :: (# Int32#, Int32#, Int32#, Int32# #) -> Int32X4#
  packInt32X8# :: (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #) -> Int32X8#
  packInt64X2# :: (# Int64#, Int64# #) -> Int64X2#
  packInt64X4# :: (# Int64#, Int64#, Int64#, Int64# #) -> Int64X4#
  packInt64X8# :: (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #) -> Int64X8#
  packInt8X16# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X16#
  packInt8X32# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X32#
  packInt8X64# :: (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #) -> Int8X64#
  packWord16X16# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X16#
  packWord16X32# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X32#
  packWord16X8# :: (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #) -> Word16X8#
  packWord32X16# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X16#
  packWord32X4# :: (# Word32#, Word32#, Word32#, Word32# #) -> Word32X4#
  packWord32X8# :: (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #) -> Word32X8#
  packWord64X2# :: (# Word64#, Word64# #) -> Word64X2#
  packWord64X4# :: (# Word64#, Word64#, Word64#, Word64# #) -> Word64X4#
  packWord64X8# :: (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #) -> Word64X8#
  packWord8X16# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X16#
  packWord8X32# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X32#
  packWord8X64# :: (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #) -> Word8X64#
  par# :: forall a. a -> Int#
  pdep# :: Word# -> Word# -> Word#
  pdep16# :: Word# -> Word# -> Word#
  pdep32# :: Word# -> Word# -> Word#
  pdep64# :: Word64# -> Word64# -> Word64#
  pdep8# :: Word# -> Word# -> Word#
  pext# :: Word# -> Word# -> Word#
  pext16# :: Word# -> Word# -> Word#
  pext32# :: Word# -> Word# -> Word#
  pext64# :: Word64# -> Word64# -> Word64#
  pext8# :: Word# -> Word# -> Word#
  plusAddr# :: Addr# -> Int# -> Addr#
  plusDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  plusDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  plusDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  plusFloat# :: Float# -> Float# -> Float#
  plusFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  plusFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  plusFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  plusInt16# :: Int16# -> Int16# -> Int16#
  plusInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  plusInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  plusInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  plusInt32# :: Int32# -> Int32# -> Int32#
  plusInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  plusInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  plusInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  plusInt64# :: Int64# -> Int64# -> Int64#
  plusInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  plusInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  plusInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  plusInt8# :: Int8# -> Int8# -> Int8#
  plusInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  plusInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  plusInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  plusWord# :: Word# -> Word# -> Word#
  plusWord16# :: Word16# -> Word16# -> Word16#
  plusWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  plusWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  plusWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  plusWord2# :: Word# -> Word# -> (# Word#, Word# #)
  plusWord32# :: Word32# -> Word32# -> Word32#
  plusWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  plusWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  plusWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  plusWord64# :: Word64# -> Word64# -> Word64#
  plusWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  plusWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  plusWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  plusWord8# :: Word8# -> Word8# -> Word8#
  plusWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  plusWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  plusWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  popCnt# :: Word# -> Word#
  popCnt16# :: Word# -> Word#
  popCnt32# :: Word# -> Word#
  popCnt64# :: Word64# -> Word#
  popCnt8# :: Word# -> Word#
  powerFloat# :: Float# -> Float# -> Float#
  prefetchAddr0# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchAddr1# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchAddr2# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchAddr3# :: forall d. Addr# -> Int# -> State# d -> State# d
  prefetchByteArray0# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray1# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray2# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchByteArray3# :: forall d. ByteArray# -> Int# -> State# d -> State# d
  prefetchMutableByteArray0# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray1# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray2# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchMutableByteArray3# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  prefetchValue0# :: forall a d. a -> State# d -> State# d
  prefetchValue1# :: forall a d. a -> State# d -> State# d
  prefetchValue2# :: forall a d. a -> State# d -> State# d
  prefetchValue3# :: forall a d. a -> State# d -> State# d
  prompt# :: forall a. PromptTag# a -> (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  proxy# :: forall {k} (a :: k). Proxy# a
  putMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> a -> State# d -> State# d
  quotInt# :: Int# -> Int# -> Int#
  quotInt16# :: Int16# -> Int16# -> Int16#
  quotInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  quotInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  quotInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  quotInt32# :: Int32# -> Int32# -> Int32#
  quotInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  quotInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  quotInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  quotInt64# :: Int64# -> Int64# -> Int64#
  quotInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  quotInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  quotInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  quotInt8# :: Int8# -> Int8# -> Int8#
  quotInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  quotInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  quotInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  quotRemInt# :: Int# -> Int# -> (# Int#, Int# #)
  quotRemInt16# :: Int16# -> Int16# -> (# Int16#, Int16# #)
  quotRemInt32# :: Int32# -> Int32# -> (# Int32#, Int32# #)
  quotRemInt8# :: Int8# -> Int8# -> (# Int8#, Int8# #)
  quotRemWord# :: Word# -> Word# -> (# Word#, Word# #)
  quotRemWord16# :: Word16# -> Word16# -> (# Word16#, Word16# #)
  quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#, Word# #)
  quotRemWord32# :: Word32# -> Word32# -> (# Word32#, Word32# #)
  quotRemWord8# :: Word8# -> Word8# -> (# Word8#, Word8# #)
  quotWord# :: Word# -> Word# -> Word#
  quotWord16# :: Word16# -> Word16# -> Word16#
  quotWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  quotWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  quotWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  quotWord32# :: Word32# -> Word32# -> Word32#
  quotWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  quotWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  quotWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  quotWord64# :: Word64# -> Word64# -> Word64#
  quotWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  quotWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  quotWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  quotWord8# :: Word8# -> Word8# -> Word8#
  quotWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  quotWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  quotWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  raise# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE (BoxedRep l)) (b :: TYPE r). a -> b
  raiseDivZero# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
  raiseIO# :: forall {l :: Levity} {r :: RuntimeRep} (a :: TYPE (BoxedRep l)) (b :: TYPE r). a -> State# RealWorld -> (# State# RealWorld, b #)
  raiseOverflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
  raiseUnderflow# :: forall {r :: RuntimeRep} (b :: TYPE r). (# #) -> b
  readAddrArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readAddrOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Addr# #)
  readArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readArrayArrayArray# :: forall s. MutableArrayArray# s -> Int# -> State# s -> (# State# s, ArrayArray# #)
  readByteArrayArray# :: forall s. MutableArrayArray# s -> Int# -> State# s -> (# State# s, ByteArray# #)
  readCharArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readCharOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readDoubleArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleArrayAsDoubleX2# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleArrayAsDoubleX4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleArrayAsDoubleX8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Double# #)
  readDoubleOffAddrAsDoubleX2# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleOffAddrAsDoubleX4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleOffAddrAsDoubleX8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX2Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX2OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX2# #)
  readDoubleX4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX4# #)
  readDoubleX8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readDoubleX8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, DoubleX8# #)
  readFloatArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readFloatArrayAsFloatX16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatArrayAsFloatX4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatArrayAsFloatX8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Float# #)
  readFloatOffAddrAsFloatX16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatOffAddrAsFloatX4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatOffAddrAsFloatX8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX16# #)
  readFloatX4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX4# #)
  readFloatX8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, FloatX8# #)
  readFloatX8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, FloatX8# #)
  readIOPort# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). IOPort# d a -> State# d -> (# State# d, a #)
  readInt16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16ArrayAsInt16X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16ArrayAsInt16X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16ArrayAsInt16X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16# #)
  readInt16OffAddrAsInt16X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16OffAddrAsInt16X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16OffAddrAsInt16X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X16# #)
  readInt16X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X32# #)
  readInt16X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt16X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int16X8# #)
  readInt32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32ArrayAsInt32X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32ArrayAsInt32X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32ArrayAsInt32X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32# #)
  readInt32OffAddrAsInt32X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32OffAddrAsInt32X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32OffAddrAsInt32X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X16# #)
  readInt32X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X4# #)
  readInt32X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt32X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int32X8# #)
  readInt64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64ArrayAsInt64X2# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64ArrayAsInt64X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64ArrayAsInt64X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64# #)
  readInt64OffAddrAsInt64X2# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64OffAddrAsInt64X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64OffAddrAsInt64X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X2Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X2OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X2# #)
  readInt64X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X4# #)
  readInt64X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt64X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int64X8# #)
  readInt8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8ArrayAsInt8X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8ArrayAsInt8X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8ArrayAsInt8X64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8# #)
  readInt8OffAddrAsInt8X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8OffAddrAsInt8X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8OffAddrAsInt8X64# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X16# #)
  readInt8X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X32# #)
  readInt8X64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int8X64# #)
  readInt8X64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int8X64# #)
  readIntArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readIntOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Int# #)
  readMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)
  readMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> State# d -> (# State# d, a #)
  readMutableArrayArrayArray# :: forall s. MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableArrayArray# s #)
  readMutableByteArrayArray# :: forall s. MutableArrayArray# s -> Int# -> State# s -> (# State# s, MutableByteArray# s #)
  readSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> (# State# d, a #)
  readStablePtrArray# :: forall d a. MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readStablePtrOffAddr# :: forall d a. Addr# -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readTVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)
  readTVarIO# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). TVar# d a -> State# d -> (# State# d, a #)
  readWideCharArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWideCharOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Char# #)
  readWord16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16ArrayAsWord16X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16ArrayAsWord16X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16ArrayAsWord16X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16# #)
  readWord16OffAddrAsWord16X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16OffAddrAsWord16X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16OffAddrAsWord16X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X16# #)
  readWord16X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X32# #)
  readWord16X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord16X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word16X8# #)
  readWord32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32ArrayAsWord32X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32ArrayAsWord32X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32ArrayAsWord32X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32# #)
  readWord32OffAddrAsWord32X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32OffAddrAsWord32X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32OffAddrAsWord32X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X16# #)
  readWord32X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X4# #)
  readWord32X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord32X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word32X8# #)
  readWord64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64ArrayAsWord64X2# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64ArrayAsWord64X4# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64ArrayAsWord64X8# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64# #)
  readWord64OffAddrAsWord64X2# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64OffAddrAsWord64X4# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64OffAddrAsWord64X8# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X2Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X2OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X2# #)
  readWord64X4Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X4OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X4# #)
  readWord64X8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord64X8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word64X8# #)
  readWord8Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8ArrayAsAddr# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Addr# #)
  readWord8ArrayAsChar# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsDouble# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Double# #)
  readWord8ArrayAsFloat# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Float# #)
  readWord8ArrayAsInt# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int# #)
  readWord8ArrayAsInt16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int16# #)
  readWord8ArrayAsInt32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int32# #)
  readWord8ArrayAsInt64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Int64# #)
  readWord8ArrayAsStablePtr# :: forall d a. MutableByteArray# d -> Int# -> State# d -> (# State# d, StablePtr# a #)
  readWord8ArrayAsWideChar# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Char# #)
  readWord8ArrayAsWord# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWord8ArrayAsWord16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word16# #)
  readWord8ArrayAsWord32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word32# #)
  readWord8ArrayAsWord64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word64# #)
  readWord8ArrayAsWord8X16# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8ArrayAsWord8X32# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8ArrayAsWord8X64# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8# #)
  readWord8OffAddrAsWord8X16# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8OffAddrAsWord8X32# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8OffAddrAsWord8X64# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X16Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X16OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X16# #)
  readWord8X32Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X32OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X32# #)
  readWord8X64Array# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWord8X64OffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word8X64# #)
  readWordArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, Word# #)
  readWordOffAddr# :: forall d. Addr# -> Int# -> State# d -> (# State# d, Word# #)
  realWorld# :: State# RealWorld
  reallyUnsafePtrEquality :: forall a. a -> a -> Int#
  reallyUnsafePtrEquality# :: forall {l :: Levity} {k :: Levity} (a :: TYPE (BoxedRep l)) (b :: TYPE (BoxedRep k)). a -> b -> Int#
  remAddr# :: Addr# -> Int# -> Int#
  remInt# :: Int# -> Int# -> Int#
  remInt16# :: Int16# -> Int16# -> Int16#
  remInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  remInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  remInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  remInt32# :: Int32# -> Int32# -> Int32#
  remInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  remInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  remInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  remInt64# :: Int64# -> Int64# -> Int64#
  remInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  remInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  remInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  remInt8# :: Int8# -> Int8# -> Int8#
  remInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  remInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  remInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  remWord# :: Word# -> Word# -> Word#
  remWord16# :: Word16# -> Word16# -> Word16#
  remWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  remWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  remWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  remWord32# :: Word32# -> Word32# -> Word32#
  remWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  remWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  remWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  remWord64# :: Word64# -> Word64# -> Word64#
  remWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  remWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  remWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  remWord8# :: Word8# -> Word8# -> Word8#
  remWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  remWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  remWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  resizeMutableByteArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> (# State# d, MutableByteArray# d #)
  resizeSmallMutableArray# :: forall s a. SmallMutableArray# s a -> Int# -> a -> State# s -> (# State# s, SmallMutableArray# s a #)
  retry# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). State# RealWorld -> (# State# RealWorld, a #)
  rightSection :: forall {q :: RuntimeRep} {r :: RuntimeRep} {s :: RuntimeRep} (a :: TYPE q) (b :: TYPE r) (c :: TYPE s). (a -> b -> c) -> b -> a -> c
  runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -> o) -> o
  sameArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Array# a -> Int#
  sameArrayArray# :: ArrayArray# -> ArrayArray# -> Int#
  sameByteArray# :: ByteArray# -> ByteArray# -> Int#
  sameIOPort# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). IOPort# s a -> IOPort# s a -> Int#
  sameMVar# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). MVar# s a -> MVar# s a -> Int#
  sameMutVar# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). MutVar# s a -> MutVar# s a -> Int#
  sameMutableArray# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). MutableArray# s a -> MutableArray# s a -> Int#
  sameMutableArrayArray# :: forall s. MutableArrayArray# s -> MutableArrayArray# s -> Int#
  sameMutableByteArray# :: forall s. MutableByteArray# s -> MutableByteArray# s -> Int#
  samePromptTag# :: forall a. PromptTag# a -> PromptTag# a -> Int#
  sameSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> SmallArray# a -> Int#
  sameSmallMutableArray# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). SmallMutableArray# s a -> SmallMutableArray# s a -> Int#
  sameTVar# :: forall {l :: Levity} s (a :: TYPE (BoxedRep l)). TVar# s a -> TVar# s a -> Int#
  seq :: forall {r :: RuntimeRep} a (b :: TYPE r). a -> b -> b
  seq# :: forall a d. a -> State# d -> (# State# d, a #)
  setAddrRange# :: Addr# -> Int# -> Int# -> State# RealWorld -> State# RealWorld
  setByteArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> Int# -> State# d -> State# d
  setThreadAllocationCounter# :: Int64# -> State# RealWorld -> State# RealWorld
  shiftL# :: Word# -> Int# -> Word#
  shiftRL# :: Word# -> Int# -> Word#
  shrinkMutableByteArray# :: forall d. MutableByteArray# d -> Int# -> State# d -> State# d
  shrinkSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> State# d -> State# d
  sinDouble# :: Double# -> Double#
  sinFloat# :: Float# -> Float#
  sinhDouble# :: Double# -> Double#
  sinhFloat# :: Float# -> Float#
  sizeofArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). Array# a -> Int#
  sizeofArrayArray# :: ArrayArray# -> Int#
  sizeofByteArray# :: ByteArray# -> Int#
  sizeofMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int#
  sizeofMutableArrayArray# :: forall s. MutableArrayArray# s -> Int#
  sizeofMutableByteArray# :: forall d. MutableByteArray# d -> Int#
  sizeofSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). SmallArray# a -> Int#
  sizeofSmallMutableArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int#
  sortWith :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
  spark# :: forall a d. a -> State# d -> (# State# d, a #)
  sqrtDouble# :: Double# -> Double#
  sqrtFloat# :: Float# -> Float#
  stableNameToInt# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)). StableName# a -> Int#
  subInt16# :: Int16# -> Int16# -> Int16#
  subInt32# :: Int32# -> Int32# -> Int32#
  subInt64# :: Int64# -> Int64# -> Int64#
  subInt8# :: Int8# -> Int8# -> Int8#
  subIntC# :: Int# -> Int# -> (# Int#, Int# #)
  subWord16# :: Word16# -> Word16# -> Word16#
  subWord32# :: Word32# -> Word32# -> Word32#
  subWord64# :: Word64# -> Word64# -> Word64#
  subWord8# :: Word8# -> Word8# -> Word8#
  subWordC# :: Word# -> Word# -> (# Word#, Int# #)
  tagToEnum# :: forall a. Int# -> a
  takeMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, a #)
  tanDouble# :: Double# -> Double#
  tanFloat# :: Float# -> Float#
  tanhDouble# :: Double# -> Double#
  tanhFloat# :: Float# -> Float#
  thawArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Array# a -> Int# -> Int# -> State# d -> (# State# d, MutableArray# d a #)
  thawSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. SmallArray# a -> Int# -> Int# -> State# d -> (# State# d, SmallMutableArray# d a #)
  the :: forall a. GHC.Classes.Eq a => [a] -> a
  threadLabel# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, ByteArray# #)
  threadStatus# :: ThreadId# -> State# RealWorld -> (# State# RealWorld, Int#, Int#, Int# #)
  timesDoubleX2# :: DoubleX2# -> DoubleX2# -> DoubleX2#
  timesDoubleX4# :: DoubleX4# -> DoubleX4# -> DoubleX4#
  timesDoubleX8# :: DoubleX8# -> DoubleX8# -> DoubleX8#
  timesFloat# :: Float# -> Float# -> Float#
  timesFloatX16# :: FloatX16# -> FloatX16# -> FloatX16#
  timesFloatX4# :: FloatX4# -> FloatX4# -> FloatX4#
  timesFloatX8# :: FloatX8# -> FloatX8# -> FloatX8#
  timesInt16# :: Int16# -> Int16# -> Int16#
  timesInt16X16# :: Int16X16# -> Int16X16# -> Int16X16#
  timesInt16X32# :: Int16X32# -> Int16X32# -> Int16X32#
  timesInt16X8# :: Int16X8# -> Int16X8# -> Int16X8#
  timesInt2# :: Int# -> Int# -> (# Int#, Int#, Int# #)
  timesInt32# :: Int32# -> Int32# -> Int32#
  timesInt32X16# :: Int32X16# -> Int32X16# -> Int32X16#
  timesInt32X4# :: Int32X4# -> Int32X4# -> Int32X4#
  timesInt32X8# :: Int32X8# -> Int32X8# -> Int32X8#
  timesInt64# :: Int64# -> Int64# -> Int64#
  timesInt64X2# :: Int64X2# -> Int64X2# -> Int64X2#
  timesInt64X4# :: Int64X4# -> Int64X4# -> Int64X4#
  timesInt64X8# :: Int64X8# -> Int64X8# -> Int64X8#
  timesInt8# :: Int8# -> Int8# -> Int8#
  timesInt8X16# :: Int8X16# -> Int8X16# -> Int8X16#
  timesInt8X32# :: Int8X32# -> Int8X32# -> Int8X32#
  timesInt8X64# :: Int8X64# -> Int8X64# -> Int8X64#
  timesWord# :: Word# -> Word# -> Word#
  timesWord16# :: Word16# -> Word16# -> Word16#
  timesWord16X16# :: Word16X16# -> Word16X16# -> Word16X16#
  timesWord16X32# :: Word16X32# -> Word16X32# -> Word16X32#
  timesWord16X8# :: Word16X8# -> Word16X8# -> Word16X8#
  timesWord2# :: Word# -> Word# -> (# Word#, Word# #)
  timesWord32# :: Word32# -> Word32# -> Word32#
  timesWord32X16# :: Word32X16# -> Word32X16# -> Word32X16#
  timesWord32X4# :: Word32X4# -> Word32X4# -> Word32X4#
  timesWord32X8# :: Word32X8# -> Word32X8# -> Word32X8#
  timesWord64# :: Word64# -> Word64# -> Word64#
  timesWord64X2# :: Word64X2# -> Word64X2# -> Word64X2#
  timesWord64X4# :: Word64X4# -> Word64X4# -> Word64X4#
  timesWord64X8# :: Word64X8# -> Word64X8# -> Word64X8#
  timesWord8# :: Word8# -> Word8# -> Word8#
  timesWord8X16# :: Word8X16# -> Word8X16# -> Word8X16#
  timesWord8X32# :: Word8X32# -> Word8X32# -> Word8X32#
  timesWord8X64# :: Word8X64# -> Word8X64# -> Word8X64#
  touch# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. a -> State# d -> State# d
  traceBinaryEvent# :: forall d. Addr# -> Int# -> State# d -> State# d
  traceEvent :: GHC.Base.String -> GHC.Types.IO ()
  traceEvent# :: forall d. Addr# -> State# d -> State# d
  traceMarker# :: forall d. Addr# -> State# d -> State# d
  tryPutMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> a -> State# d -> (# State# d, Int# #)
  tryReadMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)
  tryTakeMVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MVar# d a -> State# d -> (# State# d, Int#, a #)
  uncheckedIShiftL# :: Int# -> Int# -> Int#
  uncheckedIShiftL64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRA# :: Int# -> Int# -> Int#
  uncheckedIShiftRA64# :: Int64# -> Int# -> Int64#
  uncheckedIShiftRL# :: Int# -> Int# -> Int#
  uncheckedIShiftRL64# :: Int64# -> Int# -> Int64#
  uncheckedShiftL# :: Word# -> Int# -> Word#
  uncheckedShiftL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftLWord8# :: Word8# -> Int# -> Word8#
  uncheckedShiftRAInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRAInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRAInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRL# :: Word# -> Int# -> Word#
  uncheckedShiftRL64# :: Word64# -> Int# -> Word64#
  uncheckedShiftRLInt16# :: Int16# -> Int# -> Int16#
  uncheckedShiftRLInt32# :: Int32# -> Int# -> Int32#
  uncheckedShiftRLInt8# :: Int8# -> Int# -> Int8#
  uncheckedShiftRLWord16# :: Word16# -> Int# -> Word16#
  uncheckedShiftRLWord32# :: Word32# -> Int# -> Word32#
  uncheckedShiftRLWord8# :: Word8# -> Int# -> Word8#
  unmaskAsyncExceptions# :: forall {q :: RuntimeRep} (a :: TYPE q). (State# RealWorld -> (# State# RealWorld, a #)) -> State# RealWorld -> (# State# RealWorld, a #)
  unpackAppendCString# :: Addr# -> [Char] -> [Char]
  unpackCString# :: Addr# -> [Char]
  unpackCStringUtf8# :: Addr# -> [Char]
  unpackClosure# :: forall a b. a -> (# Addr#, ByteArray#, Array# b #)
  unpackDoubleX2# :: DoubleX2# -> (# Double#, Double# #)
  unpackDoubleX4# :: DoubleX4# -> (# Double#, Double#, Double#, Double# #)
  unpackDoubleX8# :: DoubleX8# -> (# Double#, Double#, Double#, Double#, Double#, Double#, Double#, Double# #)
  unpackFloatX16# :: FloatX16# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFloatX4# :: FloatX4# -> (# Float#, Float#, Float#, Float# #)
  unpackFloatX8# :: FloatX8# -> (# Float#, Float#, Float#, Float#, Float#, Float#, Float#, Float# #)
  unpackFoldrCString# :: forall a. Addr# -> (Char -> a -> a) -> a -> a
  unpackInt16X16# :: Int16X16# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X32# :: Int16X32# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt16X8# :: Int16X8# -> (# Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16#, Int16# #)
  unpackInt32X16# :: Int32X16# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X4# :: Int32X4# -> (# Int32#, Int32#, Int32#, Int32# #)
  unpackInt32X8# :: Int32X8# -> (# Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32#, Int32# #)
  unpackInt64X2# :: Int64X2# -> (# Int64#, Int64# #)
  unpackInt64X4# :: Int64X4# -> (# Int64#, Int64#, Int64#, Int64# #)
  unpackInt64X8# :: Int64X8# -> (# Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64#, Int64# #)
  unpackInt8X16# :: Int8X16# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X32# :: Int8X32# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackInt8X64# :: Int8X64# -> (# Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8#, Int8# #)
  unpackNBytes# :: Addr# -> Int# -> [Char]
  unpackWord16X16# :: Word16X16# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X32# :: Word16X32# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord16X8# :: Word16X8# -> (# Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16#, Word16# #)
  unpackWord32X16# :: Word32X16# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X4# :: Word32X4# -> (# Word32#, Word32#, Word32#, Word32# #)
  unpackWord32X8# :: Word32X8# -> (# Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32#, Word32# #)
  unpackWord64X2# :: Word64X2# -> (# Word64#, Word64# #)
  unpackWord64X4# :: Word64X4# -> (# Word64#, Word64#, Word64#, Word64# #)
  unpackWord64X8# :: Word64X8# -> (# Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64#, Word64# #)
  unpackWord8X16# :: Word8X16# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X32# :: Word8X32# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unpackWord8X64# :: Word8X64# -> (# Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8#, Word8# #)
  unsafeCoerce# :: forall (q :: RuntimeRep) (r :: RuntimeRep) (a :: TYPE q) (b :: TYPE r). a -> b
  unsafeFreezeArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> State# d -> (# State# d, Array# a #)
  unsafeFreezeArrayArray# :: forall s. MutableArrayArray# s -> State# s -> (# State# s, ArrayArray# #)
  unsafeFreezeByteArray# :: forall d. MutableByteArray# d -> State# d -> (# State# d, ByteArray# #)
  unsafeFreezeSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> State# d -> (# State# d, SmallArray# a #)
  unsafePtrEquality# :: forall (a :: UnliftedType) (b :: UnliftedType). a -> b -> Int#
  unsafeThawArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. Array# a -> State# d -> (# State# d, MutableArray# d a #)
  unsafeThawByteArray# :: forall d. ByteArray# -> State# d -> (# State# d, MutableByteArray# d #)
  unsafeThawSmallArray# :: forall {l :: Levity} (a :: TYPE (BoxedRep l)) d. SmallArray# a -> State# d -> (# State# d, SmallMutableArray# d a #)
  void# :: (# #)
  waitRead# :: forall d. Int# -> State# d -> State# d
  waitWrite# :: forall d. Int# -> State# d -> State# d
  whereFrom# :: forall a d. a -> State# d -> (# State# d, Addr# #)
  word16ToInt16# :: Word16# -> Int16#
  word16ToWord# :: Word16# -> Word#
  word2Double# :: Word# -> Double#
  word2Float# :: Word# -> Float#
  word2Int# :: Word# -> Int#
  word32ToInt32# :: Word32# -> Int32#
  word32ToWord# :: Word32# -> Word#
  word64ToInt64# :: Word64# -> Int64#
  word64ToWord# :: Word64# -> Word#
  word8ToInt8# :: Word8# -> Int8#
  word8ToWord# :: Word8# -> Word#
  wordToWord16# :: Word# -> Word16#
  wordToWord32# :: Word# -> Word32#
  wordToWord64# :: Word# -> Word64#
  wordToWord8# :: Word# -> Word8#
  writeAddrArray# :: forall d. MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeAddrOffAddr# :: forall d. Addr# -> Int# -> Addr# -> State# d -> State# d
  writeArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutableArray# d a -> Int# -> a -> State# d -> State# d
  writeArrayArrayArray# :: forall s. MutableArrayArray# s -> Int# -> ArrayArray# -> State# s -> State# s
  writeByteArrayArray# :: forall s. MutableArrayArray# s -> Int# -> ByteArray# -> State# s -> State# s
  writeCharArray# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeCharOffAddr# :: forall d. Addr# -> Int# -> Char# -> State# d -> State# d
  writeDoubleArray# :: forall d. MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeDoubleArrayAsDoubleX2# :: forall d. MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleArrayAsDoubleX4# :: forall d. MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleArrayAsDoubleX8# :: forall d. MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleOffAddr# :: forall d. Addr# -> Int# -> Double# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX2# :: forall d. Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX4# :: forall d. Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleOffAddrAsDoubleX8# :: forall d. Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX2Array# :: forall d. MutableByteArray# d -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX2OffAddr# :: forall d. Addr# -> Int# -> DoubleX2# -> State# d -> State# d
  writeDoubleX4Array# :: forall d. MutableByteArray# d -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX4OffAddr# :: forall d. Addr# -> Int# -> DoubleX4# -> State# d -> State# d
  writeDoubleX8Array# :: forall d. MutableByteArray# d -> Int# -> DoubleX8# -> State# d -> State# d
  writeDoubleX8OffAddr# :: forall d. Addr# -> Int# -> DoubleX8# -> State# d -> State# d
  writeFloatArray# :: forall d. MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeFloatArrayAsFloatX16# :: forall d. MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatArrayAsFloatX4# :: forall d. MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatArrayAsFloatX8# :: forall d. MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatOffAddr# :: forall d. Addr# -> Int# -> Float# -> State# d -> State# d
  writeFloatOffAddrAsFloatX16# :: forall d. Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatOffAddrAsFloatX4# :: forall d. Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatOffAddrAsFloatX8# :: forall d. Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX16Array# :: forall d. MutableByteArray# d -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX16OffAddr# :: forall d. Addr# -> Int# -> FloatX16# -> State# d -> State# d
  writeFloatX4Array# :: forall d. MutableByteArray# d -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX4OffAddr# :: forall d. Addr# -> Int# -> FloatX4# -> State# d -> State# d
  writeFloatX8Array# :: forall d. MutableByteArray# d -> Int# -> FloatX8# -> State# d -> State# d
  writeFloatX8OffAddr# :: forall d. Addr# -> Int# -> FloatX8# -> State# d -> State# d
  writeIOPort# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). IOPort# d a -> a -> State# d -> (# State# d, Int# #)
  writeInt16Array# :: forall d. MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeInt16ArrayAsInt16X16# :: forall d. MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16ArrayAsInt16X32# :: forall d. MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16ArrayAsInt16X8# :: forall d. MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16OffAddr# :: forall d. Addr# -> Int# -> Int16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X16# :: forall d. Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16OffAddrAsInt16X32# :: forall d. Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16OffAddrAsInt16X8# :: forall d. Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X16Array# :: forall d. MutableByteArray# d -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X16OffAddr# :: forall d. Addr# -> Int# -> Int16X16# -> State# d -> State# d
  writeInt16X32Array# :: forall d. MutableByteArray# d -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X32OffAddr# :: forall d. Addr# -> Int# -> Int16X32# -> State# d -> State# d
  writeInt16X8Array# :: forall d. MutableByteArray# d -> Int# -> Int16X8# -> State# d -> State# d
  writeInt16X8OffAddr# :: forall d. Addr# -> Int# -> Int16X8# -> State# d -> State# d
  writeInt32Array# :: forall d. MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeInt32ArrayAsInt32X16# :: forall d. MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32ArrayAsInt32X4# :: forall d. MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32ArrayAsInt32X8# :: forall d. MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32OffAddr# :: forall d. Addr# -> Int# -> Int32# -> State# d -> State# d
  writeInt32OffAddrAsInt32X16# :: forall d. Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32OffAddrAsInt32X4# :: forall d. Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32OffAddrAsInt32X8# :: forall d. Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X16Array# :: forall d. MutableByteArray# d -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X16OffAddr# :: forall d. Addr# -> Int# -> Int32X16# -> State# d -> State# d
  writeInt32X4Array# :: forall d. MutableByteArray# d -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X4OffAddr# :: forall d. Addr# -> Int# -> Int32X4# -> State# d -> State# d
  writeInt32X8Array# :: forall d. MutableByteArray# d -> Int# -> Int32X8# -> State# d -> State# d
  writeInt32X8OffAddr# :: forall d. Addr# -> Int# -> Int32X8# -> State# d -> State# d
  writeInt64Array# :: forall d. MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeInt64ArrayAsInt64X2# :: forall d. MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64ArrayAsInt64X4# :: forall d. MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64ArrayAsInt64X8# :: forall d. MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64OffAddr# :: forall d. Addr# -> Int# -> Int64# -> State# d -> State# d
  writeInt64OffAddrAsInt64X2# :: forall d. Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64OffAddrAsInt64X4# :: forall d. Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64OffAddrAsInt64X8# :: forall d. Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X2Array# :: forall d. MutableByteArray# d -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X2OffAddr# :: forall d. Addr# -> Int# -> Int64X2# -> State# d -> State# d
  writeInt64X4Array# :: forall d. MutableByteArray# d -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X4OffAddr# :: forall d. Addr# -> Int# -> Int64X4# -> State# d -> State# d
  writeInt64X8Array# :: forall d. MutableByteArray# d -> Int# -> Int64X8# -> State# d -> State# d
  writeInt64X8OffAddr# :: forall d. Addr# -> Int# -> Int64X8# -> State# d -> State# d
  writeInt8Array# :: forall d. MutableByteArray# d -> Int# -> Int8# -> State# d -> State# d
  writeInt8ArrayAsInt8X16# :: forall d. MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8ArrayAsInt8X32# :: forall d. MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8ArrayAsInt8X64# :: forall d. MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8OffAddr# :: forall d. Addr# -> Int# -> Int8# -> State# d -> State# d
  writeInt8OffAddrAsInt8X16# :: forall d. Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8OffAddrAsInt8X32# :: forall d. Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8OffAddrAsInt8X64# :: forall d. Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X16Array# :: forall d. MutableByteArray# d -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X16OffAddr# :: forall d. Addr# -> Int# -> Int8X16# -> State# d -> State# d
  writeInt8X32Array# :: forall d. MutableByteArray# d -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X32OffAddr# :: forall d. Addr# -> Int# -> Int8X32# -> State# d -> State# d
  writeInt8X64Array# :: forall d. MutableByteArray# d -> Int# -> Int8X64# -> State# d -> State# d
  writeInt8X64OffAddr# :: forall d. Addr# -> Int# -> Int8X64# -> State# d -> State# d
  writeIntArray# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeIntOffAddr# :: forall d. Addr# -> Int# -> Int# -> State# d -> State# d
  writeMutVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). MutVar# d a -> a -> State# d -> State# d
  writeMutableArrayArrayArray# :: forall s. MutableArrayArray# s -> Int# -> MutableArrayArray# s -> State# s -> State# s
  writeMutableByteArrayArray# :: forall s. MutableArrayArray# s -> Int# -> MutableByteArray# s -> State# s -> State# s
  writeSmallArray# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). SmallMutableArray# d a -> Int# -> a -> State# d -> State# d
  writeStablePtrArray# :: forall d a. MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeStablePtrOffAddr# :: forall a d. Addr# -> Int# -> StablePtr# a -> State# d -> State# d
  writeTVar# :: forall {l :: Levity} d (a :: TYPE (BoxedRep l)). TVar# d a -> a -> State# d -> State# d
  writeWideCharArray# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWideCharOffAddr# :: forall d. Addr# -> Int# -> Char# -> State# d -> State# d
  writeWord16Array# :: forall d. MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord16ArrayAsWord16X16# :: forall d. MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16ArrayAsWord16X32# :: forall d. MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16ArrayAsWord16X8# :: forall d. MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16OffAddr# :: forall d. Addr# -> Int# -> Word16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X16# :: forall d. Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16OffAddrAsWord16X32# :: forall d. Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16OffAddrAsWord16X8# :: forall d. Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X16Array# :: forall d. MutableByteArray# d -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X16OffAddr# :: forall d. Addr# -> Int# -> Word16X16# -> State# d -> State# d
  writeWord16X32Array# :: forall d. MutableByteArray# d -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X32OffAddr# :: forall d. Addr# -> Int# -> Word16X32# -> State# d -> State# d
  writeWord16X8Array# :: forall d. MutableByteArray# d -> Int# -> Word16X8# -> State# d -> State# d
  writeWord16X8OffAddr# :: forall d. Addr# -> Int# -> Word16X8# -> State# d -> State# d
  writeWord32Array# :: forall d. MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord32ArrayAsWord32X16# :: forall d. MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32ArrayAsWord32X4# :: forall d. MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32ArrayAsWord32X8# :: forall d. MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32OffAddr# :: forall d. Addr# -> Int# -> Word32# -> State# d -> State# d
  writeWord32OffAddrAsWord32X16# :: forall d. Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32OffAddrAsWord32X4# :: forall d. Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32OffAddrAsWord32X8# :: forall d. Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X16Array# :: forall d. MutableByteArray# d -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X16OffAddr# :: forall d. Addr# -> Int# -> Word32X16# -> State# d -> State# d
  writeWord32X4Array# :: forall d. MutableByteArray# d -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X4OffAddr# :: forall d. Addr# -> Int# -> Word32X4# -> State# d -> State# d
  writeWord32X8Array# :: forall d. MutableByteArray# d -> Int# -> Word32X8# -> State# d -> State# d
  writeWord32X8OffAddr# :: forall d. Addr# -> Int# -> Word32X8# -> State# d -> State# d
  writeWord64Array# :: forall d. MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord64ArrayAsWord64X2# :: forall d. MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64ArrayAsWord64X4# :: forall d. MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64ArrayAsWord64X8# :: forall d. MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64OffAddr# :: forall d. Addr# -> Int# -> Word64# -> State# d -> State# d
  writeWord64OffAddrAsWord64X2# :: forall d. Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64OffAddrAsWord64X4# :: forall d. Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64OffAddrAsWord64X8# :: forall d. Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X2Array# :: forall d. MutableByteArray# d -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X2OffAddr# :: forall d. Addr# -> Int# -> Word64X2# -> State# d -> State# d
  writeWord64X4Array# :: forall d. MutableByteArray# d -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X4OffAddr# :: forall d. Addr# -> Int# -> Word64X4# -> State# d -> State# d
  writeWord64X8Array# :: forall d. MutableByteArray# d -> Int# -> Word64X8# -> State# d -> State# d
  writeWord64X8OffAddr# :: forall d. Addr# -> Int# -> Word64X8# -> State# d -> State# d
  writeWord8Array# :: forall d. MutableByteArray# d -> Int# -> Word8# -> State# d -> State# d
  writeWord8ArrayAsAddr# :: forall d. MutableByteArray# d -> Int# -> Addr# -> State# d -> State# d
  writeWord8ArrayAsChar# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsDouble# :: forall d. MutableByteArray# d -> Int# -> Double# -> State# d -> State# d
  writeWord8ArrayAsFloat# :: forall d. MutableByteArray# d -> Int# -> Float# -> State# d -> State# d
  writeWord8ArrayAsInt# :: forall d. MutableByteArray# d -> Int# -> Int# -> State# d -> State# d
  writeWord8ArrayAsInt16# :: forall d. MutableByteArray# d -> Int# -> Int16# -> State# d -> State# d
  writeWord8ArrayAsInt32# :: forall d. MutableByteArray# d -> Int# -> Int32# -> State# d -> State# d
  writeWord8ArrayAsInt64# :: forall d. MutableByteArray# d -> Int# -> Int64# -> State# d -> State# d
  writeWord8ArrayAsStablePtr# :: forall d a. MutableByteArray# d -> Int# -> StablePtr# a -> State# d -> State# d
  writeWord8ArrayAsWideChar# :: forall d. MutableByteArray# d -> Int# -> Char# -> State# d -> State# d
  writeWord8ArrayAsWord# :: forall d. MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWord8ArrayAsWord16# :: forall d. MutableByteArray# d -> Int# -> Word16# -> State# d -> State# d
  writeWord8ArrayAsWord32# :: forall d. MutableByteArray# d -> Int# -> Word32# -> State# d -> State# d
  writeWord8ArrayAsWord64# :: forall d. MutableByteArray# d -> Int# -> Word64# -> State# d -> State# d
  writeWord8ArrayAsWord8X16# :: forall d. MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8ArrayAsWord8X32# :: forall d. MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8ArrayAsWord8X64# :: forall d. MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8OffAddr# :: forall d. Addr# -> Int# -> Word8# -> State# d -> State# d
  writeWord8OffAddrAsWord8X16# :: forall d. Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8OffAddrAsWord8X32# :: forall d. Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8OffAddrAsWord8X64# :: forall d. Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X16Array# :: forall d. MutableByteArray# d -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X16OffAddr# :: forall d. Addr# -> Int# -> Word8X16# -> State# d -> State# d
  writeWord8X32Array# :: forall d. MutableByteArray# d -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X32OffAddr# :: forall d. Addr# -> Int# -> Word8X32# -> State# d -> State# d
  writeWord8X64Array# :: forall d. MutableByteArray# d -> Int# -> Word8X64# -> State# d -> State# d
  writeWord8X64OffAddr# :: forall d. Addr# -> Int# -> Word8X64# -> State# d -> State# d
  writeWordArray# :: forall d. MutableByteArray# d -> Int# -> Word# -> State# d -> State# d
  writeWordOffAddr# :: forall d. Addr# -> Int# -> Word# -> State# d -> State# d
  xor# :: Word# -> Word# -> Word#
  xor64# :: Word64# -> Word64# -> Word64#
  xorI# :: Int# -> Int# -> Int#
  xorWord16# :: Word16# -> Word16# -> Word16#
  xorWord32# :: Word32# -> Word32# -> Word32#
  xorWord8# :: Word8# -> Word8# -> Word8#
  yield# :: State# RealWorld -> State# RealWorld
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
    {-# MINIMAL #-}
  type (~~) :: forall k0 k1. k0 -> k1 -> Constraint
  class (a ~~ b) => (~~) a b
    {-# MINIMAL #-}

module GHC.Fingerprint where
  -- Safety: Trustworthy
  type Fingerprint :: *
  data Fingerprint = Fingerprint {-# UNPACK #-}GHC.Word.Word64 {-# UNPACK #-}GHC.Word.Word64
  fingerprint0 :: Fingerprint
  fingerprintData :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO Fingerprint
  fingerprintFingerprints :: [Fingerprint] -> Fingerprint
  fingerprintString :: GHC.Base.String -> Fingerprint
  getFileHash :: GHC.IO.FilePath -> GHC.Types.IO Fingerprint

module GHC.Fingerprint.Type where
  -- Safety: Trustworthy
  type Fingerprint :: *
  data Fingerprint = Fingerprint {-# UNPACK #-}GHC.Word.Word64 {-# UNPACK #-}GHC.Word.Word64

module GHC.Float where
  -- Safety: Trustworthy
  type Double :: *
  data Double = D# Double#
  type Double# :: TYPE GHC.Types.DoubleRep
  data Double#
  type FFFormat :: *
  data FFFormat = FFExponent | FFFixed | FFGeneric
  type Float :: *
  data Float = F# Float#
  type Float# :: TYPE GHC.Types.FloatRep
  data Float#
  type Floating :: * -> Constraint
  class GHC.Real.Fractional a => Floating a where
    pi :: a
    exp :: a -> a
    log :: a -> a
    sqrt :: a -> a
    (**) :: a -> a -> a
    logBase :: a -> a -> a
    sin :: a -> a
    cos :: a -> a
    tan :: a -> a
    asin :: a -> a
    acos :: a -> a
    atan :: a -> a
    sinh :: a -> a
    cosh :: a -> a
    tanh :: a -> a
    asinh :: a -> a
    acosh :: a -> a
    atanh :: a -> a
    log1p :: a -> a
    expm1 :: a -> a
    log1pexp :: a -> a
    log1mexp :: a -> a
    {-# MINIMAL pi, exp, log, sin, cos, asin, acos, atan, sinh, cosh, asinh, acosh, atanh #-}
  type RealFloat :: * -> Constraint
  class (GHC.Real.RealFrac a, Floating a) => RealFloat a where
    floatRadix :: a -> GHC.Num.Integer.Integer
    floatDigits :: a -> GHC.Types.Int
    floatRange :: a -> (GHC.Types.Int, GHC.Types.Int)
    decodeFloat :: a -> (GHC.Num.Integer.Integer, GHC.Types.Int)
    encodeFloat :: GHC.Num.Integer.Integer -> GHC.Types.Int -> a
    exponent :: a -> GHC.Types.Int
    significand :: a -> a
    scaleFloat :: GHC.Types.Int -> a -> a
    isNaN :: a -> GHC.Types.Bool
    isInfinite :: a -> GHC.Types.Bool
    isDenormalized :: a -> GHC.Types.Bool
    isNegativeZero :: a -> GHC.Types.Bool
    isIEEE :: a -> GHC.Types.Bool
    atan2 :: a -> a -> a
    {-# MINIMAL floatRadix, floatDigits, floatRange, decodeFloat, encodeFloat, isNaN, isInfinite, isDenormalized, isNegativeZero, isIEEE #-}
  acosDouble :: Double -> Double
  acosFloat :: Float -> Float
  acoshDouble :: Double -> Double
  acoshFloat :: Float -> Float
  asinDouble :: Double -> Double
  asinFloat :: Float -> Float
  asinhDouble :: Double -> Double
  asinhFloat :: Float -> Float
  atanDouble :: Double -> Double
  atanFloat :: Float -> Float
  atanhDouble :: Double -> Double
  atanhFloat :: Float -> Float
  castDoubleToWord64 :: Double -> GHC.Word.Word64
  castFloatToWord32 :: Float -> GHC.Word.Word32
  castWord32ToFloat :: GHC.Word.Word32 -> Float
  castWord64ToDouble :: GHC.Word.Word64 -> Double
  ceilingDouble :: forall b. GHC.Real.Integral b => Double -> b
  ceilingFloat :: forall b. GHC.Real.Integral b => Float -> b
  clamp :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  cosDouble :: Double -> Double
  cosFloat :: Float -> Float
  coshDouble :: Double -> Double
  coshFloat :: Float -> Float
  divideDouble :: Double -> Double -> Double
  divideFloat :: Float -> Float -> Float
  double2Float :: Double -> Float
  double2Int :: Double -> GHC.Types.Int
  eqDouble :: Double -> Double -> GHC.Types.Bool
  eqFloat :: Float -> Float -> GHC.Types.Bool
  expDouble :: Double -> Double
  expFloat :: Float -> Float
  expm1Double :: Double -> Double
  expm1Float :: Float -> Float
  expt :: GHC.Num.Integer.Integer -> GHC.Types.Int -> GHC.Num.Integer.Integer
  expts :: GHC.Arr.Array GHC.Types.Int GHC.Num.Integer.Integer
  expts10 :: GHC.Arr.Array GHC.Types.Int GHC.Num.Integer.Integer
  fabsDouble :: Double -> Double
  fabsFloat :: Float -> Float
  float2Double :: Float -> Double
  float2Int :: Float -> GHC.Types.Int
  floatToDigits :: forall a. RealFloat a => GHC.Num.Integer.Integer -> a -> ([GHC.Types.Int], GHC.Types.Int)
  floorDouble :: forall b. GHC.Real.Integral b => Double -> b
  floorFloat :: forall b. GHC.Real.Integral b => Float -> b
  formatRealFloat :: forall a. RealFloat a => FFFormat -> GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Base.String
  formatRealFloatAlt :: forall a. RealFloat a => FFFormat -> GHC.Maybe.Maybe GHC.Types.Int -> GHC.Types.Bool -> a -> GHC.Base.String
  fromRat :: forall a. RealFloat a => GHC.Real.Rational -> a
  fromRat' :: forall a. RealFloat a => GHC.Real.Rational -> a
  fromRat'' :: forall a. RealFloat a => GHC.Types.Int -> GHC.Types.Int -> GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> a
  geDouble :: Double -> Double -> GHC.Types.Bool
  geFloat :: Float -> Float -> GHC.Types.Bool
  gtDouble :: Double -> Double -> GHC.Types.Bool
  gtFloat :: Float -> Float -> GHC.Types.Bool
  int2Double :: GHC.Types.Int -> Double
  int2Float :: GHC.Types.Int -> Float
  integerToBinaryFloat' :: forall a. RealFloat a => GHC.Num.Integer.Integer -> a
  integerToDouble# :: GHC.Num.Integer.Integer -> Double#
  integerToFloat# :: GHC.Num.Integer.Integer -> Float#
  isDoubleDenormalized :: Double -> GHC.Types.Int
  isDoubleFinite :: Double -> GHC.Types.Int
  isDoubleInfinite :: Double -> GHC.Types.Int
  isDoubleNaN :: Double -> GHC.Types.Int
  isDoubleNegativeZero :: Double -> GHC.Types.Int
  isFloatDenormalized :: Float -> GHC.Types.Int
  isFloatFinite :: Float -> GHC.Types.Int
  isFloatInfinite :: Float -> GHC.Types.Int
  isFloatNaN :: Float -> GHC.Types.Int
  isFloatNegativeZero :: Float -> GHC.Types.Int
  leDouble :: Double -> Double -> GHC.Types.Bool
  leFloat :: Float -> Float -> GHC.Types.Bool
  log1mexpOrd :: forall a. (GHC.Classes.Ord a, Floating a) => a -> a
  log1pDouble :: Double -> Double
  log1pFloat :: Float -> Float
  logDouble :: Double -> Double
  logFloat :: Float -> Float
  ltDouble :: Double -> Double -> GHC.Types.Bool
  ltFloat :: Float -> Float -> GHC.Types.Bool
  maxExpt :: GHC.Types.Int
  maxExpt10 :: GHC.Types.Int
  minExpt :: GHC.Types.Int
  minusDouble :: Double -> Double -> Double
  minusFloat :: Float -> Float -> Float
  naturalToDouble# :: GHC.Num.Natural.Natural -> Double#
  naturalToFloat# :: GHC.Num.Natural.Natural -> Float#
  negateDouble :: Double -> Double
  negateFloat :: Float -> Float
  plusDouble :: Double -> Double -> Double
  plusFloat :: Float -> Float -> Float
  powerDouble :: Double -> Double -> Double
  powerFloat :: Float -> Float -> Float
  properFractionDouble :: forall b. GHC.Real.Integral b => Double -> (b, Double)
  properFractionFloat :: forall b. GHC.Real.Integral b => Float -> (b, Float)
  rationalToDouble :: GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> Double
  rationalToFloat :: GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> Float
  roundDouble :: forall b. GHC.Real.Integral b => Double -> b
  roundFloat :: forall b. GHC.Real.Integral b => Float -> b
  roundTo :: GHC.Types.Int -> GHC.Types.Int -> [GHC.Types.Int] -> (GHC.Types.Int, [GHC.Types.Int])
  roundingMode# :: GHC.Num.Integer.Integer -> GHC.Prim.Int# -> GHC.Prim.Int#
  showFloat :: forall a. RealFloat a => a -> GHC.Show.ShowS
  showSignedFloat :: forall a. RealFloat a => (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
  sinDouble :: Double -> Double
  sinFloat :: Float -> Float
  sinhDouble :: Double -> Double
  sinhFloat :: Float -> Float
  sqrtDouble :: Double -> Double
  sqrtFloat :: Float -> Float
  stgDoubleToWord64 :: Double# -> GHC.Prim.Word64#
  stgFloatToWord32 :: Float# -> GHC.Prim.Word32#
  stgWord32ToFloat :: GHC.Prim.Word32# -> Float#
  stgWord64ToDouble :: GHC.Prim.Word64# -> Double#
  tanDouble :: Double -> Double
  tanFloat :: Float -> Float
  tanhDouble :: Double -> Double
  tanhFloat :: Float -> Float
  timesDouble :: Double -> Double -> Double
  timesFloat :: Float -> Float -> Float
  truncateDouble :: forall b. GHC.Real.Integral b => Double -> b
  truncateFloat :: forall b. GHC.Real.Integral b => Float -> b
  word2Double :: GHC.Types.Word -> Double
  word2Float :: GHC.Types.Word -> Float

module GHC.Float.ConversionUtils where
  -- Safety: Trustworthy
  elimZerosInt# :: GHC.Prim.Int# -> GHC.Prim.Int# -> (# GHC.Num.Integer.Integer, GHC.Prim.Int# #)
  elimZerosInteger :: GHC.Num.Integer.Integer -> GHC.Prim.Int# -> (# GHC.Num.Integer.Integer, GHC.Prim.Int# #)

module GHC.Float.RealFracMethods where
  -- Safety: Trustworthy
  ceilingDoubleInt :: GHC.Types.Double -> GHC.Types.Int
  ceilingDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  ceilingFloatInt :: GHC.Types.Float -> GHC.Types.Int
  ceilingFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer
  double2Int :: GHC.Types.Double -> GHC.Types.Int
  float2Int :: GHC.Types.Float -> GHC.Types.Int
  floorDoubleInt :: GHC.Types.Double -> GHC.Types.Int
  floorDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  floorFloatInt :: GHC.Types.Float -> GHC.Types.Int
  floorFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer
  int2Double :: GHC.Types.Int -> GHC.Types.Double
  int2Float :: GHC.Types.Int -> GHC.Types.Float
  properFractionDoubleInt :: GHC.Types.Double -> (GHC.Types.Int, GHC.Types.Double)
  properFractionDoubleInteger :: GHC.Types.Double -> (GHC.Num.Integer.Integer, GHC.Types.Double)
  properFractionFloatInt :: GHC.Types.Float -> (GHC.Types.Int, GHC.Types.Float)
  properFractionFloatInteger :: GHC.Types.Float -> (GHC.Num.Integer.Integer, GHC.Types.Float)
  roundDoubleInt :: GHC.Types.Double -> GHC.Types.Int
  roundDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  roundFloatInt :: GHC.Types.Float -> GHC.Types.Int
  roundFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer
  truncateDoubleInteger :: GHC.Types.Double -> GHC.Num.Integer.Integer
  truncateFloatInteger :: GHC.Types.Float -> GHC.Num.Integer.Integer

module GHC.Foreign where
  -- Safety: Trustworthy
  type CString :: *
  type CString = GHC.Ptr.Ptr Foreign.C.Types.CChar
  type CStringLen :: *
  type CStringLen = (GHC.Ptr.Ptr Foreign.C.Types.CChar, GHC.Types.Int)
  charIsRepresentable :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Types.Char -> GHC.Types.IO GHC.Types.Bool
  newCString :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> GHC.Types.IO CString
  newCStringLen :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> GHC.Types.IO CStringLen
  newCStringLen0 :: GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> GHC.Types.IO CStringLen
  peekCString :: GHC.IO.Encoding.Types.TextEncoding -> CString -> GHC.Types.IO GHC.Base.String
  peekCStringLen :: GHC.IO.Encoding.Types.TextEncoding -> CStringLen -> GHC.Types.IO GHC.Base.String
  withCString :: forall a. GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> (CString -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen :: forall a. GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringLen0 :: forall a. GHC.IO.Encoding.Types.TextEncoding -> GHC.Base.String -> (CStringLen -> GHC.Types.IO a) -> GHC.Types.IO a
  withCStringsLen :: forall a. GHC.IO.Encoding.Types.TextEncoding -> [GHC.Base.String] -> (GHC.Types.Int -> GHC.Ptr.Ptr CString -> GHC.Types.IO a) -> GHC.Types.IO a

module GHC.ForeignPtr where
  -- Safety: Unsafe
  type FinalizerEnvPtr :: * -> * -> *
  type FinalizerEnvPtr env a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr env -> GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type FinalizerPtr :: * -> *
  type FinalizerPtr a = GHC.Ptr.FunPtr (GHC.Ptr.Ptr a -> GHC.Types.IO ())
  type Finalizers :: *
  data Finalizers = NoFinalizers | CFinalizers (GHC.Prim.Weak# ()) | HaskellFinalizers [GHC.Types.IO ()]
  type role ForeignPtr phantom
  type ForeignPtr :: * -> *
  data ForeignPtr a = ForeignPtr GHC.Prim.Addr# ForeignPtrContents
  type ForeignPtrContents :: *
  data ForeignPtrContents = PlainForeignPtr ! {-# UNPACK #-}(GHC.IORef.N:IORef[0] <Finalizers>_N)(GHC.IORef.IORef Finalizers) | FinalPtr | MallocPtr (GHC.Prim.MutableByteArray# GHC.Prim.RealWorld) ! {-# UNPACK #-}(GHC.IORef.N:IORef[0] <Finalizers>_N)(GHC.IORef.IORef Finalizers) | PlainPtr (GHC.Prim.MutableByteArray# GHC.Prim.RealWorld)
  addForeignPtrConcFinalizer :: forall a. ForeignPtr a -> GHC.Types.IO () -> GHC.Types.IO ()
  addForeignPtrFinalizer :: forall a. FinalizerPtr a -> ForeignPtr a -> GHC.Types.IO ()
  addForeignPtrFinalizerEnv :: forall env a. FinalizerEnvPtr env a -> GHC.Ptr.Ptr env -> ForeignPtr a -> GHC.Types.IO ()
  castForeignPtr :: forall a b. ForeignPtr a -> ForeignPtr b
  finalizeForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  mallocForeignPtr :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrAlignedBytes :: forall a. GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocForeignPtrBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocPlainForeignPtr :: forall a. Foreign.Storable.Storable a => GHC.Types.IO (ForeignPtr a)
  mallocPlainForeignPtrAlignedBytes :: forall a. GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  mallocPlainForeignPtrBytes :: forall a. GHC.Types.Int -> GHC.Types.IO (ForeignPtr a)
  newConcForeignPtr :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO () -> GHC.Types.IO (ForeignPtr a)
  newForeignPtr_ :: forall a. GHC.Ptr.Ptr a -> GHC.Types.IO (ForeignPtr a)
  plusForeignPtr :: forall a b. ForeignPtr a -> GHC.Types.Int -> ForeignPtr b
  touchForeignPtr :: forall a. ForeignPtr a -> GHC.Types.IO ()
  unsafeForeignPtrToPtr :: forall a. ForeignPtr a -> GHC.Ptr.Ptr a
  unsafeWithForeignPtr :: forall a b. ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b
  withForeignPtr :: forall a b. ForeignPtr a -> (GHC.Ptr.Ptr a -> GHC.Types.IO b) -> GHC.Types.IO b

module GHC.GHCi where
  -- Safety: None
  type GHCiSandboxIO :: (* -> *) -> Constraint
  class GHC.Base.Monad m => GHCiSandboxIO m where
    ghciStepIO :: forall a. m a -> GHC.Types.IO a
    {-# MINIMAL ghciStepIO #-}
  type NoIO :: * -> *
  newtype NoIO a = ...

module GHC.GHCi.Helpers where
  -- Safety: Safe-Inferred
  disableBuffering :: GHC.Types.IO ()
  evalWrapper :: forall a. GHC.Base.String -> [GHC.Base.String] -> GHC.Types.IO a -> GHC.Types.IO a
  flushAll :: GHC.Types.IO ()

module GHC.Generics where
  -- Safety: Trustworthy
  type role (:*:) representational representational nominal
  type (:*:) :: forall k. (k -> *) -> (k -> *) -> k -> *
  data (:*:) f g p = (f p) :*: (g p)
  type role (:+:) representational representational nominal
  type (:+:) :: forall k. (k -> *) -> (k -> *) -> k -> *
  data (:+:) f g p = L1 (f p) | R1 (g p)
  type role (:.:) representational nominal nominal
  type (:.:) :: forall k2 k1. (k2 -> *) -> (k1 -> k2) -> k1 -> *
  newtype (:.:) f g p = Comp1 {unComp1 :: f (g p)}
  type Associativity :: *
  data Associativity = LeftAssociative | RightAssociative | NotAssociative
  type C :: *
  data C
  type C1 :: forall {k}. Meta -> (k -> *) -> k -> *
  type C1 = M1 C :: Meta -> (k -> *) -> k -> *
  type Constructor :: forall {k}. k -> Constraint
  class Constructor c where
    conName :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t c f a -> [GHC.Types.Char]
    conFixity :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t c f a -> Fixity
    conIsRecord :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t c f a -> GHC.Types.Bool
    {-# MINIMAL conName #-}
  type D :: *
  data D
  type D1 :: forall {k}. Meta -> (k -> *) -> k -> *
  type D1 = M1 D :: Meta -> (k -> *) -> k -> *
  type Datatype :: forall {k}. k -> Constraint
  class Datatype d where
    datatypeName :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t d f a -> [GHC.Types.Char]
    moduleName :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t d f a -> [GHC.Types.Char]
    packageName :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t d f a -> [GHC.Types.Char]
    isNewtype :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t d f a -> GHC.Types.Bool
    {-# MINIMAL datatypeName, moduleName, packageName #-}
  type DecidedStrictness :: *
  data DecidedStrictness = DecidedLazy | DecidedStrict | DecidedUnpack
  type Fixity :: *
  data Fixity = Prefix | Infix Associativity GHC.Types.Int
  type FixityI :: *
  data FixityI = PrefixI | InfixI Associativity GHC.TypeNats.Nat
  type Generic :: * -> Constraint
  class Generic a where
    type Rep :: * -> * -> *
    type family Rep a
    from :: forall x. a -> Rep a x
    to :: forall x. Rep a x -> a
    {-# MINIMAL from, to #-}
  type Generic1 :: forall k. (k -> *) -> Constraint
  class Generic1 f where
    type Rep1 :: forall k. (k -> *) -> k -> *
    type family Rep1 f
    from1 :: forall (a :: k). f a -> Rep1 f a
    to1 :: forall (a :: k). Rep1 f a -> f a
    {-# MINIMAL from1, to1 #-}
  type Generically :: * -> *
  newtype Generically a = Generically a
  type role Generically1 representational nominal
  type Generically1 :: forall k. (k -> *) -> k -> *
  newtype Generically1 f a where
    Generically1 :: forall {k} (f :: k -> *) (a :: k). f a -> Generically1 f a
  type role K1 phantom representational phantom
  type K1 :: forall k. * -> * -> k -> *
  newtype K1 i c p = K1 {unK1 :: c}
  type role M1 phantom phantom representational nominal
  type M1 :: forall k. * -> Meta -> (k -> *) -> k -> *
  newtype M1 i c f p = M1 {unM1 :: f p}
  type Meta :: *
  data Meta = MetaData GHC.Types.Symbol GHC.Types.Symbol GHC.Types.Symbol GHC.Types.Bool | MetaCons GHC.Types.Symbol FixityI GHC.Types.Bool | MetaSel (GHC.Maybe.Maybe GHC.Types.Symbol) SourceUnpackedness SourceStrictness DecidedStrictness
  type Par1 :: * -> *
  newtype Par1 p = Par1 {unPar1 :: p}
  type R :: *
  data R
  type Rec0 :: forall {k}. * -> k -> *
  type Rec0 = K1 R :: * -> k -> *
  type role Rec1 representational nominal
  type Rec1 :: forall k. (k -> *) -> k -> *
  newtype Rec1 f p = Rec1 {unRec1 :: f p}
  type S :: *
  data S
  type S1 :: forall {k}. Meta -> (k -> *) -> k -> *
  type S1 = M1 S :: Meta -> (k -> *) -> k -> *
  type Selector :: forall {k}. k -> Constraint
  class Selector s where
    selName :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t s f a -> [GHC.Types.Char]
    selSourceUnpackedness :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t s f a -> SourceUnpackedness
    selSourceStrictness :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t s f a -> SourceStrictness
    selDecidedStrictness :: forall k1 (t :: k -> (k1 -> *) -> k1 -> *) (f :: k1 -> *) (a :: k1). t s f a -> DecidedStrictness
    {-# MINIMAL selName, selSourceUnpackedness, selSourceStrictness, selDecidedStrictness #-}
  type SourceStrictness :: *
  data SourceStrictness = NoSourceStrictness | SourceLazy | SourceStrict
  type SourceUnpackedness :: *
  data SourceUnpackedness = NoSourceUnpackedness | SourceNoUnpack | SourceUnpack
  type role U1 phantom
  type U1 :: forall k. k -> *
  data U1 p = U1
  UAddr :: forall k (p :: k). GHC.Prim.Addr# -> URec (GHC.Ptr.Ptr ()) p
  type UAddr :: forall {k}. k -> *
  type UAddr = URec (GHC.Ptr.Ptr ()) :: k -> *
  UChar :: forall k (p :: k). GHC.Prim.Char# -> URec GHC.Types.Char p
  type UChar :: forall {k}. k -> *
  type UChar = URec GHC.Types.Char :: k -> *
  UDouble :: forall k (p :: k). GHC.Prim.Double# -> URec GHC.Types.Double p
  type UDouble :: forall {k}. k -> *
  type UDouble = URec GHC.Types.Double :: k -> *
  UFloat :: forall k (p :: k). GHC.Prim.Float# -> URec GHC.Types.Float p
  type UFloat :: forall {k}. k -> *
  type UFloat = URec GHC.Types.Float :: k -> *
  UInt :: forall k (p :: k). GHC.Prim.Int# -> URec GHC.Types.Int p
  type UInt :: forall {k}. k -> *
  type UInt = URec GHC.Types.Int :: k -> *
  type URec :: forall k. * -> k -> *
  data family URec a p
  UWord :: forall k (p :: k). GHC.Prim.Word# -> URec GHC.Types.Word p
  type UWord :: forall {k}. k -> *
  type UWord = URec GHC.Types.Word :: k -> *
  type role V1 phantom
  type V1 :: forall k. k -> *
  data V1 p
  prec :: Fixity -> GHC.Types.Int
  uAddr# :: forall k (p :: k). URec (GHC.Ptr.Ptr ()) p -> GHC.Prim.Addr#
  uChar# :: forall k (p :: k). URec GHC.Types.Char p -> GHC.Prim.Char#
  uDouble# :: forall k (p :: k). URec GHC.Types.Double p -> GHC.Prim.Double#
  uFloat# :: forall k (p :: k). URec GHC.Types.Float p -> GHC.Prim.Float#
  uInt# :: forall k (p :: k). URec GHC.Types.Int p -> GHC.Prim.Int#
  uWord# :: forall k (p :: k). URec GHC.Types.Word p -> GHC.Prim.Word#

module GHC.IO where
  -- Safety: Unsafe
  type FilePath :: *
  type FilePath = GHC.Base.String
  type IO :: * -> *
  newtype IO a = IO (GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #))
  type MaskingState :: *
  data MaskingState = Unmasked | MaskedInterruptible | MaskedUninterruptible
  bracket :: forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
  catch :: forall e a. GHC.Exception.Type.Exception e => IO a -> (e -> IO a) -> IO a
  catchAny :: forall a. IO a -> (forall e. GHC.Exception.Type.Exception e => e -> IO a) -> IO a
  catchException :: forall e a. GHC.Exception.Type.Exception e => IO a -> (e -> IO a) -> IO a
  evaluate :: forall a. a -> IO a
  finally :: forall a b. IO a -> IO b -> IO a
  getMaskingState :: IO MaskingState
  interruptible :: forall a. IO a -> IO a
  ioToST :: forall a. IO a -> GHC.ST.ST GHC.Prim.RealWorld a
  liftIO :: forall a. IO a -> GHC.Prim.State# GHC.Prim.RealWorld -> GHC.ST.STret GHC.Prim.RealWorld a
  mask :: forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b
  mask_ :: forall a. IO a -> IO a
  mkUserError :: [GHC.Types.Char] -> GHC.Exception.Type.SomeException
  mplusIO :: forall a. IO a -> IO a -> IO a
  noDuplicate :: IO ()
  onException :: forall a b. IO a -> IO b -> IO a
  stToIO :: forall a. GHC.ST.ST GHC.Prim.RealWorld a -> IO a
  throwIO :: forall e a. GHC.Exception.Type.Exception e => e -> IO a
  unIO :: forall a. IO a -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  uninterruptibleMask :: forall b. ((forall a. IO a -> IO a) -> IO b) -> IO b
  uninterruptibleMask_ :: forall a. IO a -> IO a
  unsafeDupableInterleaveIO :: forall a. IO a -> IO a
  unsafeDupablePerformIO :: forall a. IO a -> a
  unsafeIOToST :: forall a s. IO a -> GHC.ST.ST s a
  unsafeInterleaveIO :: forall a. IO a -> IO a
  unsafePerformIO :: forall a. IO a -> a
  unsafeSTToIO :: forall s a. GHC.ST.ST s a -> IO a
  unsafeUnmask :: forall a. IO a -> IO a

module GHC.IO.Buffer where
  -- Safety: Trustworthy
  type role Buffer phantom
  type Buffer :: * -> *
  data Buffer e = Buffer {bufRaw :: {-# UNPACK #-}(RawBuffer e), bufState :: BufferState, bufSize :: {-# UNPACK #-}GHC.Types.Int, bufOffset :: {-# UNPACK #-}GHC.Word.Word64, bufL :: {-# UNPACK #-}GHC.Types.Int, bufR :: {-# UNPACK #-}GHC.Types.Int}
  type BufferState :: *
  data BufferState = ReadBuffer | WriteBuffer
  type CharBufElem :: *
  type CharBufElem = GHC.Types.Char
  type CharBuffer :: *
  type CharBuffer = Buffer GHC.Types.Char
  type RawBuffer :: * -> *
  type RawBuffer e = GHC.ForeignPtr.ForeignPtr e
  type RawCharBuffer :: *
  type RawCharBuffer = RawBuffer CharBufElem
  bufferAdd :: forall e. GHC.Types.Int -> Buffer e -> Buffer e
  bufferAddOffset :: forall e. GHC.Types.Int -> Buffer e -> Buffer e
  bufferAdjustL :: forall e. GHC.Types.Int -> Buffer e -> Buffer e
  bufferAdjustOffset :: forall e. GHC.Word.Word64 -> Buffer e -> Buffer e
  bufferAvailable :: forall e. Buffer e -> GHC.Types.Int
  bufferElems :: forall e. Buffer e -> GHC.Types.Int
  bufferOffset :: forall e. Buffer e -> GHC.Word.Word64
  bufferRemove :: forall e. GHC.Types.Int -> Buffer e -> Buffer e
  charSize :: GHC.Types.Int
  checkBuffer :: forall a. Buffer a -> GHC.Types.IO ()
  emptyBuffer :: forall e. RawBuffer e -> GHC.Types.Int -> BufferState -> Buffer e
  isEmptyBuffer :: forall e. Buffer e -> GHC.Types.Bool
  isFullBuffer :: forall e. Buffer e -> GHC.Types.Bool
  isFullCharBuffer :: forall e. Buffer e -> GHC.Types.Bool
  isWriteBuffer :: forall e. Buffer e -> GHC.Types.Bool
  newBuffer :: forall e. GHC.Types.Int -> GHC.Types.Int -> BufferState -> GHC.Types.IO (Buffer e)
  newByteBuffer :: GHC.Types.Int -> BufferState -> GHC.Types.IO (Buffer GHC.Word.Word8)
  newCharBuffer :: GHC.Types.Int -> BufferState -> GHC.Types.IO CharBuffer
  peekCharBuf :: RawCharBuffer -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Char
  readCharBuf :: RawCharBuffer -> GHC.Types.Int -> GHC.Types.IO (GHC.Types.Char, GHC.Types.Int)
  readCharBufPtr :: GHC.Ptr.Ptr CharBufElem -> GHC.Types.Int -> GHC.Types.IO (GHC.Types.Char, GHC.Types.Int)
  readWord8Buf :: RawBuffer GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word8
  slideContents :: Buffer GHC.Word.Word8 -> GHC.Types.IO (Buffer GHC.Word.Word8)
  summaryBuffer :: forall a. Buffer a -> GHC.Base.String
  withBuffer :: forall e a. Buffer e -> (GHC.Ptr.Ptr e -> GHC.Types.IO a) -> GHC.Types.IO a
  withRawBuffer :: forall e a. RawBuffer e -> (GHC.Ptr.Ptr e -> GHC.Types.IO a) -> GHC.Types.IO a
  writeCharBuf :: RawCharBuffer -> GHC.Types.Int -> GHC.Types.Char -> GHC.Types.IO GHC.Types.Int
  writeCharBufPtr :: GHC.Ptr.Ptr CharBufElem -> GHC.Types.Int -> GHC.Types.Char -> GHC.Types.IO GHC.Types.Int
  writeWord8Buf :: RawBuffer GHC.Word.Word8 -> GHC.Types.Int -> GHC.Word.Word8 -> GHC.Types.IO ()

module GHC.IO.BufferedIO where
  -- Safety: Trustworthy
  type BufferedIO :: * -> Constraint
  class BufferedIO dev where
    newBuffer :: dev -> GHC.IO.Buffer.BufferState -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
    fillReadBuffer :: dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
    fillReadBuffer0 :: dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
    emptyWriteBuffer :: dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
    flushWriteBuffer :: dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
    flushWriteBuffer0 :: dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
    {-# MINIMAL newBuffer, fillReadBuffer, fillReadBuffer0, flushWriteBuffer, flushWriteBuffer0 #-}
  readBuf :: forall dev. GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  readBufNonBlocking :: forall dev. GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  writeBuf :: forall dev. GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8)
  writeBufNonBlocking :: forall dev. GHC.IO.Device.RawIO dev => dev -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.Types.Int, GHC.IO.Buffer.Buffer GHC.Word.Word8)

module GHC.IO.Device where
  -- Safety: Trustworthy
  type IODevice :: * -> Constraint
  class IODevice a where
    ready :: a -> GHC.Types.Bool -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Bool
    close :: a -> GHC.Types.IO ()
    isTerminal :: a -> GHC.Types.IO GHC.Types.Bool
    isSeekable :: a -> GHC.Types.IO GHC.Types.Bool
    seek :: a -> SeekMode -> GHC.Num.Integer.Integer -> GHC.Types.IO GHC.Num.Integer.Integer
    tell :: a -> GHC.Types.IO GHC.Num.Integer.Integer
    getSize :: a -> GHC.Types.IO GHC.Num.Integer.Integer
    setSize :: a -> GHC.Num.Integer.Integer -> GHC.Types.IO ()
    setEcho :: a -> GHC.Types.Bool -> GHC.Types.IO ()
    getEcho :: a -> GHC.Types.IO GHC.Types.Bool
    setRaw :: a -> GHC.Types.Bool -> GHC.Types.IO ()
    devType :: a -> GHC.Types.IO IODeviceType
    dup :: a -> GHC.Types.IO a
    dup2 :: a -> a -> GHC.Types.IO a
    {-# MINIMAL ready, close, devType #-}
  type IODeviceType :: *
  data IODeviceType = Directory | Stream | RegularFile | RawDevice
  type RawIO :: * -> Constraint
  class RawIO a where
    read :: a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
    readNonBlocking :: a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Types.Int)
    write :: a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO ()
    writeNonBlocking :: a -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
    {-# MINIMAL read, readNonBlocking, write, writeNonBlocking #-}
  type SeekMode :: *
  data SeekMode = AbsoluteSeek | RelativeSeek | SeekFromEnd

module GHC.IO.Encoding where
  -- Safety: Trustworthy
  pattern BufferCodec :: forall from to state. GHC.IO.Encoding.Types.CodeBuffer from to -> (GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)) -> GHC.Types.IO () -> GHC.Types.IO state -> (state -> GHC.Types.IO ()) -> BufferCodec from to state
  pattern BufferCodec {encode, recover, close, getState, setState}
  type role BufferCodec phantom phantom representational
  type BufferCodec :: * -> * -> * -> *
  data BufferCodec from to state = BufferCodec# {encode# :: GHC.IO.Encoding.Types.CodeBuffer# from to, recover# :: GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to #), close# :: GHC.Types.IO (), getState# :: GHC.Types.IO state, setState# :: state -> GHC.Types.IO ()}
  type CodingProgress :: *
  data CodingProgress = InputUnderflow | OutputUnderflow | InvalidSequence
  type TextDecoder :: * -> *
  type TextDecoder state = BufferCodec GHC.Word.Word8 GHC.IO.Buffer.CharBufElem state
  type TextEncoder :: * -> *
  type TextEncoder state = BufferCodec GHC.IO.Buffer.CharBufElem GHC.Word.Word8 state
  type TextEncoding :: *
  data TextEncoding = forall dstate estate. TextEncoding {textEncodingName :: GHC.Base.String, mkTextDecoder :: GHC.Types.IO (TextDecoder dstate), mkTextEncoder :: GHC.Types.IO (TextEncoder estate)}
  argvEncoding :: GHC.Types.IO TextEncoding
  char8 :: TextEncoding
  getFileSystemEncoding :: GHC.Types.IO TextEncoding
  getForeignEncoding :: GHC.Types.IO TextEncoding
  getLocaleEncoding :: GHC.Types.IO TextEncoding
  initLocaleEncoding :: TextEncoding
  latin1 :: TextEncoding
  latin1_decode :: GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8, GHC.IO.Buffer.CharBuffer)
  latin1_encode :: GHC.IO.Buffer.CharBuffer -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.CharBuffer, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  mkTextEncoding :: GHC.Base.String -> GHC.Types.IO TextEncoding
  setFileSystemEncoding :: TextEncoding -> GHC.Types.IO ()
  setForeignEncoding :: TextEncoding -> GHC.Types.IO ()
  setLocaleEncoding :: TextEncoding -> GHC.Types.IO ()
  utf16 :: TextEncoding
  utf16be :: TextEncoding
  utf16le :: TextEncoding
  utf32 :: TextEncoding
  utf32be :: TextEncoding
  utf32le :: TextEncoding
  utf8 :: TextEncoding
  utf8_bom :: TextEncoding

module GHC.IO.Encoding.CodePage where
  -- Safety: Trustworthy

module GHC.IO.Encoding.Failure where
  -- Safety: Trustworthy
  type CodingFailureMode :: *
  data CodingFailureMode = ErrorOnCodingFailure | IgnoreCodingFailure | TransliterateCodingFailure | RoundtripFailure
  codingFailureModeSuffix :: CodingFailureMode -> GHC.Base.String
  isSurrogate :: GHC.Types.Char -> GHC.Types.Bool
  recoverDecode :: CodingFailureMode -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.IO.Buffer.Buffer GHC.Types.Char -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Word.Word8, GHC.IO.Buffer.Buffer GHC.Types.Char)
  recoverDecode# :: CodingFailureMode -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.IO.Buffer.Buffer GHC.Types.Char -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.IO.Buffer.Buffer GHC.Word.Word8, GHC.IO.Buffer.Buffer GHC.Types.Char #)
  recoverEncode :: CodingFailureMode -> GHC.IO.Buffer.Buffer GHC.Types.Char -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Types.IO (GHC.IO.Buffer.Buffer GHC.Types.Char, GHC.IO.Buffer.Buffer GHC.Word.Word8)
  recoverEncode# :: CodingFailureMode -> GHC.IO.Buffer.Buffer GHC.Types.Char -> GHC.IO.Buffer.Buffer GHC.Word.Word8 -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.IO.Buffer.Buffer GHC.Types.Char, GHC.IO.Buffer.Buffer GHC.Word.Word8 #)

module GHC.IO.Encoding.Iconv where
  -- Safety: Trustworthy
  iconvEncoding :: GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding)
  localeEncodingName :: GHC.Base.String
  mkIconvEncoding :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding)

module GHC.IO.Encoding.Latin1 where
  -- Safety: Trustworthy
  ascii :: GHC.IO.Encoding.Types.TextEncoding
  ascii_decode :: GHC.IO.Encoding.Types.DecodeBuffer#
  ascii_encode :: GHC.IO.Encoding.Types.EncodeBuffer#
  latin1 :: GHC.IO.Encoding.Types.TextEncoding
  latin1_checked :: GHC.IO.Encoding.Types.TextEncoding
  latin1_checked_encode :: GHC.IO.Encoding.Types.EncodeBuffer#
  latin1_decode :: GHC.IO.Encoding.Types.DecodeBuffer#
  latin1_encode :: GHC.IO.Encoding.Types.EncodeBuffer#
  mkAscii :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkLatin1 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkLatin1_checked :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding

module GHC.IO.Encoding.Types where
  -- Safety: Trustworthy
  pattern BufferCodec :: forall from to state. CodeBuffer from to -> (GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)) -> GHC.Types.IO () -> GHC.Types.IO state -> (state -> GHC.Types.IO ()) -> BufferCodec from to state
  pattern BufferCodec {encode, recover, close, getState, setState}
  type role BufferCodec phantom phantom representational
  type BufferCodec :: * -> * -> * -> *
  data BufferCodec from to state = BufferCodec# {encode# :: GHC.IO.Encoding.Types.CodeBuffer# from to, recover# :: GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to #), close# :: GHC.Types.IO (), getState# :: GHC.Types.IO state, setState# :: state -> GHC.Types.IO ()}
  type CodeBuffer :: * -> * -> *
  type CodeBuffer from to = GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (CodingProgress, GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)
  type CodingProgress :: *
  data CodingProgress = InputUnderflow | OutputUnderflow | InvalidSequence
  type DecodeBuffer :: *
  type DecodeBuffer = CodeBuffer GHC.Word.Word8 GHC.Types.Char
  type DecodeBuffer# :: *
  type DecodeBuffer# = GHC.IO.Encoding.Types.CodeBuffer# GHC.Word.Word8 GHC.Types.Char
  type DecodingBuffer# :: *
  type DecodingBuffer# = GHC.IO.Encoding.Types.CodingBuffer# GHC.Word.Word8 GHC.Types.Char
  type EncodeBuffer :: *
  type EncodeBuffer = CodeBuffer GHC.Types.Char GHC.Word.Word8
  type EncodeBuffer# :: *
  type EncodeBuffer# = GHC.IO.Encoding.Types.CodeBuffer# GHC.Types.Char GHC.Word.Word8
  type EncodingBuffer# :: *
  type EncodingBuffer# = GHC.IO.Encoding.Types.CodingBuffer# GHC.Types.Char GHC.Word.Word8
  type TextDecoder :: * -> *
  type TextDecoder state = BufferCodec GHC.Word.Word8 GHC.IO.Buffer.CharBufElem state
  type TextEncoder :: * -> *
  type TextEncoder state = BufferCodec GHC.IO.Buffer.CharBufElem GHC.Word.Word8 state
  type TextEncoding :: *
  data TextEncoding = forall dstate estate. TextEncoding {textEncodingName :: GHC.Base.String, mkTextDecoder :: GHC.Types.IO (TextDecoder dstate), mkTextEncoder :: GHC.Types.IO (TextEncoder estate)}

module GHC.IO.Encoding.UTF16 where
  -- Safety: Trustworthy
  mkUTF16 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF16be :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF16le :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  utf16 :: GHC.IO.Encoding.Types.TextEncoding
  utf16_decode :: GHC.IORef.IORef (GHC.Maybe.Maybe GHC.IO.Encoding.Types.DecodeBuffer#) -> GHC.IO.Encoding.Types.DecodeBuffer#
  utf16_encode :: GHC.IORef.IORef GHC.Types.Bool -> GHC.IO.Encoding.Types.EncodeBuffer#
  utf16be :: GHC.IO.Encoding.Types.TextEncoding
  utf16be_decode :: GHC.IO.Encoding.Types.DecodeBuffer#
  utf16be_encode :: GHC.IO.Encoding.Types.EncodeBuffer#
  utf16le :: GHC.IO.Encoding.Types.TextEncoding
  utf16le_decode :: GHC.IO.Encoding.Types.DecodeBuffer#
  utf16le_encode :: GHC.IO.Encoding.Types.EncodeBuffer#

module GHC.IO.Encoding.UTF32 where
  -- Safety: Trustworthy
  mkUTF32 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF32be :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF32le :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  utf32 :: GHC.IO.Encoding.Types.TextEncoding
  utf32_decode :: GHC.IORef.IORef (GHC.Maybe.Maybe GHC.IO.Encoding.Types.DecodeBuffer#) -> GHC.IO.Encoding.Types.DecodeBuffer#
  utf32_encode :: GHC.IORef.IORef GHC.Types.Bool -> GHC.IO.Encoding.Types.EncodeBuffer#
  utf32be :: GHC.IO.Encoding.Types.TextEncoding
  utf32be_decode :: GHC.IO.Encoding.Types.DecodeBuffer#
  utf32be_encode :: GHC.IO.Encoding.Types.EncodeBuffer#
  utf32le :: GHC.IO.Encoding.Types.TextEncoding
  utf32le_decode :: GHC.IO.Encoding.Types.DecodeBuffer#
  utf32le_encode :: GHC.IO.Encoding.Types.EncodeBuffer#

module GHC.IO.Encoding.UTF8 where
  -- Safety: Trustworthy
  mkUTF8 :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  mkUTF8_bom :: GHC.IO.Encoding.Failure.CodingFailureMode -> GHC.IO.Encoding.Types.TextEncoding
  utf8 :: GHC.IO.Encoding.Types.TextEncoding
  utf8_bom :: GHC.IO.Encoding.Types.TextEncoding

module GHC.IO.Exception where
  -- Safety: Trustworthy
  type AllocationLimitExceeded :: *
  data AllocationLimitExceeded = AllocationLimitExceeded
  type ArrayException :: *
  data ArrayException = IndexOutOfBounds GHC.Base.String | UndefinedElement GHC.Base.String
  type AssertionFailed :: *
  newtype AssertionFailed = AssertionFailed GHC.Base.String
  type AsyncException :: *
  data AsyncException = StackOverflow | HeapOverflow | ThreadKilled | UserInterrupt
  type BlockedIndefinitelyOnMVar :: *
  data BlockedIndefinitelyOnMVar = BlockedIndefinitelyOnMVar
  type BlockedIndefinitelyOnSTM :: *
  data BlockedIndefinitelyOnSTM = BlockedIndefinitelyOnSTM
  type CompactionFailed :: *
  newtype CompactionFailed = CompactionFailed GHC.Base.String
  type Deadlock :: *
  data Deadlock = Deadlock
  type ExitCode :: *
  data ExitCode = ExitSuccess | ExitFailure GHC.Types.Int
  type FixIOException :: *
  data FixIOException = FixIOException
  type IOError :: *
  type IOError = IOException
  type IOErrorType :: *
  data IOErrorType = AlreadyExists | NoSuchThing | ResourceBusy | ResourceExhausted | EOF | IllegalOperation | PermissionDenied | UserError | UnsatisfiedConstraints | SystemError | ProtocolError | OtherError | InvalidArgument | InappropriateType | HardwareFault | UnsupportedOperation | TimeExpired | ResourceVanished | Interrupted
  type IOException :: *
  data IOException = IOError {ioe_handle :: GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle, ioe_type :: IOErrorType, ioe_location :: GHC.Base.String, ioe_description :: GHC.Base.String, ioe_errno :: GHC.Maybe.Maybe Foreign.C.Types.CInt, ioe_filename :: GHC.Maybe.Maybe GHC.IO.FilePath}
  type SomeAsyncException :: *
  data SomeAsyncException = forall e. GHC.Exception.Type.Exception e => SomeAsyncException e
  allocationLimitExceeded :: GHC.Exception.Type.SomeException
  assertError :: forall a. (?callStack::GHC.Stack.Types.CallStack) => GHC.Types.Bool -> a -> a
  asyncExceptionFromException :: forall e. GHC.Exception.Type.Exception e => GHC.Exception.Type.SomeException -> GHC.Maybe.Maybe e
  asyncExceptionToException :: forall e. GHC.Exception.Type.Exception e => e -> GHC.Exception.Type.SomeException
  blockedIndefinitelyOnMVar :: GHC.Exception.Type.SomeException
  blockedIndefinitelyOnSTM :: GHC.Exception.Type.SomeException
  cannotCompactFunction :: GHC.Exception.Type.SomeException
  cannotCompactMutable :: GHC.Exception.Type.SomeException
  cannotCompactPinned :: GHC.Exception.Type.SomeException
  heapOverflow :: GHC.Exception.Type.SomeException
  ioError :: forall a. IOError -> GHC.Types.IO a
  ioException :: forall a. IOException -> GHC.Types.IO a
  stackOverflow :: GHC.Exception.Type.SomeException
  unsupportedOperation :: IOError
  untangle :: GHC.Prim.Addr# -> GHC.Base.String -> GHC.Base.String
  userError :: GHC.Base.String -> IOError

module GHC.IO.FD where
  -- Safety: Trustworthy
  type FD :: *
  data FD = FD {fdFD :: ! {-# UNPACK #-}(Foreign.C.Types.N:CInt[0])Foreign.C.Types.CInt, fdIsNonBlocking :: {-# UNPACK #-}GHC.Types.Int}
  mkFD :: Foreign.C.Types.CInt -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe (GHC.IO.Device.IODeviceType, System.Posix.Types.CDev, System.Posix.Types.CIno) -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.IO (FD, GHC.IO.Device.IODeviceType)
  openFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> GHC.Types.IO (FD, GHC.IO.Device.IODeviceType)
  openFileWith :: forall r s. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> (FD -> GHC.IO.Device.IODeviceType -> GHC.Types.IO r) -> ((forall x. GHC.Types.IO x -> GHC.Types.IO x) -> r -> GHC.Types.IO s) -> GHC.Types.IO s
  readRawBufferPtr :: GHC.Base.String -> FD -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> Foreign.C.Types.CSize -> GHC.Types.IO GHC.Types.Int
  readRawBufferPtrNoBlock :: GHC.Base.String -> FD -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> Foreign.C.Types.CSize -> GHC.Types.IO GHC.Types.Int
  release :: FD -> GHC.Types.IO ()
  setNonBlockingMode :: FD -> GHC.Types.Bool -> GHC.Types.IO FD
  stderr :: FD
  stdin :: FD
  stdout :: FD
  writeRawBufferPtr :: GHC.Base.String -> FD -> GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> Foreign.C.Types.CSize -> GHC.Types.IO Foreign.C.Types.CInt

module GHC.IO.Handle where
  -- Safety: Trustworthy
  type BufferMode :: *
  data BufferMode = NoBuffering | LineBuffering | BlockBuffering (GHC.Maybe.Maybe GHC.Types.Int)
  type Handle :: *
  data Handle = ...
  type HandlePosition :: *
  type HandlePosition = GHC.Num.Integer.Integer
  type HandlePosn :: *
  data HandlePosn = HandlePosn Handle HandlePosition
  type LockMode :: *
  data LockMode = SharedLock | ExclusiveLock
  type Newline :: *
  data Newline = LF | CRLF
  type NewlineMode :: *
  data NewlineMode = NewlineMode {inputNL :: Newline, outputNL :: Newline}
  type SeekMode :: *
  data SeekMode = AbsoluteSeek | RelativeSeek | SeekFromEnd
  hClose :: Handle -> GHC.Types.IO ()
  hClose_help :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, GHC.Maybe.Maybe GHC.Exception.Type.SomeException)
  hDuplicate :: Handle -> GHC.Types.IO Handle
  hDuplicateTo :: Handle -> Handle -> GHC.Types.IO ()
  hFileSize :: Handle -> GHC.Types.IO GHC.Num.Integer.Integer
  hFlush :: Handle -> GHC.Types.IO ()
  hFlushAll :: Handle -> GHC.Types.IO ()
  hGetBuf :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBufNonBlocking :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBuffering :: Handle -> GHC.Types.IO BufferMode
  hGetChar :: Handle -> GHC.Types.IO GHC.Types.Char
  hGetContents :: Handle -> GHC.Types.IO GHC.Base.String
  hGetContents' :: Handle -> GHC.Types.IO GHC.Base.String
  hGetEcho :: Handle -> GHC.Types.IO GHC.Types.Bool
  hGetEncoding :: Handle -> GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding)
  hGetLine :: Handle -> GHC.Types.IO GHC.Base.String
  hGetPosn :: Handle -> GHC.Types.IO HandlePosn
  hIsClosed :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsEOF :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsOpen :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsReadable :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsSeekable :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsTerminalDevice :: Handle -> GHC.Types.IO GHC.Types.Bool
  hIsWritable :: Handle -> GHC.Types.IO GHC.Types.Bool
  hLock :: Handle -> LockMode -> GHC.Types.IO ()
  hLookAhead :: Handle -> GHC.Types.IO GHC.Types.Char
  hPutBuf :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  hPutBufNonBlocking :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hPutChar :: Handle -> GHC.Types.Char -> GHC.Types.IO ()
  hPutStr :: Handle -> GHC.Base.String -> GHC.Types.IO ()
  hSeek :: Handle -> SeekMode -> GHC.Num.Integer.Integer -> GHC.Types.IO ()
  hSetBinaryMode :: Handle -> GHC.Types.Bool -> GHC.Types.IO ()
  hSetBuffering :: Handle -> BufferMode -> GHC.Types.IO ()
  hSetEcho :: Handle -> GHC.Types.Bool -> GHC.Types.IO ()
  hSetEncoding :: Handle -> GHC.IO.Encoding.Types.TextEncoding -> GHC.Types.IO ()
  hSetFileSize :: Handle -> GHC.Num.Integer.Integer -> GHC.Types.IO ()
  hSetNewlineMode :: Handle -> NewlineMode -> GHC.Types.IO ()
  hSetPosn :: HandlePosn -> GHC.Types.IO ()
  hShow :: Handle -> GHC.Types.IO GHC.Base.String
  hTell :: Handle -> GHC.Types.IO GHC.Num.Integer.Integer
  hTryLock :: Handle -> LockMode -> GHC.Types.IO GHC.Types.Bool
  hWaitForInput :: Handle -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Bool
  isEOF :: GHC.Types.IO GHC.Types.Bool
  mkDuplexHandle :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> NewlineMode -> GHC.Types.IO Handle
  mkFileHandle :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> NewlineMode -> GHC.Types.IO Handle
  nativeNewline :: Newline
  nativeNewlineMode :: NewlineMode
  noNewlineTranslation :: NewlineMode
  universalNewlineMode :: NewlineMode

module GHC.IO.Handle.FD where
  -- Safety: Trustworthy
  fdToHandle :: System.Posix.Internals.FD -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  fdToHandle' :: Foreign.C.Types.CInt -> GHC.Maybe.Maybe GHC.IO.Device.IODeviceType -> GHC.Types.Bool -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  handleToFd :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.IO.FD.FD
  mkHandleFromFD :: GHC.IO.FD.FD -> GHC.IO.Device.IODeviceType -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.Bool -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openBinaryFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFileBlocking :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  stderr :: GHC.IO.Handle.Types.Handle
  stdin :: GHC.IO.Handle.Types.Handle
  stdout :: GHC.IO.Handle.Types.Handle
  withBinaryFile :: forall r. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFile :: forall r. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFileBlocking :: forall r. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r

module GHC.IO.Handle.Internals where
  -- Safety: Trustworthy
  type HandleFinalizer :: *
  type HandleFinalizer = GHC.IO.FilePath -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  addHandleFinalizer :: GHC.IO.Handle.Types.Handle -> HandleFinalizer -> GHC.Types.IO ()
  augmentIOError :: GHC.IO.Exception.IOException -> GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.IO.Exception.IOException
  closeTextCodecs :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  dEFAULT_CHAR_BUFFER_SIZE :: GHC.Types.Int
  debugIO :: GHC.Base.String -> GHC.Types.IO ()
  decodeByteBuf :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  flushBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushByteReadBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushByteWriteBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushCharBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushCharReadBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  flushWriteBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  hClose_help :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, GHC.Maybe.Maybe GHC.Exception.Type.SomeException)
  hClose_impl :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO ()
  hLookAhead_ :: GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.Types.Char
  handleFinalizer :: GHC.IO.FilePath -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO ()
  initBufferState :: GHC.IO.Handle.Types.HandleType -> GHC.IO.Buffer.BufferState
  ioe_EOF :: forall a. GHC.Types.IO a
  ioe_bufsiz :: forall a. GHC.Types.Int -> GHC.Types.IO a
  ioe_closedHandle :: forall a. GHC.Types.IO a
  ioe_finalizedHandle :: GHC.IO.FilePath -> GHC.IO.Handle.Types.Handle__
  ioe_notReadable :: forall a. GHC.Types.IO a
  ioe_notWritable :: forall a. GHC.Types.IO a
  ioe_semiclosedHandle :: forall a. GHC.Types.IO a
  mkDuplexHandle :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkDuplexHandleNoFinalizer :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkFileHandle :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkFileHandleNoFinalizer :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  mkHandle :: forall dev. (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) => dev -> GHC.IO.FilePath -> GHC.IO.Handle.Types.HandleType -> GHC.Types.Bool -> GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.NewlineMode -> GHC.Maybe.Maybe HandleFinalizer -> GHC.Maybe.Maybe (GHC.MVar.MVar GHC.IO.Handle.Types.Handle__) -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openTextEncoding :: forall a. GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding -> GHC.IO.Handle.Types.HandleType -> (forall es ds. GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextEncoder es) -> GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextDecoder ds) -> GHC.Types.IO a) -> GHC.Types.IO a
  readTextDevice :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  readTextDeviceNonBlocking :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  traceIO :: GHC.Base.String -> GHC.Types.IO ()
  wantReadableHandle :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, a)) -> GHC.Types.IO a
  wantReadableHandle_ :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  wantSeekableHandle :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  wantWritableHandle :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  withAllHandles__ :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.IO.Handle.Types.Handle__) -> GHC.Types.IO ()
  withHandle :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, a)) -> GHC.Types.IO a
  withHandle' :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO (GHC.IO.Handle.Types.Handle__, a)) -> GHC.Types.IO a
  withHandle_ :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  withHandle_' :: forall a. GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO a) -> GHC.Types.IO a
  withHandle__' :: GHC.Base.String -> GHC.IO.Handle.Types.Handle -> GHC.MVar.MVar GHC.IO.Handle.Types.Handle__ -> (GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.IO.Handle.Types.Handle__) -> GHC.Types.IO ()
  writeCharBuffer :: GHC.IO.Handle.Types.Handle__ -> GHC.IO.Buffer.CharBuffer -> GHC.Types.IO ()

module GHC.IO.Handle.Lock where
  -- Safety: None
  type FileLockingNotSupported :: *
  data FileLockingNotSupported = FileLockingNotSupported
  type LockMode :: *
  data LockMode = SharedLock | ExclusiveLock
  hLock :: GHC.IO.Handle.Types.Handle -> LockMode -> GHC.Types.IO ()
  hTryLock :: GHC.IO.Handle.Types.Handle -> LockMode -> GHC.Types.IO GHC.Types.Bool
  hUnlock :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO ()

module GHC.IO.Handle.Text where
  -- Safety: Trustworthy
  commitBuffer' :: GHC.IO.Buffer.RawCharBuffer -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool -> GHC.Types.Bool -> GHC.IO.Handle.Types.Handle__ -> GHC.Types.IO GHC.IO.Buffer.CharBuffer
  hGetBuf :: forall a. GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBufNonBlocking :: forall a. GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetBufSome :: forall a. GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hGetChar :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Types.Char
  hGetContents :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Base.String
  hGetContents' :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Base.String
  hGetLine :: GHC.IO.Handle.Types.Handle -> GHC.Types.IO GHC.Base.String
  hPutBuf :: forall a. GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO ()
  hPutBufNonBlocking :: forall a. GHC.IO.Handle.Types.Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  hPutChar :: GHC.IO.Handle.Types.Handle -> GHC.Types.Char -> GHC.Types.IO ()
  hPutStr :: GHC.IO.Handle.Types.Handle -> GHC.Base.String -> GHC.Types.IO ()
  hPutStrLn :: GHC.IO.Handle.Types.Handle -> GHC.Base.String -> GHC.Types.IO ()
  hWaitForInput :: GHC.IO.Handle.Types.Handle -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Bool
  memcpy :: forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Foreign.C.Types.CSize -> GHC.Types.IO (GHC.Ptr.Ptr ())

module GHC.IO.Handle.Types where
  -- Safety: Trustworthy
  pattern BufferCodec :: forall from to state. GHC.IO.Encoding.Types.CodeBuffer from to -> (GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Types.IO (GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to)) -> GHC.Types.IO () -> GHC.Types.IO state -> (state -> GHC.Types.IO ()) -> BufferCodec from to state
  pattern BufferCodec {encode, recover, close, getState, setState}
  type role BufferCodec phantom phantom representational
  type BufferCodec :: * -> * -> * -> *
  data BufferCodec from to state = BufferCodec# {encode# :: GHC.IO.Encoding.Types.CodeBuffer# from to, recover# :: GHC.IO.Buffer.Buffer from -> GHC.IO.Buffer.Buffer to -> GHC.Prim.State# GHC.Prim.RealWorld -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.IO.Buffer.Buffer from, GHC.IO.Buffer.Buffer to #), close# :: GHC.Types.IO (), getState# :: GHC.Types.IO state, setState# :: state -> GHC.Types.IO ()}
  type role BufferList phantom
  type BufferList :: * -> *
  data BufferList e = BufferListNil | BufferListCons (GHC.IO.Buffer.RawBuffer e) (BufferList e)
  type BufferMode :: *
  data BufferMode = NoBuffering | LineBuffering | BlockBuffering (GHC.Maybe.Maybe GHC.Types.Int)
  type Handle :: *
  data Handle = FileHandle GHC.IO.FilePath {-# UNPACK #-}(GHC.MVar.MVar Handle__) | DuplexHandle GHC.IO.FilePath {-# UNPACK #-}(GHC.MVar.MVar Handle__) {-# UNPACK #-}(GHC.MVar.MVar Handle__)
  type HandleType :: *
  data HandleType = ClosedHandle | SemiClosedHandle | ReadHandle | WriteHandle | AppendHandle | ReadWriteHandle
  type Handle__ :: *
  data Handle__
    = forall dev enc_state dec_state.
      (GHC.IO.Device.RawIO dev, GHC.IO.Device.IODevice dev, GHC.IO.BufferedIO.BufferedIO dev, base-4.18.0.0:Data.Typeable.Internal.Typeable dev) =>
      Handle__ {haDevice :: !dev,
                haType :: HandleType,
                haByteBuffer :: ! {-# UNPACK #-}(GHC.IORef.N:IORef[0] <GHC.IO.Buffer.Buffer GHC.Word.Word8>_N)(GHC.IORef.IORef (GHC.IO.Buffer.Buffer GHC.Word.Word8)),
                haBufferMode :: BufferMode,
                haLastDecode :: ! {-# UNPACK #-}(GHC.IORef.N:IORef[0] <(dec_state, GHC.IO.Buffer.Buffer GHC.Word.Word8)>_N)(GHC.IORef.IORef (dec_state, GHC.IO.Buffer.Buffer GHC.Word.Word8)),
                haCharBuffer :: ! {-# UNPACK #-}(GHC.IORef.N:IORef[0] <GHC.IO.Buffer.Buffer GHC.IO.Buffer.CharBufElem>_N)(GHC.IORef.IORef (GHC.IO.Buffer.Buffer GHC.IO.Buffer.CharBufElem)),
                haBuffers :: ! {-# UNPACK #-}(GHC.IORef.N:IORef[0] <BufferList GHC.IO.Buffer.CharBufElem>_N)(GHC.IORef.IORef (BufferList GHC.IO.Buffer.CharBufElem)),
                haEncoder :: GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextEncoder enc_state),
                haDecoder :: GHC.Maybe.Maybe (GHC.IO.Encoding.Types.TextDecoder dec_state),
                haCodec :: GHC.Maybe.Maybe GHC.IO.Encoding.Types.TextEncoding,
                haInputNL :: Newline,
                haOutputNL :: Newline,
                haOtherSide :: GHC.Maybe.Maybe (GHC.MVar.MVar Handle__)}
  type Newline :: *
  data Newline = LF | CRLF
  type NewlineMode :: *
  data NewlineMode = NewlineMode {inputNL :: Newline, outputNL :: Newline}
  checkHandleInvariants :: Handle__ -> GHC.Types.IO ()
  isAppendHandleType :: HandleType -> GHC.Types.Bool
  isReadWriteHandleType :: HandleType -> GHC.Types.Bool
  isReadableHandleType :: HandleType -> GHC.Types.Bool
  isWritableHandleType :: HandleType -> GHC.Types.Bool
  nativeNewline :: Newline
  nativeNewlineMode :: NewlineMode
  noNewlineTranslation :: NewlineMode
  showHandle :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Base.String
  universalNewlineMode :: NewlineMode

module GHC.IO.IOMode where
  -- Safety: Trustworthy
  type IOMode :: *
  data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode

module GHC.IO.StdHandles where
  -- Safety: Trustworthy
  openBinaryFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFile :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  openFileBlocking :: GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> GHC.Types.IO GHC.IO.Handle.Types.Handle
  stderr :: GHC.IO.Handle.Types.Handle
  stdin :: GHC.IO.Handle.Types.Handle
  stdout :: GHC.IO.Handle.Types.Handle
  withBinaryFile :: forall r. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFile :: forall r. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r
  withFileBlocking :: forall r. GHC.IO.FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> GHC.Types.IO r) -> GHC.Types.IO r

module GHC.IO.SubSystem where
  -- Safety: Trustworthy
  (<!>) :: forall a. a -> a -> a
  type IoSubSystem :: *
  data IoSubSystem = IoPOSIX | IoNative
  conditional :: forall a. a -> a -> a
  ioSubSystem :: IoSubSystem
  isWindowsNativeIO :: GHC.Types.Bool
  whenIoSubSystem :: IoSubSystem -> GHC.Types.IO () -> GHC.Types.IO ()
  withIoSubSystem :: forall a. (IoSubSystem -> GHC.Types.IO a) -> GHC.Types.IO a
  withIoSubSystem' :: forall a. (IoSubSystem -> a) -> a

module GHC.IO.Unsafe where
  -- Safety: Unsafe
  noDuplicate :: GHC.Types.IO ()
  unsafeDupableInterleaveIO :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  unsafeDupablePerformIO :: forall a. GHC.Types.IO a -> a
  unsafeInterleaveIO :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  unsafePerformIO :: forall a. GHC.Types.IO a -> a

module GHC.IOArray where
  -- Safety: Unsafe
  type role IOArray nominal representational
  type IOArray :: * -> * -> *
  newtype IOArray i e = IOArray (GHC.Arr.STArray GHC.Prim.RealWorld i e)
  boundsIOArray :: forall i e. IOArray i e -> (i, i)
  newIOArray :: forall i e. GHC.Ix.Ix i => (i, i) -> e -> GHC.Types.IO (IOArray i e)
  readIOArray :: forall i e. GHC.Ix.Ix i => IOArray i e -> i -> GHC.Types.IO e
  unsafeReadIOArray :: forall i e. IOArray i e -> GHC.Types.Int -> GHC.Types.IO e
  unsafeWriteIOArray :: forall i e. IOArray i e -> GHC.Types.Int -> e -> GHC.Types.IO ()
  writeIOArray :: forall i e. GHC.Ix.Ix i => IOArray i e -> i -> e -> GHC.Types.IO ()

module GHC.IOPort where
  -- Safety: Unsafe
  type IOPort :: * -> *
  data IOPort a = IOPort (GHC.Prim.IOPort# GHC.Prim.RealWorld a)
  doubleReadException :: GHC.Exception.Type.SomeException
  newEmptyIOPort :: forall a. GHC.Types.IO (IOPort a)
  newIOPort :: forall a. a -> GHC.Types.IO (IOPort a)
  readIOPort :: forall a. IOPort a -> GHC.Types.IO a
  writeIOPort :: forall a. IOPort a -> a -> GHC.Types.IO GHC.Types.Bool

module GHC.IORef where
  -- Safety: Unsafe
  type IORef :: * -> *
  newtype IORef a = IORef (GHC.STRef.STRef GHC.Prim.RealWorld a)
  atomicModifyIORef' :: forall a b. IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicModifyIORef'_ :: forall a. IORef a -> (a -> a) -> GHC.Types.IO (a, a)
  atomicModifyIORef2 :: forall a b. IORef a -> (a -> (a, b)) -> GHC.Types.IO (a, (a, b))
  atomicModifyIORef2Lazy :: forall a b. IORef a -> (a -> (a, b)) -> GHC.Types.IO (a, (a, b))
  atomicModifyIORefLazy_ :: forall a. IORef a -> (a -> a) -> GHC.Types.IO (a, a)
  atomicModifyIORefP :: forall a b. IORef a -> (a -> (a, b)) -> GHC.Types.IO b
  atomicSwapIORef :: forall a. IORef a -> a -> GHC.Types.IO a
  newIORef :: forall a. a -> GHC.Types.IO (IORef a)
  readIORef :: forall a. IORef a -> GHC.Types.IO a
  writeIORef :: forall a. IORef a -> a -> GHC.Types.IO ()

module GHC.InfoProv where
  -- Safety: Trustworthy
  type InfoProv :: *
  data InfoProv = InfoProv {ipName :: GHC.Base.String, ipDesc :: GHC.Base.String, ipTyDesc :: GHC.Base.String, ipLabel :: GHC.Base.String, ipMod :: GHC.Base.String, ipSrcFile :: GHC.Base.String, ipSrcSpan :: GHC.Base.String}
  type InfoProvEnt :: *
  data InfoProvEnt
  ipLoc :: InfoProv -> GHC.Base.String
  ipeProv :: GHC.Ptr.Ptr InfoProvEnt -> GHC.Ptr.Ptr InfoProv
  peekInfoProv :: GHC.Ptr.Ptr InfoProv -> GHC.Types.IO InfoProv
  whereFrom :: forall a. a -> GHC.Types.IO (GHC.Maybe.Maybe InfoProv)

module GHC.Int where
  -- Safety: Trustworthy
  type Int :: *
  data Int = I# GHC.Prim.Int#
  type Int16 :: *
  data Int16 = I16# GHC.Prim.Int16#
  type Int32 :: *
  data Int32 = I32# GHC.Prim.Int32#
  type Int64 :: *
  data Int64 = I64# GHC.Prim.Int64#
  type Int8 :: *
  data Int8 = I8# GHC.Prim.Int8#
  eqInt :: Int -> Int -> GHC.Types.Bool
  eqInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  eqInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  eqInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  eqInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  geInt :: Int -> Int -> GHC.Types.Bool
  geInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  geInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  geInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  geInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  gtInt :: Int -> Int -> GHC.Types.Bool
  gtInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  gtInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  gtInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  gtInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  leInt :: Int -> Int -> GHC.Types.Bool
  leInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  leInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  leInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  leInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  ltInt :: Int -> Int -> GHC.Types.Bool
  ltInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  ltInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  ltInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  ltInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  neInt :: Int -> Int -> GHC.Types.Bool
  neInt16 :: Int16 -> Int16 -> GHC.Types.Bool
  neInt32 :: Int32 -> Int32 -> GHC.Types.Bool
  neInt64 :: Int64 -> Int64 -> GHC.Types.Bool
  neInt8 :: Int8 -> Int8 -> GHC.Types.Bool
  shiftRLInt16# :: GHC.Prim.Int16# -> GHC.Prim.Int# -> GHC.Prim.Int16#
  shiftRLInt32# :: GHC.Prim.Int32# -> GHC.Prim.Int# -> GHC.Prim.Int32#
  shiftRLInt8# :: GHC.Prim.Int8# -> GHC.Prim.Int# -> GHC.Prim.Int8#
  uncheckedIShiftL64# :: GHC.Prim.Int64# -> GHC.Prim.Int# -> GHC.Prim.Int64#
  uncheckedIShiftRA64# :: GHC.Prim.Int64# -> GHC.Prim.Int# -> GHC.Prim.Int64#

module GHC.Integer where
  -- Safety: None
  type Integer :: *
  data Integer = ...
  absInteger :: Integer -> Integer
  andInteger :: Integer -> Integer -> Integer
  bitInteger :: GHC.Prim.Int# -> Integer
  compareInteger :: Integer -> Integer -> GHC.Types.Ordering
  complementInteger :: Integer -> Integer
  decodeDoubleInteger :: GHC.Prim.Double# -> (# Integer, GHC.Prim.Int# #)
  divInteger :: Integer -> Integer -> Integer
  divModInteger :: Integer -> Integer -> (# Integer, Integer #)
  encodeDoubleInteger :: Integer -> GHC.Prim.Int# -> GHC.Prim.Double#
  encodeFloatInteger :: Integer -> GHC.Prim.Int# -> GHC.Prim.Float#
  eqInteger :: Integer -> Integer -> GHC.Types.Bool
  eqInteger# :: Integer -> Integer -> GHC.Prim.Int#
  geInteger :: Integer -> Integer -> GHC.Types.Bool
  geInteger# :: Integer -> Integer -> GHC.Prim.Int#
  gtInteger :: Integer -> Integer -> GHC.Types.Bool
  gtInteger# :: Integer -> Integer -> GHC.Prim.Int#
  hashInteger :: Integer -> GHC.Prim.Int#
  int64ToInteger :: GHC.Prim.Int64# -> Integer
  integerToInt :: Integer -> GHC.Prim.Int#
  integerToInt64 :: Integer -> GHC.Prim.Int64#
  integerToWord :: Integer -> GHC.Prim.Word#
  integerToWord64 :: Integer -> GHC.Prim.Word64#
  leInteger :: Integer -> Integer -> GHC.Types.Bool
  leInteger# :: Integer -> Integer -> GHC.Prim.Int#
  ltInteger :: Integer -> Integer -> GHC.Types.Bool
  ltInteger# :: Integer -> Integer -> GHC.Prim.Int#
  minusInteger :: Integer -> Integer -> Integer
  modInteger :: Integer -> Integer -> Integer
  negateInteger :: Integer -> Integer
  neqInteger :: Integer -> Integer -> GHC.Types.Bool
  neqInteger# :: Integer -> Integer -> GHC.Prim.Int#
  orInteger :: Integer -> Integer -> Integer
  plusInteger :: Integer -> Integer -> Integer
  popCountInteger :: Integer -> GHC.Prim.Int#
  quotInteger :: Integer -> Integer -> Integer
  quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
  remInteger :: Integer -> Integer -> Integer
  shiftLInteger :: Integer -> GHC.Prim.Int# -> Integer
  shiftRInteger :: Integer -> GHC.Prim.Int# -> Integer
  signumInteger :: Integer -> Integer
  smallInteger :: GHC.Prim.Int# -> Integer
  testBitInteger :: Integer -> GHC.Prim.Int# -> GHC.Types.Bool
  timesInteger :: Integer -> Integer -> Integer
  word64ToInteger :: GHC.Prim.Word64# -> Integer
  wordToInteger :: GHC.Prim.Word# -> Integer
  xorInteger :: Integer -> Integer -> Integer

module GHC.Integer.Logarithms where
  -- Safety: None
  integerLog2# :: GHC.Num.Integer.Integer -> GHC.Prim.Int#
  integerLogBase# :: GHC.Num.Integer.Integer -> GHC.Num.Integer.Integer -> GHC.Prim.Int#
  wordLog2# :: GHC.Prim.Word# -> GHC.Prim.Int#

module GHC.IsList where
  -- Safety: Trustworthy
  type IsList :: * -> Constraint
  class IsList l where
    type Item :: * -> *
    type family Item l
    fromList :: [Item l] -> l
    fromListN :: GHC.Types.Int -> [Item l] -> l
    toList :: l -> [Item l]
    {-# MINIMAL fromList, toList #-}

module GHC.Ix where
  -- Safety: None
  type Ix :: * -> Constraint
  class GHC.Classes.Ord a => Ix a where
    range :: (a, a) -> [a]
    index :: (a, a) -> a -> GHC.Types.Int
    unsafeIndex :: (a, a) -> a -> GHC.Types.Int
    inRange :: (a, a) -> a -> GHC.Types.Bool
    rangeSize :: (a, a) -> GHC.Types.Int
    unsafeRangeSize :: (a, a) -> GHC.Types.Int
    {-# MINIMAL range, (index | unsafeIndex), inRange #-}
  indexError :: forall a b. GHC.Show.Show a => (a, a) -> a -> GHC.Base.String -> b

module GHC.List where
  -- Safety: Trustworthy
  (!!) :: forall a. GHC.Stack.Types.HasCallStack => [a] -> GHC.Types.Int -> a
  (!?) :: forall a. [a] -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. [a] -> [a] -> [a]
  type List :: * -> *
  data List a = ...
  all :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  and :: [GHC.Types.Bool] -> GHC.Types.Bool
  any :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  augment :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a] -> [a]
  break :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
  concat :: forall a. [[a]] -> [a]
  concatMap :: forall a b. (a -> [b]) -> [a] -> [b]
  cycle :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  drop :: forall a. GHC.Types.Int -> [a] -> [a]
  dropWhile :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  elem :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  errorEmptyList :: forall a. GHC.Stack.Types.HasCallStack => GHC.Base.String -> a
  filter :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b
  foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b
  foldl1 :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldl1' :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldr :: forall a b. (a -> b -> b) -> b -> [a] -> b
  foldr' :: forall a b. (a -> b -> b) -> b -> [a] -> b
  foldr1 :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  head :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  init :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  iterate :: forall a. (a -> a) -> a -> [a]
  iterate' :: forall a. (a -> a) -> a -> [a]
  last :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  length :: forall a. [a] -> GHC.Types.Int
  lookup :: forall a b. GHC.Classes.Eq a => a -> [(a, b)] -> GHC.Maybe.Maybe b
  map :: forall a b. (a -> b) -> [a] -> [b]
  maximum :: forall a. (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  minimum :: forall a. (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  notElem :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  null :: forall a. [a] -> GHC.Types.Bool
  or :: [GHC.Types.Bool] -> GHC.Types.Bool
  product :: forall a. GHC.Num.Num a => [a] -> a
  repeat :: forall a. a -> [a]
  replicate :: forall a. GHC.Types.Int -> a -> [a]
  reverse :: forall a. [a] -> [a]
  scanl :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl' :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
  scanr :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: forall a. (a -> a -> a) -> [a] -> [a]
  span :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
  sum :: forall a. GHC.Num.Num a => [a] -> a
  tail :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  take :: forall a. GHC.Types.Int -> [a] -> [a]
  takeWhile :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  uncons :: forall a. [a] -> GHC.Maybe.Maybe (a, [a])
  unsnoc :: forall a. [a] -> GHC.Maybe.Maybe ([a], a)
  unzip :: forall a b. [(a, b)] -> ([a], [b])
  unzip3 :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
  zip :: forall a b. [a] -> [b] -> [(a, b)]
  zip3 :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
  zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]

module GHC.MVar where
  -- Safety: Unsafe
  type MVar :: * -> *
  data MVar a = MVar (GHC.Prim.MVar# GHC.Prim.RealWorld a)
  addMVarFinalizer :: forall a. MVar a -> GHC.Types.IO () -> GHC.Types.IO ()
  isEmptyMVar :: forall a. MVar a -> GHC.Types.IO GHC.Types.Bool
  newEmptyMVar :: forall a. GHC.Types.IO (MVar a)
  newMVar :: forall a. a -> GHC.Types.IO (MVar a)
  putMVar :: forall a. MVar a -> a -> GHC.Types.IO ()
  readMVar :: forall a. MVar a -> GHC.Types.IO a
  takeMVar :: forall a. MVar a -> GHC.Types.IO a
  tryPutMVar :: forall a. MVar a -> a -> GHC.Types.IO GHC.Types.Bool
  tryReadMVar :: forall a. MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)
  tryTakeMVar :: forall a. MVar a -> GHC.Types.IO (GHC.Maybe.Maybe a)

module GHC.Maybe where
  -- Safety: None
  type Maybe :: * -> *
  data Maybe a = Nothing | Just a

module GHC.Natural where
  -- Safety: Trustworthy
  type BigNat :: *
  data BigNat = BN# {unBigNat :: GHC.Num.BigNat.BigNat#}
  pattern NatJ# :: BigNat -> Natural
  pattern NatS# :: GHC.Prim.Word# -> Natural
  type Natural :: *
  data Natural = ...
  andNatural :: Natural -> Natural -> Natural
  bitNatural :: GHC.Prim.Int# -> Natural
  gcdNatural :: Natural -> Natural -> Natural
  isValidNatural :: Natural -> GHC.Types.Bool
  lcmNatural :: Natural -> Natural -> Natural
  minusNatural :: Natural -> Natural -> Natural
  minusNaturalMaybe :: Natural -> Natural -> GHC.Maybe.Maybe Natural
  mkNatural :: [GHC.Types.Word] -> Natural
  naturalFromInteger :: GHC.Num.Integer.Integer -> Natural
  naturalToInteger :: Natural -> GHC.Num.Integer.Integer
  naturalToWord :: Natural -> GHC.Types.Word
  naturalToWordMaybe :: Natural -> GHC.Maybe.Maybe GHC.Types.Word
  negateNatural :: Natural -> Natural
  orNatural :: Natural -> Natural -> Natural
  plusNatural :: Natural -> Natural -> Natural
  popCountNatural :: Natural -> GHC.Types.Int
  powModNatural :: Natural -> Natural -> Natural -> Natural
  quotNatural :: Natural -> Natural -> Natural
  quotRemNatural :: Natural -> Natural -> (Natural, Natural)
  remNatural :: Natural -> Natural -> Natural
  shiftLNatural :: Natural -> GHC.Types.Int -> Natural
  shiftRNatural :: Natural -> GHC.Types.Int -> Natural
  signumNatural :: Natural -> Natural
  testBitNatural :: Natural -> GHC.Types.Int -> GHC.Types.Bool
  timesNatural :: Natural -> Natural -> Natural
  wordToNatural :: GHC.Types.Word -> Natural
  wordToNatural# :: GHC.Types.Word -> Natural
  xorNatural :: Natural -> Natural -> Natural

module GHC.Num where
  -- Safety: Trustworthy
  type Integer :: *
  data Integer = IS GHC.Prim.Int# | IP GHC.Prim.ByteArray# | IN GHC.Prim.ByteArray#
  type Natural :: *
  data Natural = NS GHC.Prim.Word# | NB GHC.Prim.ByteArray#
  type Num :: * -> Constraint
  class Num a where
    (+) :: a -> a -> a
    (-) :: a -> a -> a
    (*) :: a -> a -> a
    negate :: a -> a
    abs :: a -> a
    signum :: a -> a
    fromInteger :: Integer -> a
    {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  integerAbs :: Integer -> Integer
  integerAdd :: Integer -> Integer -> Integer
  integerAnd :: Integer -> Integer -> Integer
  integerBit :: GHC.Types.Word -> Integer
  integerBit# :: GHC.Prim.Word# -> Integer
  integerCheck :: Integer -> GHC.Types.Bool
  integerCheck# :: Integer -> GHC.Num.Primitives.Bool#
  integerCompare :: Integer -> Integer -> GHC.Types.Ordering
  integerComplement :: Integer -> Integer
  integerDecodeDouble# :: GHC.Prim.Double# -> (# Integer, GHC.Prim.Int# #)
  integerDiv :: Integer -> Integer -> Integer
  integerDivMod :: Integer -> Integer -> (Integer, Integer)
  integerDivMod# :: Integer -> Integer -> (# Integer, Integer #)
  integerEncodeDouble :: Integer -> GHC.Types.Int -> GHC.Types.Double
  integerEncodeDouble# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Double#
  integerEncodeFloat# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Float#
  integerEq :: Integer -> Integer -> GHC.Types.Bool
  integerEq# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Integer
  integerFromAddr# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromBigNat# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatNeg# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatSign# :: GHC.Prim.Int# -> GHC.Num.BigNat.BigNat# -> Integer
  integerFromByteArray :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> Integer
  integerFromByteArray# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromInt :: GHC.Types.Int -> Integer
  integerFromInt# :: GHC.Prim.Int# -> Integer
  integerFromInt64# :: GHC.Prim.Int64# -> Integer
  integerFromNatural :: Natural -> Integer
  integerFromWord :: GHC.Types.Word -> Integer
  integerFromWord# :: GHC.Prim.Word# -> Integer
  integerFromWord64# :: GHC.Prim.Word64# -> Integer
  integerFromWordList :: GHC.Types.Bool -> [GHC.Types.Word] -> Integer
  integerFromWordNeg# :: GHC.Prim.Word# -> Integer
  integerFromWordSign# :: GHC.Prim.Int# -> GHC.Prim.Word# -> Integer
  integerGcd :: Integer -> Integer -> Integer
  integerGcde :: Integer -> Integer -> (Integer, Integer, Integer)
  integerGcde# :: Integer -> Integer -> (# Integer, Integer, Integer #)
  integerGe :: Integer -> Integer -> GHC.Types.Bool
  integerGe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerGt :: Integer -> Integer -> GHC.Types.Bool
  integerGt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerIsNegative :: Integer -> GHC.Types.Bool
  integerIsNegative# :: Integer -> GHC.Num.Primitives.Bool#
  integerIsOne :: Integer -> GHC.Types.Bool
  integerIsPowerOf2# :: Integer -> (# (# #) | GHC.Prim.Word# #)
  integerIsZero :: Integer -> GHC.Types.Bool
  integerLcm :: Integer -> Integer -> Integer
  integerLe :: Integer -> Integer -> GHC.Types.Bool
  integerLe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerLog2 :: Integer -> GHC.Types.Word
  integerLog2# :: Integer -> GHC.Prim.Word#
  integerLogBase :: Integer -> Integer -> GHC.Types.Word
  integerLogBase# :: Integer -> Integer -> GHC.Prim.Word#
  integerLogBaseWord :: GHC.Types.Word -> Integer -> GHC.Types.Word
  integerLogBaseWord# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerLt :: Integer -> Integer -> GHC.Types.Bool
  integerLt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerMod :: Integer -> Integer -> Integer
  integerMul :: Integer -> Integer -> Integer
  integerNe :: Integer -> Integer -> GHC.Types.Bool
  integerNe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerNegate :: Integer -> Integer
  integerOne :: Integer
  integerOr :: Integer -> Integer -> Integer
  integerPopCount# :: Integer -> GHC.Prim.Int#
  integerPowMod# :: Integer -> Integer -> Natural -> (# Natural | () #)
  integerQuot :: Integer -> Integer -> Integer
  integerQuotRem :: Integer -> Integer -> (Integer, Integer)
  integerQuotRem# :: Integer -> Integer -> (# Integer, Integer #)
  integerRecipMod# :: Integer -> Natural -> (# Natural | () #)
  integerRem :: Integer -> Integer -> Integer
  integerShiftL :: Integer -> GHC.Types.Word -> Integer
  integerShiftL# :: Integer -> GHC.Prim.Word# -> Integer
  integerShiftR :: Integer -> GHC.Types.Word -> Integer
  integerShiftR# :: Integer -> GHC.Prim.Word# -> Integer
  integerSignum :: Integer -> Integer
  integerSignum# :: Integer -> GHC.Prim.Int#
  integerSizeInBase# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerSqr :: Integer -> Integer
  integerSub :: Integer -> Integer -> Integer
  integerTestBit :: Integer -> GHC.Types.Word -> GHC.Types.Bool
  integerTestBit# :: Integer -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  integerToAddr :: Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToAddr# :: forall s. Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToBigNatClamp# :: Integer -> GHC.Num.BigNat.BigNat#
  integerToBigNatSign# :: Integer -> (# GHC.Prim.Int#, GHC.Num.BigNat.BigNat# #)
  integerToInt :: Integer -> GHC.Types.Int
  integerToInt# :: Integer -> GHC.Prim.Int#
  integerToInt64# :: Integer -> GHC.Prim.Int64#
  integerToMutableByteArray :: Integer -> GHC.Prim.MutableByteArray# GHC.Prim.RealWorld -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToMutableByteArray# :: forall s. Integer -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToNatural :: Integer -> Natural
  integerToNaturalClamp :: Integer -> Natural
  integerToNaturalThrow :: Integer -> Natural
  integerToWord :: Integer -> GHC.Types.Word
  integerToWord# :: Integer -> GHC.Prim.Word#
  integerToWord64# :: Integer -> GHC.Prim.Word64#
  integerXor :: Integer -> Integer -> Integer
  integerZero :: Integer
  naturalAdd :: Natural -> Natural -> Natural
  naturalAnd :: Natural -> Natural -> Natural
  naturalAndNot :: Natural -> Natural -> Natural
  naturalBit :: GHC.Types.Word -> Natural
  naturalBit# :: GHC.Prim.Word# -> Natural
  naturalCheck :: Natural -> GHC.Types.Bool
  naturalCheck# :: Natural -> GHC.Num.Primitives.Bool#
  naturalClearBit :: Natural -> GHC.Types.Word -> Natural
  naturalClearBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalCompare :: Natural -> Natural -> GHC.Types.Ordering
  naturalComplementBit :: Natural -> GHC.Types.Word -> Natural
  naturalComplementBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalEncodeDouble# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Double#
  naturalEncodeFloat# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Float#
  naturalEq :: Natural -> Natural -> GHC.Types.Bool
  naturalEq# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Natural
  naturalFromAddr# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromBigNat# :: GHC.Num.BigNat.BigNat# -> Natural
  naturalFromByteArray# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromWord :: GHC.Types.Word -> Natural
  naturalFromWord# :: GHC.Prim.Word# -> Natural
  naturalFromWord2# :: GHC.Prim.Word# -> GHC.Prim.Word# -> Natural
  naturalFromWordList :: [GHC.Types.Word] -> Natural
  naturalGcd :: Natural -> Natural -> Natural
  naturalGe :: Natural -> Natural -> GHC.Types.Bool
  naturalGe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalGt :: Natural -> Natural -> GHC.Types.Bool
  naturalGt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalIsOne :: Natural -> GHC.Types.Bool
  naturalIsPowerOf2# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalIsZero :: Natural -> GHC.Types.Bool
  naturalLcm :: Natural -> Natural -> Natural
  naturalLe :: Natural -> Natural -> GHC.Types.Bool
  naturalLe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalLog2 :: Natural -> GHC.Types.Word
  naturalLog2# :: Natural -> GHC.Prim.Word#
  naturalLogBase :: Natural -> Natural -> GHC.Types.Word
  naturalLogBase# :: Natural -> Natural -> GHC.Prim.Word#
  naturalLogBaseWord :: GHC.Types.Word -> Natural -> GHC.Types.Word
  naturalLogBaseWord# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalLt :: Natural -> Natural -> GHC.Types.Bool
  naturalLt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalMul :: Natural -> Natural -> Natural
  naturalNe :: Natural -> Natural -> GHC.Types.Bool
  naturalNe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalNegate :: Natural -> Natural
  naturalOne :: Natural
  naturalOr :: Natural -> Natural -> Natural
  naturalPopCount :: Natural -> GHC.Types.Word
  naturalPopCount# :: Natural -> GHC.Prim.Word#
  naturalPowMod :: Natural -> Natural -> Natural -> Natural
  naturalQuot :: Natural -> Natural -> Natural
  naturalQuotRem :: Natural -> Natural -> (Natural, Natural)
  naturalQuotRem# :: Natural -> Natural -> (# Natural, Natural #)
  naturalRem :: Natural -> Natural -> Natural
  naturalSetBit :: Natural -> GHC.Types.Word -> Natural
  naturalSetBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftL :: Natural -> GHC.Types.Word -> Natural
  naturalShiftL# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftR :: Natural -> GHC.Types.Word -> Natural
  naturalShiftR# :: Natural -> GHC.Prim.Word# -> Natural
  naturalSignum :: Natural -> Natural
  naturalSizeInBase# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalSqr :: Natural -> Natural
  naturalSub :: Natural -> Natural -> (# (# #) | Natural #)
  naturalSubThrow :: Natural -> Natural -> Natural
  naturalSubUnsafe :: Natural -> Natural -> Natural
  naturalTestBit :: Natural -> GHC.Types.Word -> GHC.Types.Bool
  naturalTestBit# :: Natural -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  naturalToAddr :: Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  naturalToAddr# :: forall s. Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToBigNat# :: Natural -> GHC.Num.BigNat.BigNat#
  naturalToMutableByteArray# :: forall s. Natural -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToWord :: Natural -> GHC.Types.Word
  naturalToWord# :: Natural -> GHC.Prim.Word#
  naturalToWordClamp :: Natural -> GHC.Types.Word
  naturalToWordClamp# :: Natural -> GHC.Prim.Word#
  naturalToWordMaybe# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalXor :: Natural -> Natural -> Natural
  naturalZero :: Natural
  quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
  subtract :: forall a. Num a => a -> a -> a

module GHC.Num.BigNat where
  -- Safety: None
  type BigNat :: *
  data BigNat = BN# {unBigNat :: BigNat#}
  type BigNat# :: GHC.Types.UnliftedType
  type BigNat# = GHC.Num.WordArray.WordArray# :: GHC.Types.UnliftedType
  bigNatAdd :: BigNat# -> BigNat# -> BigNat#
  bigNatAddWord :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatAddWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatAnd :: BigNat# -> BigNat# -> BigNat#
  bigNatAndInt# :: BigNat# -> GHC.Prim.Int# -> BigNat#
  bigNatAndNot :: BigNat# -> BigNat# -> BigNat#
  bigNatAndNotWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatAndWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatBit :: GHC.Types.Word -> BigNat#
  bigNatBit# :: GHC.Prim.Word# -> BigNat#
  bigNatCheck :: BigNat# -> GHC.Types.Bool
  bigNatCheck# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatClearBit# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatCompare :: BigNat# -> BigNat# -> GHC.Types.Ordering
  bigNatCompareWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Ordering
  bigNatCompareWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Types.Ordering
  bigNatComplementBit# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatCtz :: BigNat# -> GHC.Types.Word
  bigNatCtz# :: BigNat# -> GHC.Prim.Word#
  bigNatCtzWord :: BigNat# -> GHC.Types.Word
  bigNatCtzWord# :: BigNat# -> GHC.Prim.Word#
  bigNatEncodeDouble# :: BigNat# -> GHC.Prim.Int# -> GHC.Prim.Double#
  bigNatEq :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatEq# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatEqWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatFromAbsInt# :: GHC.Prim.Int# -> BigNat#
  bigNatFromAddr# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromAddrBE# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromAddrLE# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromByteArray# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromByteArrayBE# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromByteArrayLE# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, BigNat# #)
  bigNatFromWord :: GHC.Types.Word -> BigNat#
  bigNatFromWord# :: GHC.Prim.Word# -> BigNat#
  bigNatFromWord2# :: GHC.Prim.Word# -> GHC.Prim.Word# -> BigNat#
  bigNatFromWord64# :: GHC.Prim.Word64# -> BigNat#
  bigNatFromWordArray :: GHC.Num.WordArray.WordArray# -> GHC.Prim.Word# -> BigNat
  bigNatFromWordArray# :: GHC.Num.WordArray.WordArray# -> GHC.Prim.Word# -> BigNat#
  bigNatFromWordList :: [GHC.Types.Word] -> BigNat#
  bigNatFromWordList# :: [GHC.Types.Word] -> GHC.Num.WordArray.WordArray#
  bigNatFromWordListUnsafe :: [GHC.Types.Word] -> BigNat#
  bigNatGcd :: BigNat# -> BigNat# -> BigNat#
  bigNatGcdWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Prim.Word#
  bigNatGe :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatGe# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatGt :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatGt# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatGtWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Bool
  bigNatGtWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatIndex :: BigNat# -> GHC.Prim.Int# -> GHC.Types.Word
  bigNatIndex# :: BigNat# -> GHC.Prim.Int# -> GHC.Prim.Word#
  bigNatIsOne :: BigNat# -> GHC.Types.Bool
  bigNatIsOne# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatIsPowerOf2# :: BigNat# -> (# (# #) | GHC.Prim.Word# #)
  bigNatIsTwo :: BigNat# -> GHC.Types.Bool
  bigNatIsTwo# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatIsZero :: BigNat# -> GHC.Types.Bool
  bigNatIsZero# :: BigNat# -> GHC.Num.Primitives.Bool#
  bigNatLcm :: BigNat# -> BigNat# -> BigNat#
  bigNatLcmWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatLcmWordWord# :: GHC.Prim.Word# -> GHC.Prim.Word# -> BigNat#
  bigNatLe :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatLe# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatLeWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Bool
  bigNatLeWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatLog2 :: BigNat# -> GHC.Types.Word
  bigNatLog2# :: BigNat# -> GHC.Prim.Word#
  bigNatLogBase :: BigNat# -> BigNat# -> GHC.Types.Word
  bigNatLogBase# :: BigNat# -> BigNat# -> GHC.Prim.Word#
  bigNatLogBaseWord :: GHC.Types.Word -> BigNat# -> GHC.Types.Word
  bigNatLogBaseWord# :: GHC.Prim.Word# -> BigNat# -> GHC.Prim.Word#
  bigNatLt :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatLt# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatMul :: BigNat# -> BigNat# -> BigNat#
  bigNatMulWord :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatMulWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatNe :: BigNat# -> BigNat# -> GHC.Types.Bool
  bigNatNe# :: BigNat# -> BigNat# -> GHC.Num.Primitives.Bool#
  bigNatOne :: BigNat
  bigNatOne# :: (# #) -> BigNat#
  bigNatOr :: BigNat# -> BigNat# -> BigNat#
  bigNatOrWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatPopCount :: BigNat# -> GHC.Types.Word
  bigNatPopCount# :: BigNat# -> GHC.Prim.Word#
  bigNatPowMod :: BigNat# -> BigNat# -> BigNat# -> BigNat#
  bigNatPowModWord# :: BigNat# -> BigNat# -> GHC.Prim.Word# -> GHC.Prim.Word#
  bigNatQuot :: BigNat# -> BigNat# -> BigNat#
  bigNatQuotRem# :: BigNat# -> BigNat# -> (# BigNat#, BigNat# #)
  bigNatQuotRemWord# :: BigNat# -> GHC.Prim.Word# -> (# BigNat#, GHC.Prim.Word# #)
  bigNatQuotWord :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatQuotWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatRem :: BigNat# -> BigNat# -> BigNat#
  bigNatRemWord :: BigNat# -> GHC.Types.Word -> GHC.Types.Word
  bigNatRemWord# :: BigNat# -> GHC.Prim.Word# -> GHC.Prim.Word#
  bigNatSetBit# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatShiftL :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatShiftL# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatShiftR :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatShiftR# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatShiftRNeg# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatSize :: BigNat# -> GHC.Types.Word
  bigNatSize# :: BigNat# -> GHC.Prim.Int#
  bigNatSizeInBase :: GHC.Types.Word -> BigNat# -> GHC.Types.Word
  bigNatSizeInBase# :: GHC.Prim.Word# -> BigNat# -> GHC.Prim.Word#
  bigNatSqr :: BigNat# -> BigNat#
  bigNatSub :: BigNat# -> BigNat# -> (# (# #) | BigNat# #)
  bigNatSubUnsafe :: BigNat# -> BigNat# -> BigNat#
  bigNatSubWord# :: BigNat# -> GHC.Prim.Word# -> (# (# #) | BigNat# #)
  bigNatSubWordUnsafe :: BigNat# -> GHC.Types.Word -> BigNat#
  bigNatSubWordUnsafe# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatTestBit :: BigNat# -> GHC.Types.Word -> GHC.Types.Bool
  bigNatTestBit# :: BigNat# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  bigNatToAddr :: BigNat# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  bigNatToAddr# :: forall s. BigNat# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToAddrBE# :: forall s. BigNat# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToAddrLE# :: forall s. BigNat# -> GHC.Prim.Addr# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToInt :: BigNat# -> GHC.Types.Int
  bigNatToInt# :: BigNat# -> GHC.Prim.Int#
  bigNatToMutableByteArray# :: forall s. BigNat# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToMutableByteArrayBE# :: forall s. BigNat# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToMutableByteArrayLE# :: forall s. BigNat# -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  bigNatToWord :: BigNat# -> GHC.Types.Word
  bigNatToWord# :: BigNat# -> GHC.Prim.Word#
  bigNatToWord64# :: BigNat# -> GHC.Prim.Word64#
  bigNatToWordList :: BigNat# -> [GHC.Types.Word]
  bigNatToWordMaybe# :: BigNat# -> (# (# #) | GHC.Prim.Word# #)
  bigNatXor :: BigNat# -> BigNat# -> BigNat#
  bigNatXorWord# :: BigNat# -> GHC.Prim.Word# -> BigNat#
  bigNatZero :: BigNat
  bigNatZero# :: (# #) -> BigNat#
  gcdInt :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  gcdInt# :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  gcdWord :: GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
  gcdWord# :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
  powModWord# :: GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word# -> GHC.Prim.Word#
  raiseDivZero_BigNat :: (# #) -> BigNat#

module GHC.Num.Integer where
  -- Safety: None
  type Integer :: *
  data Integer = IS GHC.Prim.Int# | IP GHC.Prim.ByteArray# | IN GHC.Prim.ByteArray#
  integerAbs :: Integer -> Integer
  integerAdd :: Integer -> Integer -> Integer
  integerAnd :: Integer -> Integer -> Integer
  integerBit :: GHC.Types.Word -> Integer
  integerBit# :: GHC.Prim.Word# -> Integer
  integerCheck :: Integer -> GHC.Types.Bool
  integerCheck# :: Integer -> GHC.Num.Primitives.Bool#
  integerCompare :: Integer -> Integer -> GHC.Types.Ordering
  integerComplement :: Integer -> Integer
  integerDecodeDouble# :: GHC.Prim.Double# -> (# Integer, GHC.Prim.Int# #)
  integerDiv :: Integer -> Integer -> Integer
  integerDivMod :: Integer -> Integer -> (Integer, Integer)
  integerDivMod# :: Integer -> Integer -> (# Integer, Integer #)
  integerEncodeDouble :: Integer -> GHC.Types.Int -> GHC.Types.Double
  integerEncodeDouble# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Double#
  integerEncodeFloat# :: Integer -> GHC.Prim.Int# -> GHC.Prim.Float#
  integerEq :: Integer -> Integer -> GHC.Types.Bool
  integerEq# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Integer
  integerFromAddr# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromBigNat# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatNeg# :: GHC.Num.BigNat.BigNat# -> Integer
  integerFromBigNatSign# :: GHC.Prim.Int# -> GHC.Num.BigNat.BigNat# -> Integer
  integerFromByteArray :: GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> Integer
  integerFromByteArray# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Integer #)
  integerFromInt :: GHC.Types.Int -> Integer
  integerFromInt# :: GHC.Prim.Int# -> Integer
  integerFromInt64# :: GHC.Prim.Int64# -> Integer
  integerFromNatural :: GHC.Num.Natural.Natural -> Integer
  integerFromWord :: GHC.Types.Word -> Integer
  integerFromWord# :: GHC.Prim.Word# -> Integer
  integerFromWord64# :: GHC.Prim.Word64# -> Integer
  integerFromWordList :: GHC.Types.Bool -> [GHC.Types.Word] -> Integer
  integerFromWordNeg# :: GHC.Prim.Word# -> Integer
  integerFromWordSign# :: GHC.Prim.Int# -> GHC.Prim.Word# -> Integer
  integerGcd :: Integer -> Integer -> Integer
  integerGcde :: Integer -> Integer -> (Integer, Integer, Integer)
  integerGcde# :: Integer -> Integer -> (# Integer, Integer, Integer #)
  integerGe :: Integer -> Integer -> GHC.Types.Bool
  integerGe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerGt :: Integer -> Integer -> GHC.Types.Bool
  integerGt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerIsNegative :: Integer -> GHC.Types.Bool
  integerIsNegative# :: Integer -> GHC.Num.Primitives.Bool#
  integerIsOne :: Integer -> GHC.Types.Bool
  integerIsPowerOf2# :: Integer -> (# (# #) | GHC.Prim.Word# #)
  integerIsZero :: Integer -> GHC.Types.Bool
  integerLcm :: Integer -> Integer -> Integer
  integerLe :: Integer -> Integer -> GHC.Types.Bool
  integerLe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerLog2 :: Integer -> GHC.Types.Word
  integerLog2# :: Integer -> GHC.Prim.Word#
  integerLogBase :: Integer -> Integer -> GHC.Types.Word
  integerLogBase# :: Integer -> Integer -> GHC.Prim.Word#
  integerLogBaseWord :: GHC.Types.Word -> Integer -> GHC.Types.Word
  integerLogBaseWord# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerLt :: Integer -> Integer -> GHC.Types.Bool
  integerLt# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerMod :: Integer -> Integer -> Integer
  integerMul :: Integer -> Integer -> Integer
  integerNe :: Integer -> Integer -> GHC.Types.Bool
  integerNe# :: Integer -> Integer -> GHC.Num.Primitives.Bool#
  integerNegate :: Integer -> Integer
  integerOne :: Integer
  integerOr :: Integer -> Integer -> Integer
  integerPopCount# :: Integer -> GHC.Prim.Int#
  integerPowMod# :: Integer -> Integer -> GHC.Num.Natural.Natural -> (# GHC.Num.Natural.Natural | () #)
  integerQuot :: Integer -> Integer -> Integer
  integerQuotRem :: Integer -> Integer -> (Integer, Integer)
  integerQuotRem# :: Integer -> Integer -> (# Integer, Integer #)
  integerRecipMod# :: Integer -> GHC.Num.Natural.Natural -> (# GHC.Num.Natural.Natural | () #)
  integerRem :: Integer -> Integer -> Integer
  integerShiftL :: Integer -> GHC.Types.Word -> Integer
  integerShiftL# :: Integer -> GHC.Prim.Word# -> Integer
  integerShiftR :: Integer -> GHC.Types.Word -> Integer
  integerShiftR# :: Integer -> GHC.Prim.Word# -> Integer
  integerSignum :: Integer -> Integer
  integerSignum# :: Integer -> GHC.Prim.Int#
  integerSizeInBase# :: GHC.Prim.Word# -> Integer -> GHC.Prim.Word#
  integerSqr :: Integer -> Integer
  integerSub :: Integer -> Integer -> Integer
  integerTestBit :: Integer -> GHC.Types.Word -> GHC.Types.Bool
  integerTestBit# :: Integer -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  integerToAddr :: Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToAddr# :: forall s. Integer -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToBigNatClamp# :: Integer -> GHC.Num.BigNat.BigNat#
  integerToBigNatSign# :: Integer -> (# GHC.Prim.Int#, GHC.Num.BigNat.BigNat# #)
  integerToInt :: Integer -> GHC.Types.Int
  integerToInt# :: Integer -> GHC.Prim.Int#
  integerToInt64# :: Integer -> GHC.Prim.Int64#
  integerToMutableByteArray :: Integer -> GHC.Prim.MutableByteArray# GHC.Prim.RealWorld -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  integerToMutableByteArray# :: forall s. Integer -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  integerToNatural :: Integer -> GHC.Num.Natural.Natural
  integerToNaturalClamp :: Integer -> GHC.Num.Natural.Natural
  integerToNaturalThrow :: Integer -> GHC.Num.Natural.Natural
  integerToWord :: Integer -> GHC.Types.Word
  integerToWord# :: Integer -> GHC.Prim.Word#
  integerToWord64# :: Integer -> GHC.Prim.Word64#
  integerXor :: Integer -> Integer -> Integer
  integerZero :: Integer

module GHC.Num.Natural where
  -- Safety: None
  type Natural :: *
  data Natural = NS GHC.Prim.Word# | NB GHC.Prim.ByteArray#
  naturalAdd :: Natural -> Natural -> Natural
  naturalAnd :: Natural -> Natural -> Natural
  naturalAndNot :: Natural -> Natural -> Natural
  naturalBit :: GHC.Types.Word -> Natural
  naturalBit# :: GHC.Prim.Word# -> Natural
  naturalCheck :: Natural -> GHC.Types.Bool
  naturalCheck# :: Natural -> GHC.Num.Primitives.Bool#
  naturalClearBit :: Natural -> GHC.Types.Word -> Natural
  naturalClearBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalCompare :: Natural -> Natural -> GHC.Types.Ordering
  naturalComplementBit :: Natural -> GHC.Types.Word -> Natural
  naturalComplementBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalEncodeDouble# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Double#
  naturalEncodeFloat# :: Natural -> GHC.Prim.Int# -> GHC.Prim.Float#
  naturalEq :: Natural -> Natural -> GHC.Types.Bool
  naturalEq# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalFromAddr :: GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO Natural
  naturalFromAddr# :: forall s. GHC.Prim.Word# -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromBigNat# :: GHC.Num.BigNat.BigNat# -> Natural
  naturalFromByteArray# :: forall s. GHC.Prim.Word# -> GHC.Prim.ByteArray# -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, Natural #)
  naturalFromWord :: GHC.Types.Word -> Natural
  naturalFromWord# :: GHC.Prim.Word# -> Natural
  naturalFromWord2# :: GHC.Prim.Word# -> GHC.Prim.Word# -> Natural
  naturalFromWordList :: [GHC.Types.Word] -> Natural
  naturalGcd :: Natural -> Natural -> Natural
  naturalGe :: Natural -> Natural -> GHC.Types.Bool
  naturalGe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalGt :: Natural -> Natural -> GHC.Types.Bool
  naturalGt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalIsOne :: Natural -> GHC.Types.Bool
  naturalIsPowerOf2# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalIsZero :: Natural -> GHC.Types.Bool
  naturalLcm :: Natural -> Natural -> Natural
  naturalLe :: Natural -> Natural -> GHC.Types.Bool
  naturalLe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalLog2 :: Natural -> GHC.Types.Word
  naturalLog2# :: Natural -> GHC.Prim.Word#
  naturalLogBase :: Natural -> Natural -> GHC.Types.Word
  naturalLogBase# :: Natural -> Natural -> GHC.Prim.Word#
  naturalLogBaseWord :: GHC.Types.Word -> Natural -> GHC.Types.Word
  naturalLogBaseWord# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalLt :: Natural -> Natural -> GHC.Types.Bool
  naturalLt# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalMul :: Natural -> Natural -> Natural
  naturalNe :: Natural -> Natural -> GHC.Types.Bool
  naturalNe# :: Natural -> Natural -> GHC.Num.Primitives.Bool#
  naturalNegate :: Natural -> Natural
  naturalOne :: Natural
  naturalOr :: Natural -> Natural -> Natural
  naturalPopCount :: Natural -> GHC.Types.Word
  naturalPopCount# :: Natural -> GHC.Prim.Word#
  naturalPowMod :: Natural -> Natural -> Natural -> Natural
  naturalQuot :: Natural -> Natural -> Natural
  naturalQuotRem :: Natural -> Natural -> (Natural, Natural)
  naturalQuotRem# :: Natural -> Natural -> (# Natural, Natural #)
  naturalRem :: Natural -> Natural -> Natural
  naturalSetBit :: Natural -> GHC.Types.Word -> Natural
  naturalSetBit# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftL :: Natural -> GHC.Types.Word -> Natural
  naturalShiftL# :: Natural -> GHC.Prim.Word# -> Natural
  naturalShiftR :: Natural -> GHC.Types.Word -> Natural
  naturalShiftR# :: Natural -> GHC.Prim.Word# -> Natural
  naturalSignum :: Natural -> Natural
  naturalSizeInBase# :: GHC.Prim.Word# -> Natural -> GHC.Prim.Word#
  naturalSqr :: Natural -> Natural
  naturalSub :: Natural -> Natural -> (# (# #) | Natural #)
  naturalSubThrow :: Natural -> Natural -> Natural
  naturalSubUnsafe :: Natural -> Natural -> Natural
  naturalTestBit :: Natural -> GHC.Types.Word -> GHC.Types.Bool
  naturalTestBit# :: Natural -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool#
  naturalToAddr :: Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Types.IO GHC.Types.Word
  naturalToAddr# :: forall s. Natural -> GHC.Prim.Addr# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToBigNat# :: Natural -> GHC.Num.BigNat.BigNat#
  naturalToMutableByteArray# :: forall s. Natural -> GHC.Prim.MutableByteArray# s -> GHC.Prim.Word# -> GHC.Num.Primitives.Bool# -> GHC.Prim.State# s -> (# GHC.Prim.State# s, GHC.Prim.Word# #)
  naturalToWord :: Natural -> GHC.Types.Word
  naturalToWord# :: Natural -> GHC.Prim.Word#
  naturalToWordClamp :: Natural -> GHC.Types.Word
  naturalToWordClamp# :: Natural -> GHC.Prim.Word#
  naturalToWordMaybe# :: Natural -> (# (# #) | GHC.Prim.Word# #)
  naturalXor :: Natural -> Natural -> Natural
  naturalZero :: Natural

module GHC.OldList where
  -- Safety: Safe
  (!!) :: forall a. GHC.Stack.Types.HasCallStack => [a] -> GHC.Types.Int -> a
  (!?) :: forall a. [a] -> GHC.Types.Int -> GHC.Maybe.Maybe a
  (++) :: forall a. [a] -> [a] -> [a]
  (\\) :: forall a. GHC.Classes.Eq a => [a] -> [a] -> [a]
  all :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  and :: [GHC.Types.Bool] -> GHC.Types.Bool
  any :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Types.Bool
  break :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  concat :: forall a. [[a]] -> [a]
  concatMap :: forall a b. (a -> [b]) -> [a] -> [b]
  cycle :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  delete :: forall a. GHC.Classes.Eq a => a -> [a] -> [a]
  deleteBy :: forall a. (a -> a -> GHC.Types.Bool) -> a -> [a] -> [a]
  deleteFirstsBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  drop :: forall a. GHC.Types.Int -> [a] -> [a]
  dropWhile :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  dropWhileEnd :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  elem :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  elemIndex :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  elemIndices :: forall a. GHC.Classes.Eq a => a -> [a] -> [GHC.Types.Int]
  filter :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  find :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Maybe.Maybe a
  findIndex :: forall a. (a -> GHC.Types.Bool) -> [a] -> GHC.Maybe.Maybe GHC.Types.Int
  findIndices :: forall a. (a -> GHC.Types.Bool) -> [a] -> [GHC.Types.Int]
  foldl :: forall a b. (b -> a -> b) -> b -> [a] -> b
  foldl' :: forall a b. (b -> a -> b) -> b -> [a] -> b
  foldl1 :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldl1' :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  foldr :: forall a b. (a -> b -> b) -> b -> [a] -> b
  foldr1 :: forall a. GHC.Stack.Types.HasCallStack => (a -> a -> a) -> [a] -> a
  genericDrop :: forall i a. GHC.Real.Integral i => i -> [a] -> [a]
  genericIndex :: forall i a. GHC.Real.Integral i => [a] -> i -> a
  genericLength :: forall i a. GHC.Num.Num i => [a] -> i
  genericReplicate :: forall i a. GHC.Real.Integral i => i -> a -> [a]
  genericSplitAt :: forall i a. GHC.Real.Integral i => i -> [a] -> ([a], [a])
  genericTake :: forall i a. GHC.Real.Integral i => i -> [a] -> [a]
  group :: forall a. GHC.Classes.Eq a => [a] -> [[a]]
  groupBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [[a]]
  head :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  init :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  inits :: forall a. [a] -> [[a]]
  insert :: forall a. GHC.Classes.Ord a => a -> [a] -> [a]
  insertBy :: forall a. (a -> a -> GHC.Types.Ordering) -> a -> [a] -> [a]
  intercalate :: forall a. [a] -> [[a]] -> [a]
  intersect :: forall a. GHC.Classes.Eq a => [a] -> [a] -> [a]
  intersectBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  intersperse :: forall a. a -> [a] -> [a]
  isInfixOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isPrefixOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  isSuffixOf :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  iterate :: forall a. (a -> a) -> a -> [a]
  iterate' :: forall a. (a -> a) -> a -> [a]
  last :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  length :: forall a. [a] -> GHC.Types.Int
  lines :: GHC.Base.String -> [GHC.Base.String]
  lookup :: forall a b. GHC.Classes.Eq a => a -> [(a, b)] -> GHC.Maybe.Maybe b
  map :: forall a b. (a -> b) -> [a] -> [b]
  mapAccumL :: forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
  mapAccumR :: forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
  maximum :: forall a. (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  maximumBy :: forall a. (a -> a -> GHC.Types.Ordering) -> [a] -> a
  minimum :: forall a. (GHC.Classes.Ord a, GHC.Stack.Types.HasCallStack) => [a] -> a
  minimumBy :: forall a. (a -> a -> GHC.Types.Ordering) -> [a] -> a
  notElem :: forall a. GHC.Classes.Eq a => a -> [a] -> GHC.Types.Bool
  nub :: forall a. GHC.Classes.Eq a => [a] -> [a]
  nubBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a]
  null :: forall a. [a] -> GHC.Types.Bool
  or :: [GHC.Types.Bool] -> GHC.Types.Bool
  partition :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  permutations :: forall a. [a] -> [[a]]
  product :: forall a. GHC.Num.Num a => [a] -> a
  repeat :: forall a. a -> [a]
  replicate :: forall a. GHC.Types.Int -> a -> [a]
  reverse :: forall a. [a] -> [a]
  scanl :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl' :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
  scanr :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: forall a. (a -> a -> a) -> [a] -> [a]
  singleton :: forall a. a -> [a]
  sort :: forall a. GHC.Classes.Ord a => [a] -> [a]
  sortBy :: forall a. (a -> a -> GHC.Types.Ordering) -> [a] -> [a]
  sortOn :: forall b a. GHC.Classes.Ord b => (a -> b) -> [a] -> [a]
  span :: forall a. (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  splitAt :: forall a. GHC.Types.Int -> [a] -> ([a], [a])
  stripPrefix :: forall a. GHC.Classes.Eq a => [a] -> [a] -> GHC.Maybe.Maybe [a]
  subsequences :: forall a. [a] -> [[a]]
  sum :: forall a. GHC.Num.Num a => [a] -> a
  tail :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  tails :: forall a. [a] -> [[a]]
  take :: forall a. GHC.Types.Int -> [a] -> [a]
  takeWhile :: forall a. (a -> GHC.Types.Bool) -> [a] -> [a]
  transpose :: forall a. [[a]] -> [[a]]
  uncons :: forall a. [a] -> GHC.Maybe.Maybe (a, [a])
  unfoldr :: forall b a. (b -> GHC.Maybe.Maybe (a, b)) -> b -> [a]
  union :: forall a. GHC.Classes.Eq a => [a] -> [a] -> [a]
  unionBy :: forall a. (a -> a -> GHC.Types.Bool) -> [a] -> [a] -> [a]
  unlines :: [GHC.Base.String] -> GHC.Base.String
  unsnoc :: forall a. [a] -> GHC.Maybe.Maybe ([a], a)
  unwords :: [GHC.Base.String] -> GHC.Base.String
  unzip :: forall a b. [(a, b)] -> ([a], [b])
  unzip3 :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
  unzip4 :: forall a b c d. [(a, b, c, d)] -> ([a], [b], [c], [d])
  unzip5 :: forall a b c d e. [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
  unzip6 :: forall a b c d e f. [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
  unzip7 :: forall a b c d e f g. [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
  words :: GHC.Base.String -> [GHC.Base.String]
  zip :: forall a b. [a] -> [b] -> [(a, b)]
  zip3 :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
  zip4 :: forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
  zip5 :: forall a b c d e. [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
  zip6 :: forall a b c d e f. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
  zip7 :: forall a b c d e f g. [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
  zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
  zipWith4 :: forall a b c d e. (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
  zipWith5 :: forall a b c d e f. (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
  zipWith6 :: forall a b c d e f g. (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
  zipWith7 :: forall a b c d e f g h. (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]

module GHC.OverloadedLabels where
  -- Safety: None
  type IsLabel :: GHC.Types.Symbol -> * -> Constraint
  class IsLabel x a where
    fromLabel :: a
    {-# MINIMAL fromLabel #-}

module GHC.Pack where
  -- Safety: Unsafe
  packCString# :: [GHC.Types.Char] -> GHC.Prim.ByteArray#
  unpackAppendCString# :: GHC.Prim.Addr# -> [GHC.Types.Char] -> [GHC.Types.Char]
  unpackCString :: forall a. GHC.Ptr.Ptr a -> [GHC.Types.Char]
  unpackCString# :: GHC.Prim.Addr# -> [GHC.Types.Char]
  unpackFoldrCString# :: forall a. GHC.Prim.Addr# -> (GHC.Types.Char -> a -> a) -> a -> a
  unpackNBytes# :: GHC.Prim.Addr# -> GHC.Prim.Int# -> [GHC.Types.Char]

module GHC.Profiling where
  -- Safety: Trustworthy
  requestHeapCensus :: GHC.Types.IO ()
  startHeapProfTimer :: GHC.Types.IO ()
  startProfTimer :: GHC.Types.IO ()
  stopHeapProfTimer :: GHC.Types.IO ()
  stopProfTimer :: GHC.Types.IO ()

module GHC.Ptr where
  -- Safety: Unsafe
  type role FunPtr phantom
  type FunPtr :: * -> *
  data FunPtr a = FunPtr GHC.Prim.Addr#
  type role Ptr phantom
  type Ptr :: * -> *
  data Ptr a = Ptr GHC.Prim.Addr#
  alignPtr :: forall a. Ptr a -> GHC.Types.Int -> Ptr a
  castFunPtr :: forall a b. FunPtr a -> FunPtr b
  castFunPtrToPtr :: forall a b. FunPtr a -> Ptr b
  castPtr :: forall a b. Ptr a -> Ptr b
  castPtrToFunPtr :: forall a b. Ptr a -> FunPtr b
  minusPtr :: forall a b. Ptr a -> Ptr b -> GHC.Types.Int
  nullFunPtr :: forall a. FunPtr a
  nullPtr :: forall a. Ptr a
  plusPtr :: forall a b. Ptr a -> GHC.Types.Int -> Ptr b

module GHC.RTS.Flags where
  -- Safety: None
  type CCFlags :: *
  data CCFlags = CCFlags {doCostCentres :: DoCostCentres, profilerTicks :: GHC.Types.Int, msecsPerTick :: GHC.Types.Int}
  type ConcFlags :: *
  data ConcFlags = ConcFlags {ctxtSwitchTime :: RtsTime, ctxtSwitchTicks :: GHC.Types.Int}
  type DebugFlags :: *
  data DebugFlags = DebugFlags {scheduler :: GHC.Types.Bool, interpreter :: GHC.Types.Bool, weak :: GHC.Types.Bool, gccafs :: GHC.Types.Bool, gc :: GHC.Types.Bool, nonmoving_gc :: GHC.Types.Bool, block_alloc :: GHC.Types.Bool, sanity :: GHC.Types.Bool, stable :: GHC.Types.Bool, prof :: GHC.Types.Bool, linker :: GHC.Types.Bool, apply :: GHC.Types.Bool, stm :: GHC.Types.Bool, squeeze :: GHC.Types.Bool, hpc :: GHC.Types.Bool, sparks :: GHC.Types.Bool}
  type DoCostCentres :: *
  data DoCostCentres = CostCentresNone | CostCentresSummary | CostCentresVerbose | CostCentresAll | CostCentresJSON
  type DoHeapProfile :: *
  data DoHeapProfile = NoHeapProfiling | HeapByCCS | HeapByMod | HeapByDescr | HeapByType | HeapByRetainer | HeapByLDV | HeapByClosureType | HeapByInfoTable
  type DoTrace :: *
  data DoTrace = TraceNone | TraceEventLog | TraceStderr
  type GCFlags :: *
  data GCFlags
    = GCFlags {statsFile :: GHC.Maybe.Maybe GHC.IO.FilePath,
               giveStats :: GiveGCStats,
               maxStkSize :: GHC.Word.Word32,
               initialStkSize :: GHC.Word.Word32,
               stkChunkSize :: GHC.Word.Word32,
               stkChunkBufferSize :: GHC.Word.Word32,
               maxHeapSize :: GHC.Word.Word32,
               minAllocAreaSize :: GHC.Word.Word32,
               largeAllocLim :: GHC.Word.Word32,
               nurseryChunkSize :: GHC.Word.Word32,
               minOldGenSize :: GHC.Word.Word32,
               heapSizeSuggestion :: GHC.Word.Word32,
               heapSizeSuggestionAuto :: GHC.Types.Bool,
               oldGenFactor :: GHC.Types.Double,
               returnDecayFactor :: GHC.Types.Double,
               pcFreeHeap :: GHC.Types.Double,
               generations :: GHC.Word.Word32,
               squeezeUpdFrames :: GHC.Types.Bool,
               compact :: GHC.Types.Bool,
               compactThreshold :: GHC.Types.Double,
               sweep :: GHC.Types.Bool,
               ringBell :: GHC.Types.Bool,
               idleGCDelayTime :: RtsTime,
               doIdleGC :: GHC.Types.Bool,
               heapBase :: GHC.Types.Word,
               allocLimitGrace :: GHC.Types.Word,
               numa :: GHC.Types.Bool,
               numaMask :: GHC.Types.Word}
  type GiveGCStats :: *
  data GiveGCStats = NoGCStats | CollectGCStats | OneLineGCStats | SummaryGCStats | VerboseGCStats
  type IoSubSystem :: *
  data IoSubSystem = IoPOSIX | IoNative
  type MiscFlags :: *
  data MiscFlags = MiscFlags {tickInterval :: RtsTime, installSignalHandlers :: GHC.Types.Bool, installSEHHandlers :: GHC.Types.Bool, generateCrashDumpFile :: GHC.Types.Bool, generateStackTrace :: GHC.Types.Bool, machineReadable :: GHC.Types.Bool, disableDelayedOsMemoryReturn :: GHC.Types.Bool, internalCounters :: GHC.Types.Bool, linkerAlwaysPic :: GHC.Types.Bool, linkerMemBase :: GHC.Types.Word, ioManager :: IoSubSystem, numIoWorkerThreads :: GHC.Word.Word32}
  type ParFlags :: *
  data ParFlags = ParFlags {nCapabilities :: GHC.Word.Word32, migrate :: GHC.Types.Bool, maxLocalSparks :: GHC.Word.Word32, parGcEnabled :: GHC.Types.Bool, parGcGen :: GHC.Word.Word32, parGcLoadBalancingEnabled :: GHC.Types.Bool, parGcLoadBalancingGen :: GHC.Word.Word32, parGcNoSyncWithIdle :: GHC.Word.Word32, parGcThreads :: GHC.Word.Word32, setAffinity :: GHC.Types.Bool}
  type ProfFlags :: *
  data ProfFlags = ProfFlags {doHeapProfile :: DoHeapProfile, heapProfileInterval :: RtsTime, heapProfileIntervalTicks :: GHC.Types.Word, startHeapProfileAtStartup :: GHC.Types.Bool, showCCSOnException :: GHC.Types.Bool, maxRetainerSetSize :: GHC.Types.Word, ccsLength :: GHC.Types.Word, modSelector :: GHC.Maybe.Maybe GHC.Base.String, descrSelector :: GHC.Maybe.Maybe GHC.Base.String, typeSelector :: GHC.Maybe.Maybe GHC.Base.String, ccSelector :: GHC.Maybe.Maybe GHC.Base.String, ccsSelector :: GHC.Maybe.Maybe GHC.Base.String, retainerSelector :: GHC.Maybe.Maybe GHC.Base.String, bioSelector :: GHC.Maybe.Maybe GHC.Base.String}
  type RTSFlags :: *
  data RTSFlags = RTSFlags {gcFlags :: GCFlags, concurrentFlags :: ConcFlags, miscFlags :: MiscFlags, debugFlags :: DebugFlags, costCentreFlags :: CCFlags, profilingFlags :: ProfFlags, traceFlags :: TraceFlags, tickyFlags :: TickyFlags, parFlags :: ParFlags}
  type RtsTime :: *
  type RtsTime = GHC.Word.Word64
  type TickyFlags :: *
  data TickyFlags = TickyFlags {showTickyStats :: GHC.Types.Bool, tickyFile :: GHC.Maybe.Maybe GHC.IO.FilePath}
  type TraceFlags :: *
  data TraceFlags = TraceFlags {tracing :: DoTrace, timestamp :: GHC.Types.Bool, traceScheduler :: GHC.Types.Bool, traceGc :: GHC.Types.Bool, traceNonmovingGc :: GHC.Types.Bool, sparksSampled :: GHC.Types.Bool, sparksFull :: GHC.Types.Bool, user :: GHC.Types.Bool}
  getCCFlags :: GHC.Types.IO CCFlags
  getConcFlags :: GHC.Types.IO ConcFlags
  getDebugFlags :: GHC.Types.IO DebugFlags
  getGCFlags :: GHC.Types.IO GCFlags
  getIoManagerFlag :: GHC.Types.IO IoSubSystem
  getMiscFlags :: GHC.Types.IO MiscFlags
  getParFlags :: GHC.Types.IO ParFlags
  getProfFlags :: GHC.Types.IO ProfFlags
  getRTSFlags :: GHC.Types.IO RTSFlags
  getTickyFlags :: GHC.Types.IO TickyFlags
  getTraceFlags :: GHC.Types.IO TraceFlags

module GHC.Read where
  -- Safety: Trustworthy
  type Read :: * -> Constraint
  class Read a where
    readsPrec :: GHC.Types.Int -> ReadS a
    readList :: ReadS [a]
    readPrec :: Text.ParserCombinators.ReadPrec.ReadPrec a
    readListPrec :: Text.ParserCombinators.ReadPrec.ReadPrec [a]
    {-# MINIMAL readsPrec | readPrec #-}
  type ReadS :: * -> *
  type ReadS a = GHC.Base.String -> [(a, GHC.Base.String)]
  choose :: forall a. [(GHC.Base.String, Text.ParserCombinators.ReadPrec.ReadPrec a)] -> Text.ParserCombinators.ReadPrec.ReadPrec a
  expectP :: Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadPrec.ReadPrec ()
  lex :: ReadS GHC.Base.String
  lexDigits :: ReadS GHC.Base.String
  lexLitChar :: ReadS GHC.Base.String
  lexP :: Text.ParserCombinators.ReadPrec.ReadPrec Text.Read.Lex.Lexeme
  list :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec [a]
  paren :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  parens :: forall a. Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readField :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readFieldHash :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readListDefault :: forall a. Read a => ReadS [a]
  readListPrecDefault :: forall a. Read a => Text.ParserCombinators.ReadPrec.ReadPrec [a]
  readLitChar :: ReadS GHC.Types.Char
  readNumber :: forall a. GHC.Num.Num a => (Text.Read.Lex.Lexeme -> Text.ParserCombinators.ReadPrec.ReadPrec a) -> Text.ParserCombinators.ReadPrec.ReadPrec a
  readParen :: forall a. GHC.Types.Bool -> ReadS a -> ReadS a
  readSymField :: forall a. GHC.Base.String -> Text.ParserCombinators.ReadPrec.ReadPrec a -> Text.ParserCombinators.ReadPrec.ReadPrec a

module GHC.Real where
  -- Safety: Trustworthy
  (%) :: forall a. Integral a => a -> a -> Ratio a
  type Fractional :: * -> Constraint
  class GHC.Num.Num a => Fractional a where
    (/) :: a -> a -> a
    recip :: a -> a
    fromRational :: Rational -> a
    {-# MINIMAL fromRational, (recip | (/)) #-}
  type FractionalExponentBase :: *
  data FractionalExponentBase = Base2 | Base10
  type Integral :: * -> Constraint
  class (Real a, GHC.Enum.Enum a) => Integral a where
    quot :: a -> a -> a
    rem :: a -> a -> a
    div :: a -> a -> a
    mod :: a -> a -> a
    quotRem :: a -> a -> (a, a)
    divMod :: a -> a -> (a, a)
    toInteger :: a -> GHC.Num.Integer.Integer
    {-# MINIMAL quotRem, toInteger #-}
  type Ratio :: * -> *
  data Ratio a = !a :% !a
  type Rational :: *
  type Rational = Ratio GHC.Num.Integer.Integer
  type Real :: * -> Constraint
  class (GHC.Num.Num a, GHC.Classes.Ord a) => Real a where
    toRational :: a -> Rational
    {-# MINIMAL toRational #-}
  type RealFrac :: * -> Constraint
  class (Real a, Fractional a) => RealFrac a where
    properFraction :: forall b. Integral b => a -> (b, a)
    truncate :: forall b. Integral b => a -> b
    round :: forall b. Integral b => a -> b
    ceiling :: forall b. Integral b => a -> b
    floor :: forall b. Integral b => a -> b
    {-# MINIMAL properFraction #-}
  (^) :: forall a b. (GHC.Num.Num a, Integral b) => a -> b -> a
  (^%^) :: forall a. Integral a => Rational -> a -> Rational
  (^^) :: forall a b. (Fractional a, Integral b) => a -> b -> a
  (^^%^^) :: forall a. Integral a => Rational -> a -> Rational
  denominator :: forall a. Ratio a -> a
  divZeroError :: forall a. a
  even :: forall a. Integral a => a -> GHC.Types.Bool
  fromIntegral :: forall a b. (Integral a, GHC.Num.Num b) => a -> b
  gcd :: forall a. Integral a => a -> a -> a
  infinity :: Rational
  integralEnumFrom :: forall a. (Integral a, GHC.Enum.Bounded a) => a -> [a]
  integralEnumFromThen :: forall a. (Integral a, GHC.Enum.Bounded a) => a -> a -> [a]
  integralEnumFromThenTo :: forall a. Integral a => a -> a -> a -> [a]
  integralEnumFromTo :: forall a. Integral a => a -> a -> [a]
  lcm :: forall a. Integral a => a -> a -> a
  mkRationalBase10 :: Rational -> GHC.Num.Integer.Integer -> Rational
  mkRationalBase2 :: Rational -> GHC.Num.Integer.Integer -> Rational
  mkRationalWithExponentBase :: Rational -> GHC.Num.Integer.Integer -> FractionalExponentBase -> Rational
  notANumber :: Rational
  numerator :: forall a. Ratio a -> a
  numericEnumFrom :: forall a. Fractional a => a -> [a]
  numericEnumFromThen :: forall a. Fractional a => a -> a -> [a]
  numericEnumFromThenTo :: forall a. (GHC.Classes.Ord a, Fractional a) => a -> a -> a -> [a]
  numericEnumFromTo :: forall a. (GHC.Classes.Ord a, Fractional a) => a -> a -> [a]
  odd :: forall a. Integral a => a -> GHC.Types.Bool
  overflowError :: forall a. a
  powImpl :: forall a b. (GHC.Num.Num a, Integral b) => a -> b -> a
  powImplAcc :: forall a b. (GHC.Num.Num a, Integral b) => a -> b -> a -> a
  ratioPrec :: GHC.Types.Int
  ratioPrec1 :: GHC.Types.Int
  ratioZeroDenominatorError :: forall a. a
  realToFrac :: forall a b. (Real a, Fractional b) => a -> b
  reduce :: forall a. Integral a => a -> a -> Ratio a
  showSigned :: forall a. Real a => (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS
  underflowError :: forall a. a

module GHC.Records where
  -- Safety: Safe-Inferred
  type HasField :: forall {k}. k -> * -> * -> Constraint
  class HasField x r a | x r -> a where
    getField :: r -> a
    {-# MINIMAL getField #-}

module GHC.ResponseFile where
  -- Safety: Safe-Inferred
  escapeArgs :: [GHC.Base.String] -> GHC.Base.String
  expandResponse :: [GHC.Base.String] -> GHC.Types.IO [GHC.Base.String]
  getArgsWithResponseFiles :: GHC.Types.IO [GHC.Base.String]
  unescapeArgs :: GHC.Base.String -> [GHC.Base.String]

module GHC.ST where
  -- Safety: Unsafe
  type role ST nominal representational
  type ST :: * -> * -> *
  newtype ST s a = ST (STRep s a)
  type STRep :: * -> * -> *
  type STRep s a = GHC.Prim.State# s -> (# GHC.Prim.State# s, a #)
  type role STret nominal representational
  type STret :: * -> * -> *
  data STret s a = STret (GHC.Prim.State# s) a
  liftST :: forall s a. ST s a -> GHC.Prim.State# s -> STret s a
  runST :: forall a. (forall s. ST s a) -> a
  unsafeDupableInterleaveST :: forall s a. ST s a -> ST s a
  unsafeInterleaveST :: forall s a. ST s a -> ST s a

module GHC.STRef where
  -- Safety: Unsafe
  type role STRef nominal representational
  type STRef :: * -> * -> *
  data STRef s a = STRef (GHC.Prim.MutVar# s a)
  newSTRef :: forall a s. a -> GHC.ST.ST s (STRef s a)
  readSTRef :: forall s a. STRef s a -> GHC.ST.ST s a
  writeSTRef :: forall s a. STRef s a -> a -> GHC.ST.ST s ()

module GHC.Show where
  -- Safety: Trustworthy
  type Show :: * -> Constraint
  class Show a where
    showsPrec :: GHC.Types.Int -> a -> ShowS
    show :: a -> GHC.Base.String
    showList :: [a] -> ShowS
    {-# MINIMAL showsPrec | show #-}
  type ShowS :: *
  type ShowS = GHC.Base.String -> GHC.Base.String
  appPrec :: GHC.Types.Int
  appPrec1 :: GHC.Types.Int
  asciiTab :: [GHC.Base.String]
  intToDigit :: GHC.Types.Int -> GHC.Types.Char
  protectEsc :: (GHC.Types.Char -> GHC.Types.Bool) -> ShowS -> ShowS
  showChar :: GHC.Types.Char -> ShowS
  showCommaSpace :: ShowS
  showList__ :: forall a. (a -> ShowS) -> [a] -> ShowS
  showLitChar :: GHC.Types.Char -> ShowS
  showLitString :: GHC.Base.String -> ShowS
  showMultiLineString :: GHC.Base.String -> [GHC.Base.String]
  showParen :: GHC.Types.Bool -> ShowS -> ShowS
  showSignedInt :: GHC.Types.Int -> GHC.Types.Int -> ShowS
  showSpace :: ShowS
  showString :: GHC.Base.String -> ShowS
  shows :: forall a. Show a => a -> ShowS

module GHC.Stable where
  -- Safety: Unsafe
  type StablePtr :: * -> *
  data StablePtr a = StablePtr (GHC.Prim.StablePtr# a)
  castPtrToStablePtr :: forall a. GHC.Ptr.Ptr () -> StablePtr a
  castStablePtrToPtr :: forall a. StablePtr a -> GHC.Ptr.Ptr ()
  deRefStablePtr :: forall a. StablePtr a -> GHC.Types.IO a
  freeStablePtr :: forall a. StablePtr a -> GHC.Types.IO ()
  newStablePtr :: forall a. a -> GHC.Types.IO (StablePtr a)

module GHC.StableName where
  -- Safety: Trustworthy
  type role StableName phantom
  type StableName :: * -> *
  data StableName a = StableName (GHC.Prim.StableName# a)
  eqStableName :: forall a b. StableName a -> StableName b -> GHC.Types.Bool
  hashStableName :: forall a. StableName a -> GHC.Types.Int
  makeStableName :: forall a. a -> GHC.Types.IO (StableName a)

module GHC.Stack where
  -- Safety: Trustworthy
  type CallStack :: *
  data CallStack = ...
  type CostCentre :: *
  data CostCentre
  type CostCentreStack :: *
  data CostCentreStack
  type HasCallStack :: Constraint
  type HasCallStack = ?callStack::CallStack :: Constraint
  type SrcLoc :: *
  data SrcLoc = SrcLoc {srcLocPackage :: [GHC.Types.Char], srcLocModule :: [GHC.Types.Char], srcLocFile :: [GHC.Types.Char], srcLocStartLine :: GHC.Types.Int, srcLocStartCol :: GHC.Types.Int, srcLocEndLine :: GHC.Types.Int, srcLocEndCol :: GHC.Types.Int}
  callStack :: HasCallStack => CallStack
  ccLabel :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  ccModule :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  ccSrcSpan :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  ccsCC :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentre)
  ccsParent :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  ccsToStrings :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO [GHC.Base.String]
  clearCCS :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  currentCallStack :: GHC.Types.IO [GHC.Base.String]
  emptyCallStack :: CallStack
  errorWithStackTrace :: forall a. GHC.Base.String -> a
  freezeCallStack :: CallStack -> CallStack
  fromCallSiteList :: [([GHC.Types.Char], SrcLoc)] -> CallStack
  getCCSOf :: forall a. a -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  getCallStack :: CallStack -> [([GHC.Types.Char], SrcLoc)]
  getCurrentCCS :: forall dummy. dummy -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  popCallStack :: CallStack -> CallStack
  prettyCallStack :: CallStack -> GHC.Base.String
  prettySrcLoc :: SrcLoc -> GHC.Base.String
  pushCallStack :: ([GHC.Types.Char], SrcLoc) -> CallStack -> CallStack
  renderStack :: [GHC.Base.String] -> GHC.Base.String
  whoCreated :: forall a. a -> GHC.Types.IO [GHC.Base.String]
  withFrozenCallStack :: forall a. HasCallStack => (HasCallStack => a) -> a

module GHC.Stack.CCS where
  -- Safety: Trustworthy
  type CostCentre :: *
  data CostCentre
  type CostCentreStack :: *
  data CostCentreStack
  ccLabel :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  ccModule :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  ccSrcSpan :: GHC.Ptr.Ptr CostCentre -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  ccsCC :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentre)
  ccsParent :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  ccsToStrings :: GHC.Ptr.Ptr CostCentreStack -> GHC.Types.IO [GHC.Base.String]
  clearCCS :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  currentCallStack :: GHC.Types.IO [GHC.Base.String]
  getCCSOf :: forall a. a -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  getCurrentCCS :: forall dummy. dummy -> GHC.Types.IO (GHC.Ptr.Ptr CostCentreStack)
  renderStack :: [GHC.Base.String] -> GHC.Base.String
  whoCreated :: forall a. a -> GHC.Types.IO [GHC.Base.String]

module GHC.Stack.CloneStack where
  -- Safety: None
  type StackEntry :: *
  data StackEntry = StackEntry {functionName :: GHC.Base.String, moduleName :: GHC.Base.String, srcLoc :: GHC.Base.String, closureType :: GHC.Types.Word}
  type StackSnapshot :: *
  data StackSnapshot = StackSnapshot GHC.Prim.StackSnapshot#
  cloneMyStack :: GHC.Types.IO StackSnapshot
  cloneThreadStack :: GHC.Conc.Sync.ThreadId -> GHC.Types.IO StackSnapshot
  decode :: StackSnapshot -> GHC.Types.IO [StackEntry]

module GHC.Stack.Types where
  -- Safety: Trustworthy
  type CallStack :: *
  data CallStack = EmptyCallStack | PushCallStack [GHC.Types.Char] SrcLoc CallStack | FreezeCallStack CallStack
  type HasCallStack :: Constraint
  type HasCallStack = ?callStack::CallStack :: Constraint
  type SrcLoc :: *
  data SrcLoc = SrcLoc {srcLocPackage :: [GHC.Types.Char], srcLocModule :: [GHC.Types.Char], srcLocFile :: [GHC.Types.Char], srcLocStartLine :: GHC.Types.Int, srcLocStartCol :: GHC.Types.Int, srcLocEndLine :: GHC.Types.Int, srcLocEndCol :: GHC.Types.Int}
  emptyCallStack :: CallStack
  freezeCallStack :: CallStack -> CallStack
  fromCallSiteList :: [([GHC.Types.Char], SrcLoc)] -> CallStack
  getCallStack :: CallStack -> [([GHC.Types.Char], SrcLoc)]
  pushCallStack :: ([GHC.Types.Char], SrcLoc) -> CallStack -> CallStack

module GHC.StaticPtr where
  -- Safety: None
  type IsStatic :: (* -> *) -> Constraint
  class IsStatic p where
    fromStaticPtr :: forall a. base-4.18.0.0:Data.Typeable.Internal.Typeable a => StaticPtr a -> p a
    {-# MINIMAL fromStaticPtr #-}
  type StaticKey :: *
  type StaticKey = GHC.Fingerprint.Type.Fingerprint
  type StaticPtr :: * -> *
  data StaticPtr a = ...
  type StaticPtrInfo :: *
  data StaticPtrInfo = StaticPtrInfo {spInfoUnitId :: GHC.Base.String, spInfoModuleName :: GHC.Base.String, spInfoSrcLoc :: (GHC.Types.Int, GHC.Types.Int)}
  deRefStaticPtr :: forall a. StaticPtr a -> a
  staticKey :: forall a. StaticPtr a -> StaticKey
  staticPtrInfo :: forall a. StaticPtr a -> StaticPtrInfo
  staticPtrKeys :: GHC.Types.IO [StaticKey]
  unsafeLookupStaticPtr :: forall a. StaticKey -> GHC.Types.IO (GHC.Maybe.Maybe (StaticPtr a))

module GHC.Stats where
  -- Safety: Trustworthy
  type GCDetails :: *
  data GCDetails
    = GCDetails {gcdetails_gen :: GHC.Word.Word32,
                 gcdetails_threads :: GHC.Word.Word32,
                 gcdetails_allocated_bytes :: GHC.Word.Word64,
                 gcdetails_live_bytes :: GHC.Word.Word64,
                 gcdetails_large_objects_bytes :: GHC.Word.Word64,
                 gcdetails_compact_bytes :: GHC.Word.Word64,
                 gcdetails_slop_bytes :: GHC.Word.Word64,
                 gcdetails_mem_in_use_bytes :: GHC.Word.Word64,
                 gcdetails_copied_bytes :: GHC.Word.Word64,
                 gcdetails_par_max_copied_bytes :: GHC.Word.Word64,
                 gcdetails_par_balanced_copied_bytes :: GHC.Word.Word64,
                 gcdetails_block_fragmentation_bytes :: GHC.Word.Word64,
                 gcdetails_sync_elapsed_ns :: RtsTime,
                 gcdetails_cpu_ns :: RtsTime,
                 gcdetails_elapsed_ns :: RtsTime,
                 gcdetails_nonmoving_gc_sync_cpu_ns :: RtsTime,
                 gcdetails_nonmoving_gc_sync_elapsed_ns :: RtsTime}
  type RTSStats :: *
  data RTSStats
    = RTSStats {gcs :: GHC.Word.Word32,
                major_gcs :: GHC.Word.Word32,
                allocated_bytes :: GHC.Word.Word64,
                max_live_bytes :: GHC.Word.Word64,
                max_large_objects_bytes :: GHC.Word.Word64,
                max_compact_bytes :: GHC.Word.Word64,
                max_slop_bytes :: GHC.Word.Word64,
                max_mem_in_use_bytes :: GHC.Word.Word64,
                cumulative_live_bytes :: GHC.Word.Word64,
                copied_bytes :: GHC.Word.Word64,
                par_copied_bytes :: GHC.Word.Word64,
                cumulative_par_max_copied_bytes :: GHC.Word.Word64,
                cumulative_par_balanced_copied_bytes :: GHC.Word.Word64,
                init_cpu_ns :: RtsTime,
                init_elapsed_ns :: RtsTime,
                mutator_cpu_ns :: RtsTime,
                mutator_elapsed_ns :: RtsTime,
                gc_cpu_ns :: RtsTime,
                gc_elapsed_ns :: RtsTime,
                cpu_ns :: RtsTime,
                elapsed_ns :: RtsTime,
                nonmoving_gc_sync_cpu_ns :: RtsTime,
                nonmoving_gc_sync_elapsed_ns :: RtsTime,
                nonmoving_gc_sync_max_elapsed_ns :: RtsTime,
                nonmoving_gc_cpu_ns :: RtsTime,
                nonmoving_gc_elapsed_ns :: RtsTime,
                nonmoving_gc_max_elapsed_ns :: RtsTime,
                gc :: GCDetails}
  type RtsTime :: *
  type RtsTime = GHC.Int.Int64
  getRTSStats :: GHC.Types.IO RTSStats
  getRTSStatsEnabled :: GHC.Types.IO GHC.Types.Bool

module GHC.Storable where
  -- Safety: Trustworthy
  readDoubleOffPtr :: GHC.Ptr.Ptr GHC.Types.Double -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Double
  readFloatOffPtr :: GHC.Ptr.Ptr GHC.Types.Float -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Float
  readFunPtrOffPtr :: forall a. GHC.Ptr.Ptr (GHC.Ptr.FunPtr a) -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.FunPtr a)
  readInt16OffPtr :: GHC.Ptr.Ptr GHC.Int.Int16 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int16
  readInt32OffPtr :: GHC.Ptr.Ptr GHC.Int.Int32 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int32
  readInt64OffPtr :: GHC.Ptr.Ptr GHC.Int.Int64 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int64
  readInt8OffPtr :: GHC.Ptr.Ptr GHC.Int.Int8 -> GHC.Types.Int -> GHC.Types.IO GHC.Int.Int8
  readIntOffPtr :: GHC.Ptr.Ptr GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Int
  readPtrOffPtr :: forall a. GHC.Ptr.Ptr (GHC.Ptr.Ptr a) -> GHC.Types.Int -> GHC.Types.IO (GHC.Ptr.Ptr a)
  readStablePtrOffPtr :: forall a. GHC.Ptr.Ptr (GHC.Stable.StablePtr a) -> GHC.Types.Int -> GHC.Types.IO (GHC.Stable.StablePtr a)
  readWideCharOffPtr :: GHC.Ptr.Ptr GHC.Types.Char -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Char
  readWord16OffPtr :: GHC.Ptr.Ptr GHC.Word.Word16 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word16
  readWord32OffPtr :: GHC.Ptr.Ptr GHC.Word.Word32 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word32
  readWord64OffPtr :: GHC.Ptr.Ptr GHC.Word.Word64 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word64
  readWord8OffPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Types.IO GHC.Word.Word8
  readWordOffPtr :: GHC.Ptr.Ptr GHC.Types.Word -> GHC.Types.Int -> GHC.Types.IO GHC.Types.Word
  writeDoubleOffPtr :: GHC.Ptr.Ptr GHC.Types.Double -> GHC.Types.Int -> GHC.Types.Double -> GHC.Types.IO ()
  writeFloatOffPtr :: GHC.Ptr.Ptr GHC.Types.Float -> GHC.Types.Int -> GHC.Types.Float -> GHC.Types.IO ()
  writeFunPtrOffPtr :: forall a. GHC.Ptr.Ptr (GHC.Ptr.FunPtr a) -> GHC.Types.Int -> GHC.Ptr.FunPtr a -> GHC.Types.IO ()
  writeInt16OffPtr :: GHC.Ptr.Ptr GHC.Int.Int16 -> GHC.Types.Int -> GHC.Int.Int16 -> GHC.Types.IO ()
  writeInt32OffPtr :: GHC.Ptr.Ptr GHC.Int.Int32 -> GHC.Types.Int -> GHC.Int.Int32 -> GHC.Types.IO ()
  writeInt64OffPtr :: GHC.Ptr.Ptr GHC.Int.Int64 -> GHC.Types.Int -> GHC.Int.Int64 -> GHC.Types.IO ()
  writeInt8OffPtr :: GHC.Ptr.Ptr GHC.Int.Int8 -> GHC.Types.Int -> GHC.Int.Int8 -> GHC.Types.IO ()
  writeIntOffPtr :: GHC.Ptr.Ptr GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Types.IO ()
  writePtrOffPtr :: forall a. GHC.Ptr.Ptr (GHC.Ptr.Ptr a) -> GHC.Types.Int -> GHC.Ptr.Ptr a -> GHC.Types.IO ()
  writeStablePtrOffPtr :: forall a. GHC.Ptr.Ptr (GHC.Stable.StablePtr a) -> GHC.Types.Int -> GHC.Stable.StablePtr a -> GHC.Types.IO ()
  writeWideCharOffPtr :: GHC.Ptr.Ptr GHC.Types.Char -> GHC.Types.Int -> GHC.Types.Char -> GHC.Types.IO ()
  writeWord16OffPtr :: GHC.Ptr.Ptr GHC.Word.Word16 -> GHC.Types.Int -> GHC.Word.Word16 -> GHC.Types.IO ()
  writeWord32OffPtr :: GHC.Ptr.Ptr GHC.Word.Word32 -> GHC.Types.Int -> GHC.Word.Word32 -> GHC.Types.IO ()
  writeWord64OffPtr :: GHC.Ptr.Ptr GHC.Word.Word64 -> GHC.Types.Int -> GHC.Word.Word64 -> GHC.Types.IO ()
  writeWord8OffPtr :: GHC.Ptr.Ptr GHC.Word.Word8 -> GHC.Types.Int -> GHC.Word.Word8 -> GHC.Types.IO ()
  writeWordOffPtr :: GHC.Ptr.Ptr GHC.Types.Word -> GHC.Types.Int -> GHC.Types.Word -> GHC.Types.IO ()

module GHC.TopHandler where
  -- Safety: Trustworthy
  flushStdHandles :: GHC.Types.IO ()
  reportError :: GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  reportStackOverflow :: GHC.Types.IO ()
  runIO :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  runIOFastExit :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  runMainIO :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  runNonIO :: forall a. a -> GHC.Types.IO a
  topHandler :: forall a. GHC.Exception.Type.SomeException -> GHC.Types.IO a
  topHandlerFastExit :: forall a. GHC.Exception.Type.SomeException -> GHC.Types.IO a

module GHC.TypeError where
  -- Safety: Trustworthy
  type Assert :: GHC.Types.Bool -> Constraint -> Constraint
  type family Assert check errMsg where
    forall (_1 :: Constraint). Assert GHC.Types.True _1 = () :: Constraint
    forall (_1 :: GHC.Types.Bool) (errMsg :: Constraint). Assert _1 errMsg = errMsg
  type ErrorMessage :: *
  data ErrorMessage = Text GHC.Types.Symbol | forall t. ShowType t | ErrorMessage :<>: ErrorMessage | ErrorMessage :$$: ErrorMessage
  type TypeError :: forall b. ErrorMessage -> b
  type family TypeError a where
  type Unsatisfiable :: ErrorMessage -> Constraint
  class Unsatisfiable msg where
    ...
    {-# MINIMAL GHC.TypeError.unsatisfiableLifted #-}
  unsatisfiable :: forall {rep :: GHC.Types.RuntimeRep} (msg :: ErrorMessage) (a :: TYPE rep). Unsatisfiable msg => a

module GHC.TypeLits where
  -- Safety: Trustworthy
  type (*) :: Natural -> Natural -> Natural
  type family (*) a b
  type (+) :: Natural -> Natural -> Natural
  type family (+) a b
  type (-) :: Natural -> Natural -> Natural
  type family (-) a b
  type (<=) :: forall {t}. t -> t -> Constraint
  type (<=) x y = GHC.TypeError.Assert (x <=? y) (Data.Type.Ord.LeErrMsg x y) :: Constraint
  type (<=?) :: forall k. k -> k -> GHC.Types.Bool
  type (<=?) m n = Data.Type.Ord.OrdCond (Data.Type.Ord.Compare m n) GHC.Types.True GHC.Types.True GHC.Types.False :: GHC.Types.Bool
  type AppendSymbol :: Symbol -> Symbol -> Symbol
  type family AppendSymbol a b
  type CharToNat :: GHC.Types.Char -> Natural
  type family CharToNat a
  type CmpChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Ordering
  type family CmpChar a b
  type CmpNat :: Natural -> Natural -> GHC.Types.Ordering
  type family CmpNat a b
  type CmpSymbol :: Symbol -> Symbol -> GHC.Types.Ordering
  type family CmpSymbol a b
  type ConsSymbol :: GHC.Types.Char -> Symbol -> Symbol
  type family ConsSymbol a b
  type Div :: Natural -> Natural -> Natural
  type family Div a b
  type ErrorMessage :: *
  data ErrorMessage = Text Symbol | forall t. ShowType t | ErrorMessage :<>: ErrorMessage | ErrorMessage :$$: ErrorMessage
  type KnownChar :: GHC.Types.Char -> Constraint
  class KnownChar n where
    charSing :: SChar n
    {-# MINIMAL charSing #-}
  type KnownNat :: Nat -> Constraint
  class KnownNat n where
    natSing :: SNat n
    {-# MINIMAL natSing #-}
  type KnownSymbol :: Symbol -> Constraint
  class KnownSymbol n where
    symbolSing :: SSymbol n
    {-# MINIMAL symbolSing #-}
  type Log2 :: Natural -> Natural
  type family Log2 a
  type Mod :: Natural -> Natural -> Natural
  type family Mod a b
  type Nat :: *
  type Nat = Natural
  type NatToChar :: Natural -> GHC.Types.Char
  type family NatToChar a
  type Natural :: *
  data Natural = ...
  type role OrderingI nominal nominal
  type OrderingI :: forall {k}. k -> k -> *
  data OrderingI a b where
    LTI :: forall {k} (a :: k) (b :: k). (Data.Type.Ord.Compare a b ~ GHC.Types.LT) => OrderingI a b
    EQI :: forall {k} (a :: k). (Data.Type.Ord.Compare a a ~ GHC.Types.EQ) => OrderingI a a
    GTI :: forall {k} (a :: k) (b :: k). (Data.Type.Ord.Compare a b ~ GHC.Types.GT) => OrderingI a b
  pattern SChar :: forall (c :: GHC.Types.Char). () => KnownChar c => SChar c
  type role SChar nominal
  type SChar :: GHC.Types.Char -> *
  newtype SChar s = ...
  pattern SNat :: forall (n :: Nat). () => KnownNat n => SNat n
  type role SNat nominal
  type SNat :: Nat -> *
  newtype SNat n = ...
  pattern SSymbol :: forall (s :: Symbol). () => KnownSymbol s => SSymbol s
  type role SSymbol nominal
  type SSymbol :: Symbol -> *
  newtype SSymbol s = ...
  type SomeChar :: *
  data SomeChar = forall (n :: GHC.Types.Char). KnownChar n => SomeChar (Data.Proxy.Proxy n)
  type SomeNat :: *
  data SomeNat = forall (n :: Nat). KnownNat n => SomeNat (Data.Proxy.Proxy n)
  type SomeSymbol :: *
  data SomeSymbol = forall (n :: Symbol). KnownSymbol n => SomeSymbol (Data.Proxy.Proxy n)
  type Symbol :: *
  data Symbol
  type TypeError :: forall b. ErrorMessage -> b
  type family TypeError a where
  type UnconsSymbol :: Symbol -> GHC.Maybe.Maybe (GHC.Types.Char, Symbol)
  type family UnconsSymbol a
  type (^) :: Natural -> Natural -> Natural
  type family (^) a b
  charVal :: forall (n :: GHC.Types.Char) (proxy :: GHC.Types.Char -> *). KnownChar n => proxy n -> GHC.Types.Char
  charVal' :: forall (n :: GHC.Types.Char). KnownChar n => GHC.Prim.Proxy# n -> GHC.Types.Char
  cmpChar :: forall (a :: GHC.Types.Char) (b :: GHC.Types.Char) (proxy1 :: GHC.Types.Char -> *) (proxy2 :: GHC.Types.Char -> *). (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> OrderingI a b
  cmpNat :: forall (a :: Nat) (b :: Nat) (proxy1 :: Nat -> *) (proxy2 :: Nat -> *). (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> OrderingI a b
  cmpSymbol :: forall (a :: Symbol) (b :: Symbol) (proxy1 :: Symbol -> *) (proxy2 :: Symbol -> *). (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> OrderingI a b
  decideChar :: forall (a :: GHC.Types.Char) (b :: GHC.Types.Char) (proxy1 :: GHC.Types.Char -> *) (proxy2 :: GHC.Types.Char -> *). (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> Data.Either.Either ((a Data.Type.Equality.:~: b) -> GHC.Base.Void) (a Data.Type.Equality.:~: b)
  decideNat :: forall (a :: Nat) (b :: Nat) (proxy1 :: Nat -> *) (proxy2 :: Nat -> *). (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Data.Either.Either ((a Data.Type.Equality.:~: b) -> GHC.Base.Void) (a Data.Type.Equality.:~: b)
  decideSymbol :: forall (a :: Symbol) (b :: Symbol) (proxy1 :: Symbol -> *) (proxy2 :: Symbol -> *). (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> Data.Either.Either ((a Data.Type.Equality.:~: b) -> GHC.Base.Void) (a Data.Type.Equality.:~: b)
  fromSChar :: forall (c :: GHC.Types.Char). SChar c -> GHC.Types.Char
  fromSNat :: forall (n :: Nat). SNat n -> GHC.Num.Integer.Integer
  fromSSymbol :: forall (s :: Symbol). SSymbol s -> GHC.Base.String
  natVal :: forall (n :: Nat) (proxy :: Nat -> *). KnownNat n => proxy n -> GHC.Num.Integer.Integer
  natVal' :: forall (n :: Nat). KnownNat n => GHC.Prim.Proxy# n -> GHC.Num.Integer.Integer
  sameChar :: forall (a :: GHC.Types.Char) (b :: GHC.Types.Char) (proxy1 :: GHC.Types.Char -> *) (proxy2 :: GHC.Types.Char -> *). (KnownChar a, KnownChar b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  sameNat :: forall (a :: Nat) (b :: Nat) (proxy1 :: Nat -> *) (proxy2 :: Nat -> *). (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  sameSymbol :: forall (a :: Symbol) (b :: Symbol) (proxy1 :: Symbol -> *) (proxy2 :: Symbol -> *). (KnownSymbol a, KnownSymbol b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  someCharVal :: GHC.Types.Char -> SomeChar
  someNatVal :: GHC.Num.Integer.Integer -> GHC.Maybe.Maybe SomeNat
  someSymbolVal :: GHC.Base.String -> SomeSymbol
  symbolVal :: forall (n :: Symbol) (proxy :: Symbol -> *). KnownSymbol n => proxy n -> GHC.Base.String
  symbolVal' :: forall (n :: Symbol). KnownSymbol n => GHC.Prim.Proxy# n -> GHC.Base.String
  withKnownChar :: forall (c :: GHC.Types.Char) (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). SChar c -> (KnownChar c => r) -> r
  withKnownNat :: forall (n :: Nat) (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). SNat n -> (KnownNat n => r) -> r
  withKnownSymbol :: forall (s :: Symbol) (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). SSymbol s -> (KnownSymbol s => r) -> r
  withSomeSChar :: forall (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). GHC.Types.Char -> (forall (c :: GHC.Types.Char). SChar c -> r) -> r
  withSomeSNat :: forall (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). GHC.Num.Integer.Integer -> (forall (n :: Nat). GHC.Maybe.Maybe (SNat n) -> r) -> r
  withSomeSSymbol :: forall (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). GHC.Base.String -> (forall (s :: Symbol). SSymbol s -> r) -> r

module GHC.TypeLits.Internal where
  -- Safety: Trustworthy
  type CmpChar :: GHC.Types.Char -> GHC.Types.Char -> GHC.Types.Ordering
  type family CmpChar a b
  type CmpSymbol :: Symbol -> Symbol -> GHC.Types.Ordering
  type family CmpSymbol a b
  type Symbol :: *
  data Symbol

module GHC.TypeNats where
  -- Safety: Trustworthy
  type (*) :: Natural -> Natural -> Natural
  type family (*) a b
  type (+) :: Natural -> Natural -> Natural
  type family (+) a b
  type (-) :: Natural -> Natural -> Natural
  type family (-) a b
  type (<=) :: forall {t}. t -> t -> Constraint
  type (<=) x y = GHC.TypeError.Assert (x <=? y) (Data.Type.Ord.LeErrMsg x y) :: Constraint
  type (<=?) :: forall k. k -> k -> GHC.Types.Bool
  type (<=?) m n = Data.Type.Ord.OrdCond (Data.Type.Ord.Compare m n) GHC.Types.True GHC.Types.True GHC.Types.False :: GHC.Types.Bool
  type CmpNat :: Natural -> Natural -> GHC.Types.Ordering
  type family CmpNat a b
  type Div :: Natural -> Natural -> Natural
  type family Div a b
  type KnownNat :: Nat -> Constraint
  class KnownNat n where
    natSing :: SNat n
    {-# MINIMAL natSing #-}
  type Log2 :: Natural -> Natural
  type family Log2 a
  type Mod :: Natural -> Natural -> Natural
  type family Mod a b
  type Nat :: *
  type Nat = Natural
  type Natural :: *
  data Natural = ...
  pattern SNat :: forall (n :: Nat). () => KnownNat n => SNat n
  type role SNat nominal
  type SNat :: Nat -> *
  newtype SNat n = ...
  type SomeNat :: *
  data SomeNat = forall (n :: Nat). KnownNat n => SomeNat (Data.Proxy.Proxy n)
  type (^) :: Natural -> Natural -> Natural
  type family (^) a b
  cmpNat :: forall (a :: Nat) (b :: Nat) (proxy1 :: Nat -> *) (proxy2 :: Nat -> *). (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Data.Type.Ord.OrderingI a b
  decideNat :: forall (a :: Nat) (b :: Nat) (proxy1 :: Nat -> *) (proxy2 :: Nat -> *). (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> Data.Either.Either ((a Data.Type.Equality.:~: b) -> GHC.Base.Void) (a Data.Type.Equality.:~: b)
  fromSNat :: forall (n :: Nat). SNat n -> Natural
  natVal :: forall (n :: Nat) (proxy :: Nat -> *). KnownNat n => proxy n -> Natural
  natVal' :: forall (n :: Nat). KnownNat n => GHC.Prim.Proxy# n -> Natural
  sameNat :: forall (a :: Nat) (b :: Nat) (proxy1 :: Nat -> *) (proxy2 :: Nat -> *). (KnownNat a, KnownNat b) => proxy1 a -> proxy2 b -> GHC.Maybe.Maybe (a Data.Type.Equality.:~: b)
  someNatVal :: Natural -> SomeNat
  withKnownNat :: forall (n :: Nat) (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). SNat n -> (KnownNat n => r) -> r
  withSomeSNat :: forall (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). Natural -> (forall (n :: Nat). SNat n -> r) -> r

module GHC.TypeNats.Internal where
  -- Safety: Trustworthy
  type CmpNat :: Natural -> Natural -> GHC.Types.Ordering
  type family CmpNat a b
  type Natural :: *
  data Natural = ...

module GHC.Unicode where
  -- Safety: Trustworthy
  type GeneralCategory :: *
  data GeneralCategory = UppercaseLetter | LowercaseLetter | TitlecaseLetter | ModifierLetter | OtherLetter | NonSpacingMark | SpacingCombiningMark | EnclosingMark | DecimalNumber | LetterNumber | OtherNumber | ConnectorPunctuation | DashPunctuation | OpenPunctuation | ClosePunctuation | InitialQuote | FinalQuote | OtherPunctuation | MathSymbol | CurrencySymbol | ModifierSymbol | OtherSymbol | Space | LineSeparator | ParagraphSeparator | Control | Format | Surrogate | PrivateUse | NotAssigned
  generalCategory :: GHC.Types.Char -> GeneralCategory
  isAlpha :: GHC.Types.Char -> GHC.Types.Bool
  isAlphaNum :: GHC.Types.Char -> GHC.Types.Bool
  isAscii :: GHC.Types.Char -> GHC.Types.Bool
  isAsciiLower :: GHC.Types.Char -> GHC.Types.Bool
  isAsciiUpper :: GHC.Types.Char -> GHC.Types.Bool
  isControl :: GHC.Types.Char -> GHC.Types.Bool
  isDigit :: GHC.Types.Char -> GHC.Types.Bool
  isHexDigit :: GHC.Types.Char -> GHC.Types.Bool
  isLatin1 :: GHC.Types.Char -> GHC.Types.Bool
  isLower :: GHC.Types.Char -> GHC.Types.Bool
  isLowerCase :: GHC.Types.Char -> GHC.Types.Bool
  isOctDigit :: GHC.Types.Char -> GHC.Types.Bool
  isPrint :: GHC.Types.Char -> GHC.Types.Bool
  isPunctuation :: GHC.Types.Char -> GHC.Types.Bool
  isSpace :: GHC.Types.Char -> GHC.Types.Bool
  isSymbol :: GHC.Types.Char -> GHC.Types.Bool
  isUpper :: GHC.Types.Char -> GHC.Types.Bool
  isUpperCase :: GHC.Types.Char -> GHC.Types.Bool
  toLower :: GHC.Types.Char -> GHC.Types.Char
  toTitle :: GHC.Types.Char -> GHC.Types.Char
  toUpper :: GHC.Types.Char -> GHC.Types.Char
  unicodeVersion :: Data.Version.Version

module GHC.Weak where
  -- Safety: Unsafe
  type Weak :: * -> *
  data Weak v = Weak (GHC.Prim.Weak# v)
  deRefWeak :: forall v. Weak v -> GHC.Types.IO (GHC.Maybe.Maybe v)
  finalize :: forall v. Weak v -> GHC.Types.IO ()
  getFinalizerExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  mkWeak :: forall k v. k -> v -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak v)
  printToHandleFinalizerExceptionHandler :: GHC.IO.Handle.Types.Handle -> GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  setFinalizerExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()

module GHC.Weak.Finalize where
  -- Safety: Unsafe
  getFinalizerExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  printToHandleFinalizerExceptionHandler :: GHC.IO.Handle.Types.Handle -> GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  runFinalizerBatch :: GHC.Types.Int -> GHC.Prim.Array# (GHC.Prim.State# GHC.Prim.RealWorld -> GHC.Prim.State# GHC.Prim.RealWorld) -> GHC.Types.IO ()
  setFinalizerExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()

module GHC.Word where
  -- Safety: Trustworthy
  type Word :: *
  data Word = W# GHC.Prim.Word#
  type Word16 :: *
  data Word16 = W16# GHC.Prim.Word16#
  type Word32 :: *
  data Word32 = W32# GHC.Prim.Word32#
  type Word64 :: *
  data Word64 = W64# GHC.Prim.Word64#
  type Word8 :: *
  data Word8 = W8# GHC.Prim.Word8#
  bitReverse16 :: Word16 -> Word16
  bitReverse32 :: Word32 -> Word32
  bitReverse64 :: Word64 -> Word64
  bitReverse8 :: Word8 -> Word8
  byteSwap16 :: Word16 -> Word16
  byteSwap32 :: Word32 -> Word32
  byteSwap64 :: Word64 -> Word64
  eqWord :: Word -> Word -> GHC.Types.Bool
  eqWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  eqWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  eqWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  eqWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  geWord :: Word -> Word -> GHC.Types.Bool
  geWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  geWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  geWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  geWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  gtWord :: Word -> Word -> GHC.Types.Bool
  gtWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  gtWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  gtWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  gtWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  leWord :: Word -> Word -> GHC.Types.Bool
  leWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  leWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  leWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  leWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  ltWord :: Word -> Word -> GHC.Types.Bool
  ltWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  ltWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  ltWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  ltWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  neWord :: Word -> Word -> GHC.Types.Bool
  neWord16 :: Word16 -> Word16 -> GHC.Types.Bool
  neWord32 :: Word32 -> Word32 -> GHC.Types.Bool
  neWord64 :: Word64 -> Word64 -> GHC.Types.Bool
  neWord8 :: Word8 -> Word8 -> GHC.Types.Bool
  uncheckedShiftL64# :: GHC.Prim.Word64# -> GHC.Prim.Int# -> GHC.Prim.Word64#
  uncheckedShiftRL64# :: GHC.Prim.Word64# -> GHC.Prim.Int# -> GHC.Prim.Word64#

module Numeric where
  -- Safety: Trustworthy
  type Floating :: * -> Constraint
  class GHC.Real.Fractional a => Floating a where
    pi :: a
    exp :: a -> a
    log :: a -> a
    sqrt :: a -> a
    (**) :: a -> a -> a
    logBase :: a -> a -> a
    sin :: a -> a
    cos :: a -> a
    tan :: a -> a
    asin :: a -> a
    acos :: a -> a
    atan :: a -> a
    sinh :: a -> a
    cosh :: a -> a
    tanh :: a -> a
    asinh :: a -> a
    acosh :: a -> a
    atanh :: a -> a
    log1p :: a -> a
    expm1 :: a -> a
    log1pexp :: a -> a
    log1mexp :: a -> a
    {-# MINIMAL pi, exp, log, sin, cos, asin, acos, atan, sinh, cosh, asinh, acosh, atanh #-}
  floatToDigits :: forall a. GHC.Float.RealFloat a => GHC.Num.Integer.Integer -> a -> ([GHC.Types.Int], GHC.Types.Int)
  fromRat :: forall a. GHC.Float.RealFloat a => GHC.Real.Rational -> a
  lexDigits :: Text.ParserCombinators.ReadP.ReadS GHC.Base.String
  readBin :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readDec :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readFloat :: forall a. GHC.Real.RealFrac a => Text.ParserCombinators.ReadP.ReadS a
  readHex :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readInt :: forall a. GHC.Num.Num a => a -> (GHC.Types.Char -> GHC.Types.Bool) -> (GHC.Types.Char -> GHC.Types.Int) -> Text.ParserCombinators.ReadP.ReadS a
  readOct :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadS a
  readSigned :: forall a. GHC.Real.Real a => Text.ParserCombinators.ReadP.ReadS a -> Text.ParserCombinators.ReadP.ReadS a
  showBin :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
  showEFloat :: forall a. GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showFFloat :: forall a. GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showFFloatAlt :: forall a. GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showFloat :: forall a. GHC.Float.RealFloat a => a -> GHC.Show.ShowS
  showGFloat :: forall a. GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showGFloatAlt :: forall a. GHC.Float.RealFloat a => GHC.Maybe.Maybe GHC.Types.Int -> a -> GHC.Show.ShowS
  showHFloat :: forall a. GHC.Float.RealFloat a => a -> GHC.Show.ShowS
  showHex :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
  showInt :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
  showIntAtBase :: forall a. GHC.Real.Integral a => a -> (GHC.Types.Int -> GHC.Types.Char) -> a -> GHC.Show.ShowS
  showOct :: forall a. GHC.Real.Integral a => a -> GHC.Show.ShowS
  showSigned :: forall a. GHC.Real.Real a => (a -> GHC.Show.ShowS) -> GHC.Types.Int -> a -> GHC.Show.ShowS

module Numeric.Natural where
  -- Safety: Trustworthy
  type Natural :: *
  data Natural = ...
  minusNaturalMaybe :: Natural -> Natural -> GHC.Maybe.Maybe Natural

module Prelude where
  -- Safety: Trustworthy
  (!!) :: forall a. GHC.Stack.Types.HasCallStack => [a] -> Int -> a
  ($) :: forall (repa :: GHC.Types.RuntimeRep) (repb :: GHC.Types.RuntimeRep) (a :: TYPE repa) (b :: TYPE repb). (a -> b) -> a -> b
  ($!) :: forall (r :: GHC.Types.RuntimeRep) a (b :: TYPE r). (a -> b) -> a -> b
  (&&) :: Bool -> Bool -> Bool
  (++) :: forall a. [a] -> [a] -> [a]
  (.) :: forall b c a. (b -> c) -> (a -> b) -> a -> c
  (<$>) :: forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
  (=<<) :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> m a -> m b
  type Applicative :: (* -> *) -> Constraint
  class Functor f => Applicative f where
    pure :: forall a. a -> f a
    (<*>) :: forall a b. f (a -> b) -> f a -> f b
    liftA2 :: forall a b c. (a -> b -> c) -> f a -> f b -> f c
    (*>) :: forall a b. f a -> f b -> f b
    (<*) :: forall a b. f a -> f b -> f a
    {-# MINIMAL pure, ((<*>) | liftA2) #-}
  type Bool :: *
  data Bool = False | True
  type Bounded :: * -> Constraint
  class Bounded a where
    minBound :: a
    maxBound :: a
    {-# MINIMAL minBound, maxBound #-}
  type Char :: *
  data Char = ...
  type Double :: *
  data Double = ...
  type Either :: * -> * -> *
  data Either a b = Left a | Right b
  type Enum :: * -> Constraint
  class Enum a where
    succ :: a -> a
    pred :: a -> a
    toEnum :: Int -> a
    fromEnum :: a -> Int
    enumFrom :: a -> [a]
    enumFromThen :: a -> a -> [a]
    enumFromTo :: a -> a -> [a]
    enumFromThenTo :: a -> a -> a -> [a]
    {-# MINIMAL toEnum, fromEnum #-}
  type Eq :: * -> Constraint
  class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    {-# MINIMAL (==) | (/=) #-}
  type FilePath :: *
  type FilePath = String
  type Float :: *
  data Float = ...
  type Floating :: * -> Constraint
  class Fractional a => Floating a where
    pi :: a
    exp :: a -> a
    log :: a -> a
    sqrt :: a -> a
    (**) :: a -> a -> a
    logBase :: a -> a -> a
    sin :: a -> a
    cos :: a -> a
    tan :: a -> a
    asin :: a -> a
    acos :: a -> a
    atan :: a -> a
    sinh :: a -> a
    cosh :: a -> a
    tanh :: a -> a
    asinh :: a -> a
    acosh :: a -> a
    atanh :: a -> a
    ...
    {-# MINIMAL pi, exp, log, sin, cos, asin, acos, atan, sinh, cosh, asinh, acosh, atanh #-}
  type Foldable :: (* -> *) -> Constraint
  class Foldable t where
    ...
    foldMap :: forall m a. Monoid m => (a -> m) -> t a -> m
    ...
    foldr :: forall a b. (a -> b -> b) -> b -> t a -> b
    ...
    foldl :: forall b a. (b -> a -> b) -> b -> t a -> b
    ...
    foldr1 :: forall a. (a -> a -> a) -> t a -> a
    foldl1 :: forall a. (a -> a -> a) -> t a -> a
    ...
    null :: forall a. t a -> Bool
    length :: forall a. t a -> Int
    elem :: forall a. Eq a => a -> t a -> Bool
    maximum :: forall a. Ord a => t a -> a
    minimum :: forall a. Ord a => t a -> a
    sum :: forall a. Num a => t a -> a
    product :: forall a. Num a => t a -> a
    {-# MINIMAL foldMap | foldr #-}
  type Fractional :: * -> Constraint
  class Num a => Fractional a where
    (/) :: a -> a -> a
    recip :: a -> a
    fromRational :: Rational -> a
    {-# MINIMAL fromRational, (recip | (/)) #-}
  type Functor :: (* -> *) -> Constraint
  class Functor f where
    fmap :: forall a b. (a -> b) -> f a -> f b
    (<$) :: forall a b. a -> f b -> f a
    {-# MINIMAL fmap #-}
  type IO :: * -> *
  newtype IO a = ...
  type IOError :: *
  type IOError = GHC.IO.Exception.IOException
  type Int :: *
  data Int = ...
  type Integer :: *
  data Integer = ...
  type Integral :: * -> Constraint
  class (Real a, Enum a) => Integral a where
    quot :: a -> a -> a
    rem :: a -> a -> a
    div :: a -> a -> a
    mod :: a -> a -> a
    quotRem :: a -> a -> (a, a)
    divMod :: a -> a -> (a, a)
    toInteger :: a -> Integer
    {-# MINIMAL quotRem, toInteger #-}
  type Maybe :: * -> *
  data Maybe a = Nothing | Just a
  type Monad :: (* -> *) -> Constraint
  class Applicative m => Monad m where
    (>>=) :: forall a b. m a -> (a -> m b) -> m b
    (>>) :: forall a b. m a -> m b -> m b
    return :: forall a. a -> m a
    {-# MINIMAL (>>=) #-}
  type MonadFail :: (* -> *) -> Constraint
  class Monad m => MonadFail m where
    fail :: forall a. String -> m a
    {-# MINIMAL fail #-}
  type Monoid :: * -> Constraint
  class Semigroup a => Monoid a where
    mempty :: a
    mappend :: a -> a -> a
    mconcat :: [a] -> a
    {-# MINIMAL mempty | mconcat #-}
  type Num :: * -> Constraint
  class Num a where
    (+) :: a -> a -> a
    (-) :: a -> a -> a
    (*) :: a -> a -> a
    negate :: a -> a
    abs :: a -> a
    signum :: a -> a
    fromInteger :: Integer -> a
    {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  type Ord :: * -> Constraint
  class Eq a => Ord a where
    compare :: a -> a -> Ordering
    (<) :: a -> a -> Bool
    (<=) :: a -> a -> Bool
    (>) :: a -> a -> Bool
    (>=) :: a -> a -> Bool
    max :: a -> a -> a
    min :: a -> a -> a
    {-# MINIMAL compare | (<=) #-}
  type Ordering :: *
  data Ordering = LT | EQ | GT
  type Rational :: *
  type Rational = GHC.Real.Ratio Integer
  type Read :: * -> Constraint
  class Read a where
    readsPrec :: Int -> ReadS a
    readList :: ReadS [a]
    ...
    {-# MINIMAL readsPrec | GHC.Read.readPrec #-}
  type ReadS :: * -> *
  type ReadS a = String -> [(a, String)]
  type Real :: * -> Constraint
  class (Num a, Ord a) => Real a where
    toRational :: a -> Rational
    {-# MINIMAL toRational #-}
  type RealFloat :: * -> Constraint
  class (RealFrac a, Floating a) => RealFloat a where
    floatRadix :: a -> Integer
    floatDigits :: a -> Int
    floatRange :: a -> (Int, Int)
    decodeFloat :: a -> (Integer, Int)
    encodeFloat :: Integer -> Int -> a
    exponent :: a -> Int
    significand :: a -> a
    scaleFloat :: Int -> a -> a
    isNaN :: a -> Bool
    isInfinite :: a -> Bool
    isDenormalized :: a -> Bool
    isNegativeZero :: a -> Bool
    isIEEE :: a -> Bool
    atan2 :: a -> a -> a
    {-# MINIMAL floatRadix, floatDigits, floatRange, decodeFloat, encodeFloat, isNaN, isInfinite, isDenormalized, isNegativeZero, isIEEE #-}
  type RealFrac :: * -> Constraint
  class (Real a, Fractional a) => RealFrac a where
    properFraction :: forall b. Integral b => a -> (b, a)
    truncate :: forall b. Integral b => a -> b
    round :: forall b. Integral b => a -> b
    ceiling :: forall b. Integral b => a -> b
    floor :: forall b. Integral b => a -> b
    {-# MINIMAL properFraction #-}
  type Semigroup :: * -> Constraint
  class Semigroup a where
    (<>) :: a -> a -> a
    ...
    {-# MINIMAL (<>) | GHC.Base.sconcat #-}
  type Show :: * -> Constraint
  class Show a where
    showsPrec :: Int -> a -> ShowS
    show :: a -> String
    showList :: [a] -> ShowS
    {-# MINIMAL showsPrec | show #-}
  type ShowS :: *
  type ShowS = String -> String
  type String :: *
  type String = [Char]
  type Traversable :: (* -> *) -> Constraint
  class (Functor t, Foldable t) => Traversable t where
    traverse :: forall (f :: * -> *) a b. Applicative f => (a -> f b) -> t a -> f (t b)
    sequenceA :: forall (f :: * -> *) a. Applicative f => t (f a) -> f (t a)
    mapM :: forall (m :: * -> *) a b. Monad m => (a -> m b) -> t a -> m (t b)
    sequence :: forall (m :: * -> *) a. Monad m => t (m a) -> m (t a)
    {-# MINIMAL traverse | sequenceA #-}
  type Word :: *
  data Word = ...
  (^) :: forall a b. (Num a, Integral b) => a -> b -> a
  (^^) :: forall a b. (Fractional a, Integral b) => a -> b -> a
  all :: forall (t :: * -> *) a. Foldable t => (a -> Bool) -> t a -> Bool
  and :: forall (t :: * -> *). Foldable t => t Bool -> Bool
  any :: forall (t :: * -> *) a. Foldable t => (a -> Bool) -> t a -> Bool
  appendFile :: FilePath -> String -> IO ()
  asTypeOf :: forall a. a -> a -> a
  break :: forall a. (a -> Bool) -> [a] -> ([a], [a])
  concat :: forall (t :: * -> *) a. Foldable t => t [a] -> [a]
  concatMap :: forall (t :: * -> *) a b. Foldable t => (a -> [b]) -> t a -> [b]
  const :: forall a b. a -> b -> a
  curry :: forall a b c. ((a, b) -> c) -> a -> b -> c
  cycle :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  drop :: forall a. Int -> [a] -> [a]
  dropWhile :: forall a. (a -> Bool) -> [a] -> [a]
  either :: forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
  error :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => [Char] -> a
  errorWithoutStackTrace :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r). [Char] -> a
  even :: forall a. Integral a => a -> Bool
  filter :: forall a. (a -> Bool) -> [a] -> [a]
  flip :: forall a b c. (a -> b -> c) -> b -> a -> c
  fromIntegral :: forall a b. (Integral a, Num b) => a -> b
  fst :: forall a b. (a, b) -> a
  gcd :: forall a. Integral a => a -> a -> a
  getChar :: IO Char
  getContents :: IO String
  getLine :: IO String
  head :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  id :: forall a. a -> a
  init :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  interact :: (String -> String) -> IO ()
  ioError :: forall a. IOError -> IO a
  iterate :: forall a. (a -> a) -> a -> [a]
  last :: forall a. GHC.Stack.Types.HasCallStack => [a] -> a
  lcm :: forall a. Integral a => a -> a -> a
  lex :: ReadS String
  lines :: String -> [String]
  lookup :: forall a b. Eq a => a -> [(a, b)] -> Maybe b
  map :: forall a b. (a -> b) -> [a] -> [b]
  mapM_ :: forall (t :: * -> *) (m :: * -> *) a b. (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
  maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
  not :: Bool -> Bool
  notElem :: forall (t :: * -> *) a. (Foldable t, Eq a) => a -> t a -> Bool
  odd :: forall a. Integral a => a -> Bool
  or :: forall (t :: * -> *). Foldable t => t Bool -> Bool
  otherwise :: Bool
  print :: forall a. Show a => a -> IO ()
  putChar :: Char -> IO ()
  putStr :: String -> IO ()
  putStrLn :: String -> IO ()
  read :: forall a. Read a => String -> a
  readFile :: FilePath -> IO String
  readIO :: forall a. Read a => String -> IO a
  readLn :: forall a. Read a => IO a
  readParen :: forall a. Bool -> ReadS a -> ReadS a
  reads :: forall a. Read a => ReadS a
  realToFrac :: forall a b. (Real a, Fractional b) => a -> b
  repeat :: forall a. a -> [a]
  replicate :: forall a. Int -> a -> [a]
  reverse :: forall a. [a] -> [a]
  scanl :: forall b a. (b -> a -> b) -> b -> [a] -> [b]
  scanl1 :: forall a. (a -> a -> a) -> [a] -> [a]
  scanr :: forall a b. (a -> b -> b) -> b -> [a] -> [b]
  scanr1 :: forall a. (a -> a -> a) -> [a] -> [a]
  seq :: forall {r :: GHC.Types.RuntimeRep} a (b :: TYPE r). a -> b -> b
  sequence_ :: forall (t :: * -> *) (m :: * -> *) a. (Foldable t, Monad m) => t (m a) -> m ()
  showChar :: Char -> ShowS
  showParen :: Bool -> ShowS -> ShowS
  showString :: String -> ShowS
  shows :: forall a. Show a => a -> ShowS
  snd :: forall a b. (a, b) -> b
  span :: forall a. (a -> Bool) -> [a] -> ([a], [a])
  splitAt :: forall a. Int -> [a] -> ([a], [a])
  subtract :: forall a. Num a => a -> a -> a
  tail :: forall a. GHC.Stack.Types.HasCallStack => [a] -> [a]
  take :: forall a. Int -> [a] -> [a]
  takeWhile :: forall a. (a -> Bool) -> [a] -> [a]
  uncurry :: forall a b c. (a -> b -> c) -> (a, b) -> c
  undefined :: forall (r :: GHC.Types.RuntimeRep) (a :: TYPE r). GHC.Stack.Types.HasCallStack => a
  unlines :: [String] -> String
  until :: forall a. (a -> Bool) -> (a -> a) -> a -> a
  unwords :: [String] -> String
  unzip :: forall a b. [(a, b)] -> ([a], [b])
  unzip3 :: forall a b c. [(a, b, c)] -> ([a], [b], [c])
  userError :: String -> IOError
  words :: String -> [String]
  writeFile :: FilePath -> String -> IO ()
  zip :: forall a b. [a] -> [b] -> [(a, b)]
  zip3 :: forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
  zipWith :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
  zipWith3 :: forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
  (||) :: Bool -> Bool -> Bool
  type (~) :: forall k. k -> k -> Constraint
  class (a ~ b) => (~) a b
    {-# MINIMAL #-}

module System.CPUTime where
  -- Safety: Trustworthy
  cpuTimePrecision :: GHC.Num.Integer.Integer
  getCPUTime :: GHC.Types.IO GHC.Num.Integer.Integer

module System.Console.GetOpt where
  -- Safety: Safe
  type ArgDescr :: * -> *
  data ArgDescr a = NoArg a | ReqArg (GHC.Base.String -> a) GHC.Base.String | OptArg (GHC.Maybe.Maybe GHC.Base.String -> a) GHC.Base.String
  type ArgOrder :: * -> *
  data ArgOrder a = RequireOrder | Permute | ReturnInOrder (GHC.Base.String -> a)
  type OptDescr :: * -> *
  data OptDescr a = Option [GHC.Types.Char] [GHC.Base.String] (ArgDescr a) GHC.Base.String
  getOpt :: forall a. ArgOrder a -> [OptDescr a] -> [GHC.Base.String] -> ([a], [GHC.Base.String], [GHC.Base.String])
  getOpt' :: forall a. ArgOrder a -> [OptDescr a] -> [GHC.Base.String] -> ([a], [GHC.Base.String], [GHC.Base.String], [GHC.Base.String])
  usageInfo :: forall a. GHC.Base.String -> [OptDescr a] -> GHC.Base.String

module System.Environment where
  -- Safety: Safe
  executablePath :: GHC.Maybe.Maybe (GHC.Types.IO (GHC.Maybe.Maybe GHC.IO.FilePath))
  getArgs :: GHC.Types.IO [GHC.Base.String]
  getEnv :: GHC.Base.String -> GHC.Types.IO GHC.Base.String
  getEnvironment :: GHC.Types.IO [(GHC.Base.String, GHC.Base.String)]
  getExecutablePath :: GHC.Types.IO GHC.IO.FilePath
  getProgName :: GHC.Types.IO GHC.Base.String
  lookupEnv :: GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  setEnv :: GHC.Base.String -> GHC.Base.String -> GHC.Types.IO ()
  unsetEnv :: GHC.Base.String -> GHC.Types.IO ()
  withArgs :: forall a. [GHC.Base.String] -> GHC.Types.IO a -> GHC.Types.IO a
  withProgName :: forall a. GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a

module System.Environment.Blank where
  -- Safety: Safe
  getArgs :: GHC.Types.IO [GHC.Base.String]
  getEnv :: GHC.Base.String -> GHC.Types.IO (GHC.Maybe.Maybe GHC.Base.String)
  getEnvDefault :: GHC.Base.String -> GHC.Base.String -> GHC.Types.IO GHC.Base.String
  getEnvironment :: GHC.Types.IO [(GHC.Base.String, GHC.Base.String)]
  getExecutablePath :: GHC.Types.IO GHC.IO.FilePath
  getProgName :: GHC.Types.IO GHC.Base.String
  setEnv :: GHC.Base.String -> GHC.Base.String -> GHC.Types.Bool -> GHC.Types.IO ()
  unsetEnv :: GHC.Base.String -> GHC.Types.IO ()
  withArgs :: forall a. [GHC.Base.String] -> GHC.Types.IO a -> GHC.Types.IO a
  withProgName :: forall a. GHC.Base.String -> GHC.Types.IO a -> GHC.Types.IO a

module System.Exit where
  -- Safety: Trustworthy
  type ExitCode :: *
  data ExitCode = ExitSuccess | ExitFailure GHC.Types.Int
  die :: forall a. GHC.Base.String -> GHC.Types.IO a
  exitFailure :: forall a. GHC.Types.IO a
  exitSuccess :: forall a. GHC.Types.IO a
  exitWith :: forall a. ExitCode -> GHC.Types.IO a

module System.IO where
  -- Safety: Trustworthy
  type BufferMode :: *
  data BufferMode = NoBuffering | LineBuffering | BlockBuffering (GHC.Maybe.Maybe GHC.Types.Int)
  type FilePath :: *
  type FilePath = GHC.Base.String
  type Handle :: *
  data Handle = ...
  type HandlePosn :: *
  data HandlePosn = ...
  type IO :: * -> *
  newtype IO a = ...
  type IOMode :: *
  data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
  type Newline :: *
  data Newline = LF | CRLF
  type NewlineMode :: *
  data NewlineMode = NewlineMode {inputNL :: Newline, outputNL :: Newline}
  type SeekMode :: *
  data SeekMode = AbsoluteSeek | RelativeSeek | SeekFromEnd
  type TextEncoding :: *
  data TextEncoding = ...
  appendFile :: FilePath -> GHC.Base.String -> IO ()
  char8 :: TextEncoding
  fixIO :: forall a. (a -> IO a) -> IO a
  getChar :: IO GHC.Types.Char
  getContents :: IO GHC.Base.String
  getContents' :: IO GHC.Base.String
  getLine :: IO GHC.Base.String
  hClose :: Handle -> IO ()
  hFileSize :: Handle -> IO GHC.Num.Integer.Integer
  hFlush :: Handle -> IO ()
  hGetBuf :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hGetBufNonBlocking :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hGetBufSome :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hGetBuffering :: Handle -> IO BufferMode
  hGetChar :: Handle -> IO GHC.Types.Char
  hGetContents :: Handle -> IO GHC.Base.String
  hGetContents' :: Handle -> IO GHC.Base.String
  hGetEcho :: Handle -> IO GHC.Types.Bool
  hGetEncoding :: Handle -> IO (GHC.Maybe.Maybe TextEncoding)
  hGetLine :: Handle -> IO GHC.Base.String
  hGetPosn :: Handle -> IO HandlePosn
  hIsClosed :: Handle -> IO GHC.Types.Bool
  hIsEOF :: Handle -> IO GHC.Types.Bool
  hIsOpen :: Handle -> IO GHC.Types.Bool
  hIsReadable :: Handle -> IO GHC.Types.Bool
  hIsSeekable :: Handle -> IO GHC.Types.Bool
  hIsTerminalDevice :: Handle -> IO GHC.Types.Bool
  hIsWritable :: Handle -> IO GHC.Types.Bool
  hLookAhead :: Handle -> IO GHC.Types.Char
  hPrint :: forall a. GHC.Show.Show a => Handle -> a -> IO ()
  hPutBuf :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO ()
  hPutBufNonBlocking :: forall a. Handle -> GHC.Ptr.Ptr a -> GHC.Types.Int -> IO GHC.Types.Int
  hPutChar :: Handle -> GHC.Types.Char -> IO ()
  hPutStr :: Handle -> GHC.Base.String -> IO ()
  hPutStrLn :: Handle -> GHC.Base.String -> IO ()
  hReady :: Handle -> IO GHC.Types.Bool
  hSeek :: Handle -> SeekMode -> GHC.Num.Integer.Integer -> IO ()
  hSetBinaryMode :: Handle -> GHC.Types.Bool -> IO ()
  hSetBuffering :: Handle -> BufferMode -> IO ()
  hSetEcho :: Handle -> GHC.Types.Bool -> IO ()
  hSetEncoding :: Handle -> TextEncoding -> IO ()
  hSetFileSize :: Handle -> GHC.Num.Integer.Integer -> IO ()
  hSetNewlineMode :: Handle -> NewlineMode -> IO ()
  hSetPosn :: HandlePosn -> IO ()
  hShow :: Handle -> IO GHC.Base.String
  hTell :: Handle -> IO GHC.Num.Integer.Integer
  hWaitForInput :: Handle -> GHC.Types.Int -> IO GHC.Types.Bool
  interact :: (GHC.Base.String -> GHC.Base.String) -> IO ()
  isEOF :: IO GHC.Types.Bool
  latin1 :: TextEncoding
  localeEncoding :: TextEncoding
  mkTextEncoding :: GHC.Base.String -> IO TextEncoding
  nativeNewline :: Newline
  nativeNewlineMode :: NewlineMode
  noNewlineTranslation :: NewlineMode
  openBinaryFile :: FilePath -> IOMode -> IO Handle
  openBinaryTempFile :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  openBinaryTempFileWithDefaultPermissions :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  openFile :: FilePath -> IOMode -> IO Handle
  openTempFile :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  openTempFileWithDefaultPermissions :: FilePath -> GHC.Base.String -> IO (FilePath, Handle)
  print :: forall a. GHC.Show.Show a => a -> IO ()
  putChar :: GHC.Types.Char -> IO ()
  putStr :: GHC.Base.String -> IO ()
  putStrLn :: GHC.Base.String -> IO ()
  readFile :: FilePath -> IO GHC.Base.String
  readFile' :: FilePath -> IO GHC.Base.String
  readIO :: forall a. GHC.Read.Read a => GHC.Base.String -> IO a
  readLn :: forall a. GHC.Read.Read a => IO a
  stderr :: Handle
  stdin :: Handle
  stdout :: Handle
  universalNewlineMode :: NewlineMode
  utf16 :: TextEncoding
  utf16be :: TextEncoding
  utf16le :: TextEncoding
  utf32 :: TextEncoding
  utf32be :: TextEncoding
  utf32le :: TextEncoding
  utf8 :: TextEncoding
  utf8_bom :: TextEncoding
  withBinaryFile :: forall r. FilePath -> IOMode -> (Handle -> IO r) -> IO r
  withFile :: forall r. FilePath -> IOMode -> (Handle -> IO r) -> IO r
  writeFile :: FilePath -> GHC.Base.String -> IO ()

module System.IO.Error where
  -- Safety: Trustworthy
  type IOError :: *
  type IOError = GHC.IO.Exception.IOException
  type IOErrorType :: *
  data IOErrorType = ...
  alreadyExistsErrorType :: IOErrorType
  alreadyInUseErrorType :: IOErrorType
  annotateIOError :: IOError -> GHC.Base.String -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.IO.FilePath -> IOError
  catchIOError :: forall a. GHC.Types.IO a -> (IOError -> GHC.Types.IO a) -> GHC.Types.IO a
  doesNotExistErrorType :: IOErrorType
  eofErrorType :: IOErrorType
  fullErrorType :: IOErrorType
  illegalOperationErrorType :: IOErrorType
  ioError :: forall a. IOError -> GHC.Types.IO a
  ioeGetErrorString :: IOError -> GHC.Base.String
  ioeGetErrorType :: IOError -> IOErrorType
  ioeGetFileName :: IOError -> GHC.Maybe.Maybe GHC.IO.FilePath
  ioeGetHandle :: IOError -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle
  ioeGetLocation :: IOError -> GHC.Base.String
  ioeSetErrorString :: IOError -> GHC.Base.String -> IOError
  ioeSetErrorType :: IOError -> IOErrorType -> IOError
  ioeSetFileName :: IOError -> GHC.IO.FilePath -> IOError
  ioeSetHandle :: IOError -> GHC.IO.Handle.Types.Handle -> IOError
  ioeSetLocation :: IOError -> GHC.Base.String -> IOError
  isAlreadyExistsError :: IOError -> GHC.Types.Bool
  isAlreadyExistsErrorType :: IOErrorType -> GHC.Types.Bool
  isAlreadyInUseError :: IOError -> GHC.Types.Bool
  isAlreadyInUseErrorType :: IOErrorType -> GHC.Types.Bool
  isDoesNotExistError :: IOError -> GHC.Types.Bool
  isDoesNotExistErrorType :: IOErrorType -> GHC.Types.Bool
  isEOFError :: IOError -> GHC.Types.Bool
  isEOFErrorType :: IOErrorType -> GHC.Types.Bool
  isFullError :: IOError -> GHC.Types.Bool
  isFullErrorType :: IOErrorType -> GHC.Types.Bool
  isIllegalOperation :: IOError -> GHC.Types.Bool
  isIllegalOperationErrorType :: IOErrorType -> GHC.Types.Bool
  isPermissionError :: IOError -> GHC.Types.Bool
  isPermissionErrorType :: IOErrorType -> GHC.Types.Bool
  isResourceVanishedError :: IOError -> GHC.Types.Bool
  isResourceVanishedErrorType :: IOErrorType -> GHC.Types.Bool
  isUserError :: IOError -> GHC.Types.Bool
  isUserErrorType :: IOErrorType -> GHC.Types.Bool
  mkIOError :: IOErrorType -> GHC.Base.String -> GHC.Maybe.Maybe GHC.IO.Handle.Types.Handle -> GHC.Maybe.Maybe GHC.IO.FilePath -> IOError
  modifyIOError :: forall a. (IOError -> IOError) -> GHC.Types.IO a -> GHC.Types.IO a
  permissionErrorType :: IOErrorType
  resourceVanishedErrorType :: IOErrorType
  tryIOError :: forall a. GHC.Types.IO a -> GHC.Types.IO (Data.Either.Either IOError a)
  userError :: GHC.Base.String -> IOError
  userErrorType :: IOErrorType

module System.IO.Unsafe where
  -- Safety: Unsafe
  unsafeDupablePerformIO :: forall a. GHC.Types.IO a -> a
  unsafeFixIO :: forall a. (a -> GHC.Types.IO a) -> GHC.Types.IO a
  unsafeInterleaveIO :: forall a. GHC.Types.IO a -> GHC.Types.IO a
  unsafePerformIO :: forall a. GHC.Types.IO a -> a

module System.Info where
  -- Safety: Safe
  arch :: GHC.Base.String
  compilerName :: GHC.Base.String
  compilerVersion :: Data.Version.Version
  fullCompilerVersion :: Data.Version.Version
  os :: GHC.Base.String

module System.Mem where
  -- Safety: Trustworthy
  disableAllocationLimit :: GHC.Types.IO ()
  enableAllocationLimit :: GHC.Types.IO ()
  getAllocationCounter :: GHC.Types.IO GHC.Int.Int64
  performGC :: GHC.Types.IO ()
  performMajorGC :: GHC.Types.IO ()
  performMinorGC :: GHC.Types.IO ()
  setAllocationCounter :: GHC.Int.Int64 -> GHC.Types.IO ()

module System.Mem.StableName where
  -- Safety: Safe
  type role StableName phantom
  type StableName :: * -> *
  data StableName a = ...
  eqStableName :: forall a b. StableName a -> StableName b -> GHC.Types.Bool
  hashStableName :: forall a. StableName a -> GHC.Types.Int
  makeStableName :: forall a. a -> GHC.Types.IO (StableName a)

module System.Mem.Weak where
  -- Safety: Trustworthy
  type Weak :: * -> *
  data Weak v = ...
  addFinalizer :: forall key. key -> GHC.Types.IO () -> GHC.Types.IO ()
  deRefWeak :: forall v. Weak v -> GHC.Types.IO (GHC.Maybe.Maybe v)
  finalize :: forall v. Weak v -> GHC.Types.IO ()
  getFinalizerExceptionHandler :: GHC.Types.IO (GHC.Exception.Type.SomeException -> GHC.Types.IO ())
  mkWeak :: forall k v. k -> v -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak v)
  mkWeakPair :: forall k v. k -> v -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak (k, v))
  mkWeakPtr :: forall k. k -> GHC.Maybe.Maybe (GHC.Types.IO ()) -> GHC.Types.IO (Weak k)
  printToHandleFinalizerExceptionHandler :: GHC.IO.Handle.Types.Handle -> GHC.Exception.Type.SomeException -> GHC.Types.IO ()
  setFinalizerExceptionHandler :: (GHC.Exception.Type.SomeException -> GHC.Types.IO ()) -> GHC.Types.IO ()

module System.Posix.Internals where
  -- Safety: Trustworthy
  type CFLock :: *
  data CFLock
  type CFilePath :: *
  type CFilePath = base-4.18.0.0:GHC.Foreign.Internal.CString
  type CGroup :: *
  data CGroup
  type CLconv :: *
  data CLconv
  type CPasswd :: *
  data CPasswd
  type CSigaction :: *
  data CSigaction
  type CSigset :: *
  data CSigset
  type CStat :: *
  data CStat
  type CTermios :: *
  data CTermios
  type CTm :: *
  data CTm
  type CTms :: *
  data CTms
  type CUtimbuf :: *
  data CUtimbuf
  type CUtsname :: *
  data CUtsname
  type FD :: *
  type FD = Foreign.C.Types.CInt
  c_access :: base-4.18.0.0:GHC.Foreign.Internal.CString -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_chmod :: base-4.18.0.0:GHC.Foreign.Internal.CString -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_close :: Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_creat :: base-4.18.0.0:GHC.Foreign.Internal.CString -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_dup :: Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_dup2 :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_fcntl_lock :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Ptr.Ptr CFLock -> GHC.Types.IO Foreign.C.Types.CInt
  c_fcntl_read :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_fcntl_write :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> Foreign.C.Types.CLong -> GHC.Types.IO Foreign.C.Types.CInt
  c_fork :: GHC.Types.IO System.Posix.Types.CPid
  c_fstat :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CInt
  c_ftruncate :: Foreign.C.Types.CInt -> System.Posix.Types.COff -> GHC.Types.IO Foreign.C.Types.CInt
  c_getpid :: GHC.Types.IO System.Posix.Types.CPid
  c_interruptible_open :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_interruptible_open_ :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_isatty :: Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_lflag :: GHC.Ptr.Ptr CTermios -> GHC.Types.IO System.Posix.Types.CTcflag
  c_link :: base-4.18.0.0:GHC.Foreign.Internal.CString -> base-4.18.0.0:GHC.Foreign.Internal.CString -> GHC.Types.IO Foreign.C.Types.CInt
  c_lseek :: Foreign.C.Types.CInt -> System.Posix.Types.COff -> Foreign.C.Types.CInt -> GHC.Types.IO System.Posix.Types.COff
  c_mkfifo :: base-4.18.0.0:GHC.Foreign.Internal.CString -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_open :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_pipe :: GHC.Ptr.Ptr Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_read :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  c_s_isblk :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_ischr :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_isdir :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_isfifo :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_isreg :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_s_issock :: System.Posix.Types.CMode -> Foreign.C.Types.CInt
  c_safe_open :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_safe_open_ :: CFilePath -> Foreign.C.Types.CInt -> System.Posix.Types.CMode -> GHC.Types.IO Foreign.C.Types.CInt
  c_safe_read :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  c_safe_write :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  c_sigaddset :: GHC.Ptr.Ptr CSigset -> Foreign.C.Types.CInt -> GHC.Types.IO Foreign.C.Types.CInt
  c_sigemptyset :: GHC.Ptr.Ptr CSigset -> GHC.Types.IO Foreign.C.Types.CInt
  c_sigprocmask :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CSigset -> GHC.Ptr.Ptr CSigset -> GHC.Types.IO Foreign.C.Types.CInt
  c_stat :: CFilePath -> GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CInt
  c_tcgetattr :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CTermios -> GHC.Types.IO Foreign.C.Types.CInt
  c_tcsetattr :: Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Ptr.Ptr CTermios -> GHC.Types.IO Foreign.C.Types.CInt
  c_umask :: System.Posix.Types.CMode -> GHC.Types.IO System.Posix.Types.CMode
  c_unlink :: base-4.18.0.0:GHC.Foreign.Internal.CString -> GHC.Types.IO Foreign.C.Types.CInt
  c_utime :: base-4.18.0.0:GHC.Foreign.Internal.CString -> GHC.Ptr.Ptr CUtimbuf -> GHC.Types.IO Foreign.C.Types.CInt
  c_waitpid :: System.Posix.Types.CPid -> GHC.Ptr.Ptr Foreign.C.Types.CInt -> Foreign.C.Types.CInt -> GHC.Types.IO System.Posix.Types.CPid
  c_write :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr GHC.Word.Word8 -> Foreign.C.Types.CSize -> GHC.Types.IO System.Posix.Types.CSsize
  checkForInteriorNuls :: GHC.IO.FilePath -> base-4.18.0.0:GHC.Foreign.Internal.CStringLen -> GHC.Types.IO ()
  const_echo :: Foreign.C.Types.CInt
  const_f_getfl :: Foreign.C.Types.CInt
  const_f_setfd :: Foreign.C.Types.CInt
  const_f_setfl :: Foreign.C.Types.CInt
  const_fd_cloexec :: Foreign.C.Types.CLong
  const_icanon :: Foreign.C.Types.CInt
  const_sig_block :: Foreign.C.Types.CInt
  const_sig_setmask :: Foreign.C.Types.CInt
  const_sigttou :: Foreign.C.Types.CInt
  const_tcsanow :: Foreign.C.Types.CInt
  const_vmin :: Foreign.C.Types.CInt
  const_vtime :: Foreign.C.Types.CInt
  dEFAULT_BUFFER_SIZE :: GHC.Types.Int
  fdFileSize :: FD -> GHC.Types.IO GHC.Num.Integer.Integer
  fdGetMode :: FD -> GHC.Types.IO GHC.IO.IOMode.IOMode
  fdStat :: FD -> GHC.Types.IO (GHC.IO.Device.IODeviceType, System.Posix.Types.CDev, System.Posix.Types.CIno)
  fdType :: FD -> GHC.Types.IO GHC.IO.Device.IODeviceType
  fileType :: GHC.IO.FilePath -> GHC.Types.IO GHC.IO.Device.IODeviceType
  getEcho :: FD -> GHC.Types.IO GHC.Types.Bool
  get_saved_termios :: Foreign.C.Types.CInt -> GHC.Types.IO (GHC.Ptr.Ptr CTermios)
  hostIsThreaded :: GHC.Types.Bool
  ioe_unknownfiletype :: GHC.IO.Exception.IOException
  lstat :: CFilePath -> GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CInt
  newFilePath :: GHC.IO.FilePath -> GHC.Types.IO base-4.18.0.0:GHC.Foreign.Internal.CString
  o_APPEND :: Foreign.C.Types.CInt
  o_BINARY :: Foreign.C.Types.CInt
  o_CREAT :: Foreign.C.Types.CInt
  o_EXCL :: Foreign.C.Types.CInt
  o_NOCTTY :: Foreign.C.Types.CInt
  o_NONBLOCK :: Foreign.C.Types.CInt
  o_RDONLY :: Foreign.C.Types.CInt
  o_RDWR :: Foreign.C.Types.CInt
  o_TRUNC :: Foreign.C.Types.CInt
  o_WRONLY :: Foreign.C.Types.CInt
  peekFilePath :: base-4.18.0.0:GHC.Foreign.Internal.CString -> GHC.Types.IO GHC.IO.FilePath
  peekFilePathLen :: base-4.18.0.0:GHC.Foreign.Internal.CStringLen -> GHC.Types.IO GHC.IO.FilePath
  poke_c_lflag :: GHC.Ptr.Ptr CTermios -> System.Posix.Types.CTcflag -> GHC.Types.IO ()
  ptr_c_cc :: GHC.Ptr.Ptr CTermios -> GHC.Types.IO (GHC.Ptr.Ptr GHC.Word.Word8)
  puts :: GHC.Base.String -> GHC.Types.IO ()
  rtsIsThreaded_ :: GHC.Types.Int
  sEEK_CUR :: Foreign.C.Types.CInt
  sEEK_END :: Foreign.C.Types.CInt
  sEEK_SET :: Foreign.C.Types.CInt
  s_isblk :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_ischr :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_isdir :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_isfifo :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_isreg :: System.Posix.Types.CMode -> GHC.Types.Bool
  s_issock :: System.Posix.Types.CMode -> GHC.Types.Bool
  setCloseOnExec :: FD -> GHC.Types.IO ()
  setCooked :: FD -> GHC.Types.Bool -> GHC.Types.IO ()
  setEcho :: FD -> GHC.Types.Bool -> GHC.Types.IO ()
  setNonBlockingFD :: FD -> GHC.Types.Bool -> GHC.Types.IO ()
  set_saved_termios :: Foreign.C.Types.CInt -> GHC.Ptr.Ptr CTermios -> GHC.Types.IO ()
  sizeof_sigset_t :: GHC.Types.Int
  sizeof_stat :: GHC.Types.Int
  sizeof_termios :: GHC.Types.Int
  st_dev :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.CDev
  st_ino :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.CIno
  st_mode :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.CMode
  st_mtime :: GHC.Ptr.Ptr CStat -> GHC.Types.IO Foreign.C.Types.CTime
  st_size :: GHC.Ptr.Ptr CStat -> GHC.Types.IO System.Posix.Types.COff
  statGetType :: GHC.Ptr.Ptr CStat -> GHC.Types.IO GHC.IO.Device.IODeviceType
  tcSetAttr :: forall a. FD -> (GHC.Ptr.Ptr CTermios -> GHC.Types.IO a) -> GHC.Types.IO a
  throwInternalNulError :: forall a. GHC.IO.FilePath -> GHC.Types.IO a
  withFilePath :: forall a. GHC.IO.FilePath -> (base-4.18.0.0:GHC.Foreign.Internal.CString -> GHC.Types.IO a) -> GHC.Types.IO a

module System.Posix.Types where

-- ignored


module System.Timeout where
  -- Safety: Safe
  type Timeout :: *
  newtype Timeout = ...
  timeout :: forall a. GHC.Types.Int -> GHC.Types.IO a -> GHC.Types.IO (GHC.Maybe.Maybe a)

module Text.ParserCombinators.ReadP where
  -- Safety: Trustworthy
  (+++) :: forall a. ReadP a -> ReadP a -> ReadP a
  (<++) :: forall a. ReadP a -> ReadP a -> ReadP a
  type ReadP :: * -> *
  newtype ReadP a = ...
  type ReadS :: * -> *
  type ReadS a = GHC.Base.String -> [(a, GHC.Base.String)]
  between :: forall open close a. ReadP open -> ReadP close -> ReadP a -> ReadP a
  chainl :: forall a. ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainl1 :: forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a
  chainr :: forall a. ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
  chainr1 :: forall a. ReadP a -> ReadP (a -> a -> a) -> ReadP a
  char :: GHC.Types.Char -> ReadP GHC.Types.Char
  choice :: forall a. [ReadP a] -> ReadP a
  count :: forall a. GHC.Types.Int -> ReadP a -> ReadP [a]
  endBy :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
  endBy1 :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
  eof :: ReadP ()
  gather :: forall a. ReadP a -> ReadP (GHC.Base.String, a)
  get :: ReadP GHC.Types.Char
  look :: ReadP GHC.Base.String
  many :: forall a. ReadP a -> ReadP [a]
  many1 :: forall a. ReadP a -> ReadP [a]
  manyTill :: forall a end. ReadP a -> ReadP end -> ReadP [a]
  munch :: (GHC.Types.Char -> GHC.Types.Bool) -> ReadP GHC.Base.String
  munch1 :: (GHC.Types.Char -> GHC.Types.Bool) -> ReadP GHC.Base.String
  option :: forall a. a -> ReadP a -> ReadP a
  optional :: forall a. ReadP a -> ReadP ()
  pfail :: forall a. ReadP a
  readP_to_S :: forall a. ReadP a -> ReadS a
  readS_to_P :: forall a. ReadS a -> ReadP a
  satisfy :: (GHC.Types.Char -> GHC.Types.Bool) -> ReadP GHC.Types.Char
  sepBy :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
  sepBy1 :: forall a sep. ReadP a -> ReadP sep -> ReadP [a]
  skipMany :: forall a. ReadP a -> ReadP ()
  skipMany1 :: forall a. ReadP a -> ReadP ()
  skipSpaces :: ReadP ()
  string :: GHC.Base.String -> ReadP GHC.Base.String

module Text.ParserCombinators.ReadPrec where
  -- Safety: Trustworthy
  (+++) :: forall a. ReadPrec a -> ReadPrec a -> ReadPrec a
  (<++) :: forall a. ReadPrec a -> ReadPrec a -> ReadPrec a
  type Prec :: *
  type Prec = GHC.Types.Int
  type ReadPrec :: * -> *
  newtype ReadPrec a = ...
  choice :: forall a. [ReadPrec a] -> ReadPrec a
  get :: ReadPrec GHC.Types.Char
  lift :: forall a. Text.ParserCombinators.ReadP.ReadP a -> ReadPrec a
  look :: ReadPrec GHC.Base.String
  minPrec :: Prec
  pfail :: forall a. ReadPrec a
  prec :: forall a. Prec -> ReadPrec a -> ReadPrec a
  readP_to_Prec :: forall a. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a) -> ReadPrec a
  readPrec_to_P :: forall a. ReadPrec a -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
  readPrec_to_S :: forall a. ReadPrec a -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a
  readS_to_Prec :: forall a. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS a) -> ReadPrec a
  reset :: forall a. ReadPrec a -> ReadPrec a
  step :: forall a. ReadPrec a -> ReadPrec a

module Text.Printf where
  -- Safety: Safe
  type FieldFormat :: *
  data FieldFormat = FieldFormat {fmtWidth :: GHC.Maybe.Maybe GHC.Types.Int, fmtPrecision :: GHC.Maybe.Maybe GHC.Types.Int, fmtAdjust :: GHC.Maybe.Maybe FormatAdjustment, fmtSign :: GHC.Maybe.Maybe FormatSign, fmtAlternate :: GHC.Types.Bool, fmtModifiers :: GHC.Base.String, fmtChar :: GHC.Types.Char}
  type FieldFormatter :: *
  type FieldFormatter = FieldFormat -> GHC.Show.ShowS
  type FormatAdjustment :: *
  data FormatAdjustment = LeftAdjust | ZeroPad
  type FormatParse :: *
  data FormatParse = FormatParse {fpModifiers :: GHC.Base.String, fpChar :: GHC.Types.Char, fpRest :: GHC.Base.String}
  type FormatSign :: *
  data FormatSign = SignPlus | SignSpace
  type HPrintfType :: * -> Constraint
  class HPrintfType t where
    ...
    {-# MINIMAL Text.Printf.hspr #-}
  type IsChar :: * -> Constraint
  class IsChar c where
    toChar :: c -> GHC.Types.Char
    fromChar :: GHC.Types.Char -> c
    {-# MINIMAL toChar, fromChar #-}
  type ModifierParser :: *
  type ModifierParser = GHC.Base.String -> FormatParse
  type PrintfArg :: * -> Constraint
  class PrintfArg a where
    formatArg :: a -> FieldFormatter
    parseFormat :: a -> ModifierParser
    {-# MINIMAL formatArg #-}
  type PrintfType :: * -> Constraint
  class PrintfType t where
    ...
    {-# MINIMAL Text.Printf.spr #-}
  errorBadArgument :: forall a. a
  errorBadFormat :: forall a. GHC.Types.Char -> a
  errorMissingArgument :: forall a. a
  errorShortFormat :: forall a. a
  formatChar :: GHC.Types.Char -> FieldFormatter
  formatInt :: forall a. (GHC.Real.Integral a, GHC.Enum.Bounded a) => a -> FieldFormatter
  formatInteger :: GHC.Num.Integer.Integer -> FieldFormatter
  formatRealFloat :: forall a. GHC.Float.RealFloat a => a -> FieldFormatter
  formatString :: forall a. IsChar a => [a] -> FieldFormatter
  hPrintf :: forall r. HPrintfType r => GHC.IO.Handle.Types.Handle -> GHC.Base.String -> r
  perror :: forall a. GHC.Base.String -> a
  printf :: forall r. PrintfType r => GHC.Base.String -> r
  vFmt :: GHC.Types.Char -> FieldFormat -> FieldFormat

module Text.Read where
  -- Safety: Trustworthy
  (+++) :: forall a. ReadPrec a -> ReadPrec a -> ReadPrec a
  (<++) :: forall a. ReadPrec a -> ReadPrec a -> ReadPrec a
  type Lexeme :: *
  data Lexeme = Char GHC.Types.Char | String GHC.Base.String | Punc GHC.Base.String | Ident GHC.Base.String | Symbol GHC.Base.String | Number Text.Read.Lex.Number | EOF
  type Prec :: *
  type Prec = GHC.Types.Int
  type Read :: * -> Constraint
  class Read a where
    readsPrec :: GHC.Types.Int -> ReadS a
    readList :: ReadS [a]
    readPrec :: ReadPrec a
    readListPrec :: ReadPrec [a]
    {-# MINIMAL readsPrec | readPrec #-}
  type ReadPrec :: * -> *
  newtype ReadPrec a = ...
  type ReadS :: * -> *
  type ReadS a = GHC.Base.String -> [(a, GHC.Base.String)]
  choice :: forall a. [ReadPrec a] -> ReadPrec a
  get :: ReadPrec GHC.Types.Char
  lex :: ReadS GHC.Base.String
  lexP :: ReadPrec Lexeme
  lift :: forall a. Text.ParserCombinators.ReadP.ReadP a -> ReadPrec a
  look :: ReadPrec GHC.Base.String
  minPrec :: Prec
  parens :: forall a. ReadPrec a -> ReadPrec a
  pfail :: forall a. ReadPrec a
  prec :: forall a. Prec -> ReadPrec a -> ReadPrec a
  read :: forall a. Read a => GHC.Base.String -> a
  readEither :: forall a. Read a => GHC.Base.String -> Data.Either.Either GHC.Base.String a
  readListDefault :: forall a. Read a => ReadS [a]
  readListPrecDefault :: forall a. Read a => ReadPrec [a]
  readMaybe :: forall a. Read a => GHC.Base.String -> GHC.Maybe.Maybe a
  readP_to_Prec :: forall a. (GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a) -> ReadPrec a
  readParen :: forall a. GHC.Types.Bool -> ReadS a -> ReadS a
  readPrec_to_P :: forall a. ReadPrec a -> GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadP a
  readPrec_to_S :: forall a. ReadPrec a -> GHC.Types.Int -> ReadS a
  readS_to_Prec :: forall a. (GHC.Types.Int -> ReadS a) -> ReadPrec a
  reads :: forall a. Read a => ReadS a
  reset :: forall a. ReadPrec a -> ReadPrec a
  step :: forall a. ReadPrec a -> ReadPrec a

module Text.Read.Lex where
  -- Safety: Trustworthy
  type Lexeme :: *
  data Lexeme = Char GHC.Types.Char | String GHC.Base.String | Punc GHC.Base.String | Ident GHC.Base.String | Symbol GHC.Base.String | Number Number | EOF
  type Number :: *
  data Number = ...
  expect :: Lexeme -> Text.ParserCombinators.ReadP.ReadP ()
  hsLex :: Text.ParserCombinators.ReadP.ReadP GHC.Base.String
  isSymbolChar :: GHC.Types.Char -> GHC.Types.Bool
  lex :: Text.ParserCombinators.ReadP.ReadP Lexeme
  lexChar :: Text.ParserCombinators.ReadP.ReadP GHC.Types.Char
  numberToFixed :: GHC.Num.Integer.Integer -> Number -> GHC.Maybe.Maybe (GHC.Num.Integer.Integer, GHC.Num.Integer.Integer)
  numberToInteger :: Number -> GHC.Maybe.Maybe GHC.Num.Integer.Integer
  numberToRangedRational :: (GHC.Types.Int, GHC.Types.Int) -> Number -> GHC.Maybe.Maybe GHC.Real.Rational
  numberToRational :: Number -> GHC.Real.Rational
  readBinP :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a
  readDecP :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a
  readHexP :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a
  readIntP :: forall a. GHC.Num.Num a => a -> (GHC.Types.Char -> GHC.Types.Bool) -> (GHC.Types.Char -> GHC.Types.Int) -> Text.ParserCombinators.ReadP.ReadP a
  readOctP :: forall a. (GHC.Classes.Eq a, GHC.Num.Num a) => Text.ParserCombinators.ReadP.ReadP a

module Text.Show where
  -- Safety: Safe
  type Show :: * -> Constraint
  class Show a where
    showsPrec :: GHC.Types.Int -> a -> ShowS
    show :: a -> GHC.Base.String
    showList :: [a] -> ShowS
    {-# MINIMAL showsPrec | show #-}
  type ShowS :: *
  type ShowS = GHC.Base.String -> GHC.Base.String
  showChar :: GHC.Types.Char -> ShowS
  showListWith :: forall a. (a -> ShowS) -> [a] -> ShowS
  showParen :: GHC.Types.Bool -> ShowS -> ShowS
  showString :: GHC.Base.String -> ShowS
  shows :: forall a. Show a => a -> ShowS

module Text.Show.Functions where
  -- Safety: Safe

module Type.Reflection where
  -- Safety: Trustworthy
  type role (:~:) nominal nominal
  type (:~:) :: forall {k}. k -> k -> *
  data (:~:) a b where
    Refl :: forall {k} (a :: k). (:~:) a a
  type role (:~~:) nominal nominal
  type (:~~:) :: forall k1 k2. k1 -> k2 -> *
  data (:~~:) a b where
    HRefl :: forall {k1} (a :: k1). (:~~:) a a
  pattern App :: forall k2 (t :: k2). () => forall k1 (a :: k1 -> k2) (b :: k1). (t ~ a b) => TypeRep a -> TypeRep b -> TypeRep t
  pattern Con :: forall k (a :: k). () => base-4.18.0.0:Data.Typeable.Internal.NotApplication a => TyCon -> TypeRep a
  pattern Con' :: forall k (a :: k). () => base-4.18.0.0:Data.Typeable.Internal.NotApplication a => TyCon -> [SomeTypeRep] -> TypeRep a
  pattern Fun :: forall k (fun :: k). () => forall (r1 :: GHC.Types.RuntimeRep) (r2 :: GHC.Types.RuntimeRep) (arg :: TYPE r1) (res :: TYPE r2). (k ~ *, fun ~~ (arg -> res)) => TypeRep arg -> TypeRep res -> TypeRep fun
  type Module :: *
  data Module = ...
  type SomeTypeRep :: *
  data SomeTypeRep where
    SomeTypeRep :: forall k (a :: k). !(TypeRep a) -> SomeTypeRep
  type TyCon :: *
  data TyCon = ...
  pattern TypeRep :: forall {k} (a :: k). () => Typeable a => TypeRep a
  type role TypeRep nominal
  type TypeRep :: forall k. k -> *
  data TypeRep a where
    ...
  type Typeable :: forall k. k -> Constraint
  class Typeable a where
    ...
    {-# MINIMAL base-4.18.0.0:Data.Typeable.Internal.typeRep# #-}
  decTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> Data.Either.Either ((a :~~: b) -> GHC.Base.Void) (a :~~: b)
  eqTypeRep :: forall k1 k2 (a :: k1) (b :: k2). TypeRep a -> TypeRep b -> GHC.Maybe.Maybe (a :~~: b)
  moduleName :: Module -> GHC.Base.String
  modulePackage :: Module -> GHC.Base.String
  rnfModule :: Module -> ()
  rnfSomeTypeRep :: SomeTypeRep -> ()
  rnfTyCon :: TyCon -> ()
  rnfTypeRep :: forall {k} (a :: k). TypeRep a -> ()
  someTypeRep :: forall {k} (proxy :: k -> *) (a :: k). Typeable a => proxy a -> SomeTypeRep
  someTypeRepTyCon :: SomeTypeRep -> TyCon
  splitApps :: forall {k} (a :: k). TypeRep a -> (TyCon, [SomeTypeRep])
  tyConModule :: TyCon -> GHC.Base.String
  tyConName :: TyCon -> GHC.Base.String
  tyConPackage :: TyCon -> GHC.Base.String
  typeOf :: forall a. Typeable a => a -> TypeRep a
  typeRep :: forall {k} (a :: k). Typeable a => TypeRep a
  typeRepKind :: forall k (a :: k). TypeRep a -> TypeRep k
  typeRepTyCon :: forall {k} (a :: k). TypeRep a -> TyCon
  withTypeable :: forall k (a :: k) (rep :: GHC.Types.RuntimeRep) (r :: TYPE rep). TypeRep a -> (Typeable a => r) -> r

module Type.Reflection.Unsafe where
  -- Safety: Unsafe
  type KindRep :: *
  data KindRep = KindRepTyConApp TyCon [KindRep] | KindRepVar {-# UNPACK #-}GHC.Types.KindBndr | KindRepApp KindRep KindRep | KindRepFun KindRep KindRep | KindRepTYPE !GHC.Types.RuntimeRep | KindRepTypeLitS TypeLitSort GHC.Prim.Addr# | KindRepTypeLitD TypeLitSort [GHC.Types.Char]
  pattern KindRepTypeLit :: TypeLitSort -> GHC.Base.String -> KindRep
  type TyCon :: *
  data TyCon = ...
  type TypeLitSort :: *
  data TypeLitSort = TypeLitSymbol | TypeLitNat | TypeLitChar
  type role TypeRep nominal
  type TypeRep :: forall k. k -> *
  data TypeRep a where
    ...
  mkTrApp :: forall k1 k2 (a :: k1 -> k2) (b :: k1). TypeRep a -> TypeRep b -> TypeRep (a b)
  mkTrCon :: forall k (a :: k). TyCon -> [base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep] -> TypeRep a
  mkTyCon :: GHC.Base.String -> GHC.Base.String -> GHC.Base.String -> GHC.Types.Int -> KindRep -> TyCon
  someTypeRepFingerprint :: base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -> GHC.Fingerprint.Type.Fingerprint
  tyConFingerprint :: TyCon -> GHC.Fingerprint.Type.Fingerprint
  tyConKindArgs :: TyCon -> GHC.Types.Int
  tyConKindRep :: TyCon -> KindRep
  typeRepFingerprint :: forall {k} (a :: k). TypeRep a -> GHC.Fingerprint.Type.Fingerprint

module Unsafe.Coerce where
  -- Safety: Unsafe
  type role UnsafeEquality nominal nominal
  type UnsafeEquality :: forall {k}. k -> k -> *
  data UnsafeEquality a b where
    UnsafeRefl :: forall {k} (a :: k). UnsafeEquality a a
  unsafeCoerce :: forall a b. a -> b
  unsafeCoerce# :: forall (q :: GHC.Types.RuntimeRep) (r :: GHC.Types.RuntimeRep) (a :: TYPE q) (b :: TYPE r). a -> b
  unsafeCoerceAddr :: forall (a :: TYPE GHC.Types.AddrRep) (b :: TYPE GHC.Types.AddrRep). a -> b
  unsafeCoerceUnlifted :: forall (a :: GHC.Types.UnliftedType) (b :: GHC.Types.UnliftedType). a -> b
  unsafeEqualityProof :: forall {k} (a :: k) (b :: k). UnsafeEquality a b


-- Instances:
instance forall (m :: * -> *). GHC.Base.Monad m => Control.Arrow.Arrow (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *). GHC.Base.Monad m => Control.Arrow.ArrowApply (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *). GHC.Base.Monad m => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *). Control.Monad.Fix.MonadFix m => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *). GHC.Base.MonadPlus m => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *). GHC.Base.MonadPlus m => Control.Arrow.ArrowZero (Control.Arrow.Kleisli m) -- Defined in ‘Control.Arrow’
instance forall k. Control.Category.Category (Data.Type.Equality.:~:) -- Defined in ‘Control.Category’
instance forall k. Control.Category.Category (Data.Type.Equality.:~~:) -- Defined in ‘Control.Category’
instance forall k. Control.Category.Category Data.Type.Coercion.Coercion -- Defined in ‘Control.Category’
instance Control.Monad.Fail.MonadFail GHC.Types.IO -- Defined in ‘Control.Monad.Fail’
instance Control.Monad.Fail.MonadFail [] -- Defined in ‘Control.Monad.Fail’
instance Control.Monad.Fail.MonadFail GHC.Maybe.Maybe -- Defined in ‘Control.Monad.Fail’
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance Control.Monad.Fail.MonadFail Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance Control.Monad.Fix.MonadFix Data.Ord.Down -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Control.Monad.Fix’
instance forall e. Control.Monad.Fix.MonadFix (Data.Either.Either e) -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix Data.Monoid.First -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Types.IO -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix Data.Monoid.Last -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix [] -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Maybe.Maybe -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Base.NonEmpty -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix GHC.Generics.Par1 -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Control.Monad.Fix’
instance forall s. Control.Monad.Fix.MonadFix (GHC.ST.ST s) -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix Solo -- Defined in ‘Control.Monad.Fix’
instance Control.Monad.Fix.MonadFix base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Control.Monad.Fix’
instance forall s. Control.Monad.Fix.MonadFix (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance Control.Monad.Fix.MonadFix Data.Complex.Complex -- Defined in ‘Data.Complex’
instance Control.Monad.Fix.MonadFix Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance Control.Monad.Fix.MonadFix Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance Control.Monad.Fix.MonadFix Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance [safe] Control.Monad.IO.Class.MonadIO GHC.Types.IO -- Defined in ‘Control.Monad.IO.Class’
instance [safe] Control.Monad.Zip.MonadZip Data.Ord.Down -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Data.Monoid.First -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Data.Functor.Identity.Identity -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Data.Monoid.Last -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip [] -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip GHC.Maybe.Maybe -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip GHC.Base.NonEmpty -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip GHC.Generics.Par1 -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip Solo -- Defined in ‘Control.Monad.Zip’
instance [safe] Control.Monad.Zip.MonadZip base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Control.Monad.Zip’
instance Control.Monad.Zip.MonadZip Data.Complex.Complex -- Defined in ‘Data.Complex’
instance [safe] Data.Bifoldable.Bifoldable Data.Either.Either -- Defined in ‘Data.Bifoldable’
instance [safe] Data.Bifoldable.Bifoldable (,) -- Defined in ‘Data.Bifoldable’
instance [safe] forall x. Data.Bifoldable.Bifoldable ((,,) x) -- Defined in ‘Data.Bifoldable’
instance [safe] forall x y. Data.Bifoldable.Bifoldable ((,,,) x y) -- Defined in ‘Data.Bifoldable’
instance [safe] forall x y z. Data.Bifoldable.Bifoldable ((,,,,) x y z) -- Defined in ‘Data.Bifoldable’
instance [safe] forall x y z w. Data.Bifoldable.Bifoldable ((,,,,,) x y z w) -- Defined in ‘Data.Bifoldable’
instance [safe] forall x y z w v. Data.Bifoldable.Bifoldable ((,,,,,,) x y z w v) -- Defined in ‘Data.Bifoldable’
instance Data.Bifoldable.Bifoldable Data.Semigroup.Arg -- Defined in ‘Data.Semigroup’
instance [safe] Data.Bifoldable1.Bifoldable1 Data.Semigroup.Arg -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 Data.Either.Either -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifoldable1.Bifoldable1 (,) -- Defined in ‘Data.Bifoldable1’
instance [safe] forall x. Data.Bifoldable1.Bifoldable1 ((,,) x) -- Defined in ‘Data.Bifoldable1’
instance [safe] forall x y. Data.Bifoldable1.Bifoldable1 ((,,,) x y) -- Defined in ‘Data.Bifoldable1’
instance [safe] forall x y z. Data.Bifoldable1.Bifoldable1 ((,,,,) x y z) -- Defined in ‘Data.Bifoldable1’
instance [safe] Data.Bifunctor.Bifunctor Data.Either.Either -- Defined in ‘Data.Bifunctor’
instance [safe] Data.Bifunctor.Bifunctor (,) -- Defined in ‘Data.Bifunctor’
instance [safe] forall x1. Data.Bifunctor.Bifunctor ((,,) x1) -- Defined in ‘Data.Bifunctor’
instance [safe] forall x1 x2. Data.Bifunctor.Bifunctor ((,,,) x1 x2) -- Defined in ‘Data.Bifunctor’
instance [safe] forall x1 x2 x3. Data.Bifunctor.Bifunctor ((,,,,) x1 x2 x3) -- Defined in ‘Data.Bifunctor’
instance [safe] forall x1 x2 x3 x4. Data.Bifunctor.Bifunctor ((,,,,,) x1 x2 x3 x4) -- Defined in ‘Data.Bifunctor’
instance [safe] forall x1 x2 x3 x4 x5. Data.Bifunctor.Bifunctor ((,,,,,,) x1 x2 x3 x4 x5) -- Defined in ‘Data.Bifunctor’
instance Data.Bifunctor.Bifunctor Data.Semigroup.Arg -- Defined in ‘Data.Semigroup’
instance Data.Bitraversable.Bitraversable Data.Either.Either -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable (,) -- Defined in ‘Data.Bitraversable’
instance forall x. Data.Bitraversable.Bitraversable ((,,) x) -- Defined in ‘Data.Bitraversable’
instance forall x y. Data.Bitraversable.Bitraversable ((,,,) x y) -- Defined in ‘Data.Bitraversable’
instance forall x y z. Data.Bitraversable.Bitraversable ((,,,,) x y z) -- Defined in ‘Data.Bitraversable’
instance forall x y z w. Data.Bitraversable.Bitraversable ((,,,,,) x y z w) -- Defined in ‘Data.Bitraversable’
instance forall x y z w v. Data.Bitraversable.Bitraversable ((,,,,,,) x y z w v) -- Defined in ‘Data.Bitraversable’
instance Data.Bitraversable.Bitraversable Data.Semigroup.Arg -- Defined in ‘Data.Semigroup’
instance Data.Data.Data Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance forall s. base-4.18.0.0:Data.Typeable.Internal.Typeable s => Data.Data.Data (Data.Array.Byte.MutableByteArray s) -- Defined in ‘Data.Array.Byte’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall i j (a :: i) (b :: j). (base-4.18.0.0:Data.Typeable.Internal.Typeable i, base-4.18.0.0:Data.Typeable.Internal.Typeable j, base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable b, a ~~ b) => Data.Data.Data (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Data’
instance Data.Data.Data base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘Data.Data’
instance Data.Data.Data base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘Data.Data’
instance forall a b. (Data.Data.Data a, Data.Data.Data b, GHC.Ix.Ix a) => Data.Data.Data (GHC.Arr.Array a b) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.Associativity -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Bool -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Char -- Defined in ‘Data.Data’
instance forall k a (b :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable k, Data.Data.Data a, base-4.18.0.0:Data.Typeable.Internal.Typeable b) => Data.Data.Data (Data.Functor.Const.Const a b) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.DecidedStrictness -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Double -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Ord.Down a) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘Data.Data’
instance forall a b. (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Either.Either a b) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Monoid.First a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.Fixity -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Float -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Int -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int16 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int32 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int64 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Int.Int8 -- Defined in ‘Data.Data’
instance Data.Data.Data Foreign.Ptr.IntPtr -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Num.Integer.Integer -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Monoid.Last a) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data [a] -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (GHC.Maybe.Maybe a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Num.Natural.Natural -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (GHC.Base.NonEmpty a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Ordering -- Defined in ‘Data.Data’
instance forall p. Data.Data.Data p => Data.Data.Data (GHC.Generics.Par1 p) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (GHC.Ptr.Ptr a) -- Defined in ‘Data.Data’
instance forall a. (Data.Data.Data a, GHC.Real.Integral a) => Data.Data.Data (GHC.Real.Ratio a) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Solo a) -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.SourceStrictness -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Generics.SourceUnpackedness -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘Data.Data’
instance forall a b. (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (a, b) -- Defined in ‘Data.Data’
instance forall a b c. (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c) => Data.Data.Data (a, b, c) -- Defined in ‘Data.Data’
instance forall a b c d. (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d) => Data.Data.Data (a, b, c, d) -- Defined in ‘Data.Data’
instance forall a b c d e. (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e) => Data.Data.Data (a, b, c, d, e) -- Defined in ‘Data.Data’
instance forall a b c d e f. (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f) => Data.Data.Data (a, b, c, d, e, f) -- Defined in ‘Data.Data’
instance forall a b c d e f g. (Data.Data.Data a, Data.Data.Data b, Data.Data.Data c, Data.Data.Data d, Data.Data.Data e, Data.Data.Data f, Data.Data.Data g) => Data.Data.Data (a, b, c, d, e, f, g) -- Defined in ‘Data.Data’
instance Data.Data.Data () -- Defined in ‘Data.Data’
instance Data.Data.Data Data.Version.Version -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Base.Void -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Types.Word -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word16 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word32 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word64 -- Defined in ‘Data.Data’
instance Data.Data.Data GHC.Word.Word8 -- Defined in ‘Data.Data’
instance Data.Data.Data Foreign.Ptr.WordPtr -- Defined in ‘Data.Data’
instance forall (a :: * -> * -> *) b c. (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable b, base-4.18.0.0:Data.Typeable.Internal.Typeable c, Data.Data.Data (a b c)) => Data.Data.Data (Control.Applicative.WrappedArrow a b c) -- Defined in ‘Data.Data’
instance forall (m :: * -> *) a. (base-4.18.0.0:Data.Typeable.Internal.Typeable m, base-4.18.0.0:Data.Typeable.Internal.Typeable a, Data.Data.Data (m a)) => Data.Data.Data (Control.Applicative.WrappedMonad m a) -- Defined in ‘Data.Data’
instance forall a. Data.Data.Data a => Data.Data.Data (Control.Applicative.ZipList a) -- Defined in ‘Data.Data’
instance forall k (a :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable k, base-4.18.0.0:Data.Typeable.Internal.Typeable a) => Data.Data.Data (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable f, base-4.18.0.0:Data.Typeable.Internal.Typeable g, base-4.18.0.0:Data.Typeable.Internal.Typeable k1, base-4.18.0.0:Data.Typeable.Internal.Typeable k2, Data.Data.Data (f (g a))) => Data.Data.Data (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable f, base-4.18.0.0:Data.Typeable.Internal.Typeable g, base-4.18.0.0:Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). (base-4.18.0.0:Data.Typeable.Internal.Typeable a, base-4.18.0.0:Data.Typeable.Internal.Typeable f, base-4.18.0.0:Data.Typeable.Internal.Typeable g, base-4.18.0.0:Data.Typeable.Internal.Typeable k, Data.Data.Data (f a), Data.Data.Data (g a)) => Data.Data.Data (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance forall a b. (Data.Data.Data a, Data.Data.Data b) => Data.Data.Data (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. Data.Data.Data a => Data.Data.Data (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. Data.Data.Data m => Data.Data.Data (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance Data.Data.Data GHC.Exts.SpecConstrAnnotation -- Defined in ‘GHC.Exts’
instance forall (n :: GHC.TypeNats.Nat). GHC.TypeNats.KnownNat n => Data.Fixed.HasResolution n -- Defined in ‘Data.Fixed’
instance Data.Foldable.Foldable Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance forall i. Data.Foldable.Foldable (GHC.Arr.Array i) -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Ord.Down -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Data.Foldable’
instance forall a. Data.Foldable.Foldable (Data.Either.Either a) -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Monoid.First -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Monoid.Last -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable [] -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable GHC.Maybe.Maybe -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable GHC.Base.NonEmpty -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable GHC.Generics.Par1 -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Solo -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Data.Foldable’
instance forall a. Data.Foldable.Foldable ((,) a) -- Defined in ‘Data.Foldable’
instance Data.Foldable.Foldable Data.Complex.Complex -- Defined in ‘Data.Complex’
instance Data.Foldable.Foldable Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance forall a. Data.Foldable.Foldable (Data.Semigroup.Arg a) -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance Data.Foldable.Foldable Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance Data.Foldable1.Foldable1 Data.Complex.Complex -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Ord.Down -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.First -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Functor.Identity.Identity -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.Last -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.Max -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Data.Semigroup.Min -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 GHC.Base.NonEmpty -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 GHC.Generics.Par1 -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 Solo -- Defined in ‘Data.Foldable1’
instance Data.Foldable1.Foldable1 base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Data.Foldable1’
instance forall a. Data.Foldable1.Foldable1 ((,) a) -- Defined in ‘Data.Foldable1’
instance [safe] Data.Functor.Classes.Eq1 Data.Complex.Complex -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Classes.Eq a, GHC.Classes.Eq b) => Data.Functor.Classes.Eq1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b c. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => Data.Functor.Classes.Eq1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Eq2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Classes.Eq a => Data.Functor.Classes.Eq2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Classes.Eq a, GHC.Classes.Eq b) => Data.Functor.Classes.Eq2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Classes.Ord a, GHC.Classes.Ord b) => Data.Functor.Classes.Ord1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b c. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => Data.Functor.Classes.Ord1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Ord2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Classes.Ord a => Data.Functor.Classes.Ord2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Classes.Ord a, GHC.Classes.Ord b) => Data.Functor.Classes.Ord2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Data.Complex.Complex -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Read.Read a => Data.Functor.Classes.Read1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Read.Read a => Data.Functor.Classes.Read1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Read.Read a, GHC.Read.Read b) => Data.Functor.Classes.Read1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b c. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c) => Data.Functor.Classes.Read1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Read2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Read.Read a => Data.Functor.Classes.Read2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Read.Read a, GHC.Read.Read b) => Data.Functor.Classes.Read2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Data.Complex.Complex -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Data.Ord.Down -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.Either.Either a) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 [] -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 GHC.Maybe.Maybe -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 GHC.Base.NonEmpty -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show1 Solo -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Show.Show a => Data.Functor.Classes.Show1 ((,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Show.Show a, GHC.Show.Show b) => Data.Functor.Classes.Show1 ((,,) a b) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b c. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => Data.Functor.Classes.Show1 ((,,,) a b c) -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show2 Data.Either.Either -- Defined in ‘Data.Functor.Classes’
instance [safe] Data.Functor.Classes.Show2 (,) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a. GHC.Show.Show a => Data.Functor.Classes.Show2 ((,,) a) -- Defined in ‘Data.Functor.Classes’
instance [safe] forall a b. (GHC.Show.Show a, GHC.Show.Show b) => Data.Functor.Classes.Show2 ((,,,) a b) -- Defined in ‘Data.Functor.Classes’
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Comparison -- Defined in ‘Data.Functor.Contravariant’
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Equivalence -- Defined in ‘Data.Functor.Contravariant’
instance forall a. Data.Functor.Contravariant.Contravariant (Data.Functor.Contravariant.Op a) -- Defined in ‘Data.Functor.Contravariant’
instance Data.Functor.Contravariant.Contravariant Data.Functor.Contravariant.Predicate -- Defined in ‘Data.Functor.Contravariant’
instance forall a k (b :: k). Data.String.IsString a => Data.String.IsString (Data.Functor.Const.Const a b) -- Defined in ‘Data.String’
instance forall a. Data.String.IsString a => Data.String.IsString (Data.Functor.Identity.Identity a) -- Defined in ‘Data.String’
instance forall a. (a ~ GHC.Types.Char) => Data.String.IsString [a] -- Defined in ‘Data.String’
instance forall i. GHC.Ix.Ix i => Data.Traversable.Traversable (GHC.Arr.Array i) -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Ord.Down -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘Data.Traversable’
instance forall a. Data.Traversable.Traversable (Data.Either.Either a) -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Monoid.First -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Functor.Identity.Identity -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Monoid.Last -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable [] -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable GHC.Maybe.Maybe -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable GHC.Base.NonEmpty -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable GHC.Generics.Par1 -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Solo -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘Data.Traversable’
instance forall a. Data.Traversable.Traversable ((,) a) -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Control.Applicative.ZipList -- Defined in ‘Data.Traversable’
instance Data.Traversable.Traversable Data.Complex.Complex -- Defined in ‘Data.Complex’
instance forall a. Data.Traversable.Traversable (Data.Semigroup.Arg a) -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance Data.Traversable.Traversable Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance Data.Type.Coercion.TestCoercion GHC.TypeLits.SChar -- Defined in ‘GHC.TypeLits’
instance Data.Type.Coercion.TestCoercion GHC.TypeLits.SSymbol -- Defined in ‘GHC.TypeLits’
instance Data.Type.Coercion.TestCoercion GHC.TypeNats.SNat -- Defined in ‘GHC.TypeNats’
instance forall k (a :: k). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~:) a) -- Defined in ‘Data.Type.Coercion’
instance forall k1 k (a :: k1). Data.Type.Coercion.TestCoercion ((Data.Type.Equality.:~~:) a) -- Defined in ‘Data.Type.Coercion’
instance forall k (a :: k). Data.Type.Coercion.TestCoercion (Data.Type.Coercion.Coercion a) -- Defined in ‘Data.Type.Coercion’
instance Data.Type.Equality.TestEquality GHC.TypeLits.SChar -- Defined in ‘GHC.TypeLits’
instance Data.Type.Equality.TestEquality GHC.TypeLits.SSymbol -- Defined in ‘GHC.TypeLits’
instance Data.Type.Equality.TestEquality GHC.TypeNats.SNat -- Defined in ‘GHC.TypeNats’
instance forall k (a :: k). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~:) a) -- Defined in ‘Data.Type.Equality’
instance forall k1 k (a :: k1). Data.Type.Equality.TestEquality ((Data.Type.Equality.:~~:) a) -- Defined in ‘Data.Type.Equality’
instance forall k. Data.Type.Equality.TestEquality base-4.18.0.0:Data.Typeable.Internal.TypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1). Data.Type.Equality.TestEquality f => Data.Type.Equality.TestEquality (Data.Functor.Compose.Compose f g) -- Defined in ‘Data.Functor.Compose’
instance forall a k (b :: k). Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall a. Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance forall a. Foreign.Storable.Storable a => Foreign.Storable.Storable (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance Foreign.Storable.Storable Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance Foreign.Storable.Storable Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance Foreign.Storable.Storable GHC.Types.Bool -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Char -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Double -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Fingerprint.Type.Fingerprint -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Float -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (GHC.Ptr.FunPtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Int -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int16 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int32 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int64 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Int.Int8 -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (GHC.Ptr.Ptr a) -- Defined in ‘Foreign.Storable’
instance forall a. (Foreign.Storable.Storable a, GHC.Real.Integral a) => Foreign.Storable.Storable (GHC.Real.Ratio a) -- Defined in ‘Foreign.Storable’
instance forall a. Foreign.Storable.Storable (GHC.Stable.StablePtr a) -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable () -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Types.Word -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word16 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word32 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word64 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.Word.Word8 -- Defined in ‘Foreign.Storable’
instance Foreign.Storable.Storable GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance forall (a :: * -> * -> *) b. (Control.Arrow.ArrowZero a, Control.Arrow.ArrowPlus a) => GHC.Base.Alternative (Control.Applicative.WrappedArrow a b) -- Defined in ‘Control.Applicative’
instance forall (m :: * -> *). GHC.Base.MonadPlus m => GHC.Base.Alternative (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Alternative Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.Alternative GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Alternative [] -- Defined in ‘GHC.Base’
instance GHC.Base.Alternative GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance forall (a :: * -> * -> *). Control.Arrow.ArrowPlus a => GHC.Base.Alternative (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *) a. GHC.Base.Alternative m => GHC.Base.Alternative (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Alternative GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Alternative Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Alternative Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance forall (a :: * -> * -> *) b. Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Applicative.WrappedArrow a b) -- Defined in ‘Control.Applicative’
instance forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Applicative (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Applicative Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.Applicative GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative [] -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative GHC.Base.NonEmpty -- Defined in ‘GHC.Base’
instance GHC.Base.Applicative Solo -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Monoid a => GHC.Base.Applicative ((,) a) -- Defined in ‘GHC.Base’
instance forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Applicative ((,,) a b) -- Defined in ‘GHC.Base’
instance forall a b c. (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Applicative ((,,,) a b c) -- Defined in ‘GHC.Base’
instance forall (a :: * -> * -> *). Control.Arrow.Arrow a => GHC.Base.Applicative (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *) a. GHC.Base.Applicative m => GHC.Base.Applicative (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Applicative GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance forall s. GHC.Base.Applicative (GHC.ST.ST s) -- Defined in ‘GHC.ST’
instance forall s. GHC.Base.Applicative (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance GHC.Base.Applicative Data.Complex.Complex -- Defined in ‘Data.Complex’
instance forall e. GHC.Base.Applicative (Data.Either.Either e) -- Defined in ‘Data.Either’
instance GHC.Base.Applicative Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance GHC.Base.Applicative Data.Monoid.First -- Defined in ‘Data.Monoid’
instance GHC.Base.Applicative Data.Monoid.Last -- Defined in ‘Data.Monoid’
instance GHC.Base.Applicative base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Applicative base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Applicative base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Applicative Data.Ord.Down -- Defined in ‘Data.Ord’
instance GHC.Base.Applicative Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance GHC.Base.Applicative GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance GHC.Base.Applicative GHC.Generics.Par1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Applicative Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Applicative Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance forall (a :: * -> * -> *) b. Control.Arrow.Arrow a => GHC.Base.Functor (Control.Applicative.WrappedArrow a b) -- Defined in ‘Control.Applicative’
instance forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Functor (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Functor Control.Applicative.ZipList -- Defined in ‘Control.Applicative’
instance GHC.Base.Functor GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Functor [] -- Defined in ‘GHC.Base’
instance GHC.Base.Functor GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance GHC.Base.Functor GHC.Base.NonEmpty -- Defined in ‘GHC.Base’
instance GHC.Base.Functor Solo -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Functor ((,) a) -- Defined in ‘GHC.Base’
instance forall a b. GHC.Base.Functor ((,,) a b) -- Defined in ‘GHC.Base’
instance forall a b c. GHC.Base.Functor ((,,,) a b c) -- Defined in ‘GHC.Base’
instance forall a b c d. GHC.Base.Functor ((,,,,) a b c d) -- Defined in ‘GHC.Base’
instance forall a b c d e. GHC.Base.Functor ((,,,,,) a b c d e) -- Defined in ‘GHC.Base’
instance forall a b c d e f. GHC.Base.Functor ((,,,,,,) a b c d e f) -- Defined in ‘GHC.Base’
instance forall (a :: * -> * -> *). Control.Arrow.Arrow a => GHC.Base.Functor (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *) a. GHC.Base.Functor m => GHC.Base.Functor (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Functor GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.Functor Control.Exception.Handler -- Defined in ‘Control.Exception’
instance forall s. GHC.Base.Functor (GHC.ST.ST s) -- Defined in ‘GHC.ST’
instance forall s. GHC.Base.Functor (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance GHC.Base.Functor Data.Complex.Complex -- Defined in ‘Data.Complex’
instance forall a. GHC.Base.Functor (Data.Either.Either a) -- Defined in ‘Data.Either’
instance GHC.Base.Functor Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance GHC.Base.Functor Data.Monoid.First -- Defined in ‘Data.Monoid’
instance GHC.Base.Functor Data.Monoid.Last -- Defined in ‘Data.Monoid’
instance GHC.Base.Functor base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Functor base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Functor base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Functor Data.Ord.Down -- Defined in ‘Data.Ord’
instance forall a. GHC.Base.Functor (Data.Semigroup.Arg a) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance GHC.Base.Functor Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance forall i. GHC.Base.Functor (GHC.Arr.Array i) -- Defined in ‘GHC.Arr’
instance GHC.Base.Functor GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance GHC.Base.Functor GHC.Generics.Par1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Functor Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Functor Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance [safe] GHC.Base.Functor System.Console.GetOpt.ArgDescr -- Defined in ‘System.Console.GetOpt’
instance [safe] GHC.Base.Functor System.Console.GetOpt.ArgOrder -- Defined in ‘System.Console.GetOpt’
instance [safe] GHC.Base.Functor System.Console.GetOpt.OptDescr -- Defined in ‘System.Console.GetOpt’
instance GHC.Base.Functor Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance forall (m :: * -> *). GHC.Base.Monad m => GHC.Base.Monad (Control.Applicative.WrappedMonad m) -- Defined in ‘Control.Applicative’
instance GHC.Base.Monad GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.Monad [] -- Defined in ‘GHC.Base’
instance GHC.Base.Monad GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance GHC.Base.Monad GHC.Base.NonEmpty -- Defined in ‘GHC.Base’
instance GHC.Base.Monad Solo -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monad ((,) a) -- Defined in ‘GHC.Base’
instance forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monad ((,,) a b) -- Defined in ‘GHC.Base’
instance forall a b c. (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monad ((,,,) a b c) -- Defined in ‘GHC.Base’
instance forall (a :: * -> * -> *). Control.Arrow.ArrowApply a => GHC.Base.Monad (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *) a. GHC.Base.Monad m => GHC.Base.Monad (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.Monad GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance forall s. GHC.Base.Monad (GHC.ST.ST s) -- Defined in ‘GHC.ST’
instance forall s. GHC.Base.Monad (base-4.18.0.0:Control.Monad.ST.Lazy.Imp.ST s) -- Defined in ‘base-4.18.0.0:Control.Monad.ST.Lazy.Imp’
instance GHC.Base.Monad Data.Complex.Complex -- Defined in ‘Data.Complex’
instance forall e. GHC.Base.Monad (Data.Either.Either e) -- Defined in ‘Data.Either’
instance GHC.Base.Monad Data.Functor.Identity.Identity -- Defined in ‘Data.Functor.Identity’
instance GHC.Base.Monad Data.Monoid.First -- Defined in ‘Data.Monoid’
instance GHC.Base.Monad Data.Monoid.Last -- Defined in ‘Data.Monoid’
instance GHC.Base.Monad base-4.18.0.0:Data.Semigroup.Internal.Dual -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monad base-4.18.0.0:Data.Semigroup.Internal.Product -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monad base-4.18.0.0:Data.Semigroup.Internal.Sum -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monad Data.Ord.Down -- Defined in ‘Data.Ord’
instance GHC.Base.Monad Data.Semigroup.First -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad Data.Semigroup.Last -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad Data.Semigroup.Max -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad Data.Semigroup.Min -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monad GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance GHC.Base.Monad GHC.Generics.Par1 -- Defined in ‘GHC.Generics’
instance GHC.Base.Monad Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Monad Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.Monad Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance GHC.Base.MonadPlus GHC.Types.IO -- Defined in ‘GHC.Base’
instance GHC.Base.MonadPlus [] -- Defined in ‘GHC.Base’
instance GHC.Base.MonadPlus GHC.Maybe.Maybe -- Defined in ‘GHC.Base’
instance forall (a :: * -> * -> *). (Control.Arrow.ArrowApply a, Control.Arrow.ArrowPlus a) => GHC.Base.MonadPlus (Control.Arrow.ArrowMonad a) -- Defined in ‘Control.Arrow’
instance forall (m :: * -> *) a. GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Arrow.Kleisli m a) -- Defined in ‘Control.Arrow’
instance GHC.Base.MonadPlus GHC.Conc.Sync.STM -- Defined in ‘GHC.Conc.Sync’
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.P -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadP.ReadP -- Defined in ‘Text.ParserCombinators.ReadP’
instance GHC.Base.MonadPlus Text.ParserCombinators.ReadPrec.ReadPrec -- Defined in ‘Text.ParserCombinators.ReadPrec’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Types.IO a) -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Monoid [a] -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Monoid (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Base’
instance GHC.Base.Monoid GHC.Types.Ordering -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (Solo a) -- Defined in ‘GHC.Base’
instance forall a b. (GHC.Base.Monoid a, GHC.Base.Monoid b) => GHC.Base.Monoid (a, b) -- Defined in ‘GHC.Base’
instance forall a b c. (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c) => GHC.Base.Monoid (a, b, c) -- Defined in ‘GHC.Base’
instance forall a b c d. (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c, GHC.Base.Monoid d) => GHC.Base.Monoid (a, b, c, d) -- Defined in ‘GHC.Base’
instance forall a b c d e. (GHC.Base.Monoid a, GHC.Base.Monoid b, GHC.Base.Monoid c, GHC.Base.Monoid d, GHC.Base.Monoid e) => GHC.Base.Monoid (a, b, c, d, e) -- Defined in ‘GHC.Base’
instance GHC.Base.Monoid () -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.Conc.Sync.STM a) -- Defined in ‘GHC.Conc.Sync’
instance forall a s. GHC.Base.Monoid a => GHC.Base.Monoid (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
instance GHC.Base.Monoid Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance forall a. GHC.Bits.FiniteBits a => GHC.Base.Monoid (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.FiniteBits a => GHC.Base.Monoid (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Base.Monoid (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Base.Monoid (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance forall k (s :: k). GHC.Base.Monoid (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Base.Monoid (f (g a)) => GHC.Base.Monoid (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Base.Monoid (Data.Functor.Contravariant.Comparison a) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Base.Monoid (Data.Functor.Contravariant.Equivalence a) -- Defined in ‘Data.Functor.Contravariant’
instance forall a b. GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Base.Monoid (Data.Functor.Contravariant.Predicate a) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Monoid (f a), GHC.Base.Monoid (g a)) => GHC.Base.Monoid (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance forall a. GHC.Base.Monoid (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Base.Monoid (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Base.Monoid base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Monoid base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Endo a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Base.Monoid (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Base.Monoid a => GHC.Base.Monoid (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. (GHC.Classes.Ord a, GHC.Enum.Bounded a) => GHC.Base.Monoid (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Base.Monoid m => GHC.Base.Monoid (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Monoid base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Monoid base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Monoid base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Monoid (f p), GHC.Base.Monoid (g p)) => GHC.Base.Monoid ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Monoid (f (g p)) => GHC.Base.Monoid ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance forall a. (GHC.Generics.Generic a, GHC.Base.Monoid (GHC.Generics.Rep a ())) => GHC.Base.Monoid (GHC.Generics.Generically a) -- Defined in ‘GHC.Generics’
instance forall k c i (p :: k). GHC.Base.Monoid c => GHC.Base.Monoid (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall p. GHC.Base.Monoid p => GHC.Base.Monoid (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Base.Monoid (f p) => GHC.Base.Monoid (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Base.Monoid (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Types.IO a) -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Semigroup [a] -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Semigroup (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup GHC.Types.Ordering -- Defined in ‘GHC.Base’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (Solo a) -- Defined in ‘GHC.Base’
instance forall a b. (GHC.Base.Semigroup a, GHC.Base.Semigroup b) => GHC.Base.Semigroup (a, b) -- Defined in ‘GHC.Base’
instance forall a b c. (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c) => GHC.Base.Semigroup (a, b, c) -- Defined in ‘GHC.Base’
instance forall a b c d. (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Semigroup d) => GHC.Base.Semigroup (a, b, c, d) -- Defined in ‘GHC.Base’
instance forall a b c d e. (GHC.Base.Semigroup a, GHC.Base.Semigroup b, GHC.Base.Semigroup c, GHC.Base.Semigroup d, GHC.Base.Semigroup e) => GHC.Base.Semigroup (a, b, c, d, e) -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup () -- Defined in ‘GHC.Base’
instance GHC.Base.Semigroup GHC.Base.Void -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.Conc.Sync.STM a) -- Defined in ‘GHC.Conc.Sync’
instance forall a s. GHC.Base.Semigroup a => GHC.Base.Semigroup (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
instance GHC.Base.Semigroup Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance forall a. GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.FiniteBits a => GHC.Base.Semigroup (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Base.Semigroup (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance forall k (s :: k). GHC.Base.Semigroup (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance forall a b. GHC.Base.Semigroup (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall b. GHC.Base.Semigroup (Data.Foldable1.FromMaybe b) -- Defined in ‘Data.Foldable1’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Foldable1.JoinWith a) -- Defined in ‘Data.Foldable1’
instance forall a. GHC.Base.Semigroup (Data.Foldable1.NonEmptyDList a) -- Defined in ‘Data.Foldable1’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Base.Semigroup (f (g a)) => GHC.Base.Semigroup (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Base.Semigroup (Data.Functor.Contravariant.Comparison a) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Base.Semigroup (Data.Functor.Contravariant.Equivalence a) -- Defined in ‘Data.Functor.Contravariant’
instance forall a b. GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Base.Semigroup (Data.Functor.Contravariant.Predicate a) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Base.Semigroup (f a), GHC.Base.Semigroup (g a)) => GHC.Base.Semigroup (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance forall a. GHC.Base.Semigroup (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Base.Semigroup (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Base.Semigroup base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Base.Semigroup base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Endo a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Base.Semigroup (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Base.Semigroup (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Base.Semigroup (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Base.Monoid m => GHC.Base.Semigroup (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance GHC.Base.Semigroup base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Semigroup base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Base.Semigroup base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance forall k (f :: k -> *) (p :: k) (g :: k -> *). (GHC.Base.Semigroup (f p), GHC.Base.Semigroup (g p)) => GHC.Base.Semigroup ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 k1 (f :: k2 -> *) (g :: k1 -> k2) (p :: k1). GHC.Base.Semigroup (f (g p)) => GHC.Base.Semigroup ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance forall a. (GHC.Generics.Generic a, GHC.Base.Semigroup (GHC.Generics.Rep a ())) => GHC.Base.Semigroup (GHC.Generics.Generically a) -- Defined in ‘GHC.Generics’
instance forall k c i (p :: k). GHC.Base.Semigroup c => GHC.Base.Semigroup (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k) i (c :: GHC.Generics.Meta). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall p. GHC.Base.Semigroup p => GHC.Base.Semigroup (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Base.Semigroup (f p) => GHC.Base.Semigroup (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Base.Semigroup (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance forall a k (b :: k). GHC.Bits.Bits a => GHC.Bits.Bits (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Bits.Bits (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Bits.Bits GHC.Types.Bool -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Types.Int -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Num.Integer.Integer -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Num.Natural.Natural -- Defined in ‘GHC.Bits’
instance GHC.Bits.Bits GHC.Types.Word -- Defined in ‘GHC.Bits’
instance forall a. GHC.Bits.Bits a => GHC.Bits.Bits (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Bits.Bits GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Bits.Bits GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall a. GHC.Bits.Bits a => GHC.Bits.Bits (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Bits.Bits GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Bits.Bits Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Bits.Bits Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a k (b :: k). GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Bits.FiniteBits GHC.Types.Bool -- Defined in ‘GHC.Bits’
instance GHC.Bits.FiniteBits GHC.Types.Int -- Defined in ‘GHC.Bits’
instance GHC.Bits.FiniteBits GHC.Types.Word -- Defined in ‘GHC.Bits’
instance forall a. GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Bits.FiniteBits GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Bits.FiniteBits GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall a. GHC.Bits.FiniteBits a => GHC.Bits.FiniteBits (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Bits.FiniteBits GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Bits.FiniteBits Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Bits.FiniteBits Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a k (b :: k). GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Bounded GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (a :: k) (b :: k). (a ~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). (a ~~ b) => GHC.Enum.Bounded (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (t :: k). GHC.Enum.Bounded (Data.Proxy.Proxy t) -- Defined in ‘Data.Proxy’
instance GHC.Enum.Bounded GHC.Types.Bool -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Char -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Int -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Levity -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Ordering -- Defined in ‘GHC.Enum’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Solo a) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i j. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i j k. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i j k l. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i j k l m. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i j k l m n. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m, GHC.Enum.Bounded n) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i j k l m n o. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i, GHC.Enum.Bounded j, GHC.Enum.Bounded k, GHC.Enum.Bounded l, GHC.Enum.Bounded m, GHC.Enum.Bounded n, GHC.Enum.Bounded o) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Enum’
instance forall a b. (GHC.Enum.Bounded a, GHC.Enum.Bounded b) => GHC.Enum.Bounded (a, b) -- Defined in ‘GHC.Enum’
instance forall a b c. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c) => GHC.Enum.Bounded (a, b, c) -- Defined in ‘GHC.Enum’
instance forall a b c d. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d) => GHC.Enum.Bounded (a, b, c, d) -- Defined in ‘GHC.Enum’
instance forall a b c d e. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e) => GHC.Enum.Bounded (a, b, c, d, e) -- Defined in ‘GHC.Enum’
instance forall a b c d e f. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f) => GHC.Enum.Bounded (a, b, c, d, e, f) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g) => GHC.Enum.Bounded (a, b, c, d, e, f, g) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Enum’
instance forall a b c d e f g h i. (GHC.Enum.Bounded a, GHC.Enum.Bounded b, GHC.Enum.Bounded c, GHC.Enum.Bounded d, GHC.Enum.Bounded e, GHC.Enum.Bounded f, GHC.Enum.Bounded g, GHC.Enum.Bounded h, GHC.Enum.Bounded i) => GHC.Enum.Bounded (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded () -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.VecCount -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.VecElem -- Defined in ‘GHC.Enum’
instance GHC.Enum.Bounded GHC.Types.Word -- Defined in ‘GHC.Enum’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Enum.Bounded (f (g a)) => GHC.Enum.Bounded (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Enum.Bounded GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Enum.Bounded base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Enum.Bounded base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Enum.Bounded m => GHC.Enum.Bounded (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). Coercible a b => GHC.Enum.Bounded (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance GHC.Enum.Bounded GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Enum.Bounded Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Enum.Bounded Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance [safe] GHC.Enum.Bounded GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Enum.Bounded GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Enum.Bounded GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Bounded GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Bounded GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall a k (b :: k). GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Enum.Enum GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (a :: k) (b :: k). (a ~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). (a ~~ b) => GHC.Enum.Enum (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Enum.Enum (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Enum.Enum GHC.Types.Bool -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Char -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Int -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Num.Integer.Integer -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Levity -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Num.Natural.Natural -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Ordering -- Defined in ‘GHC.Enum’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Solo a) -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum () -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.VecCount -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.VecElem -- Defined in ‘GHC.Enum’
instance GHC.Enum.Enum GHC.Types.Word -- Defined in ‘GHC.Enum’
instance forall k (a :: k). GHC.Enum.Enum (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Enum.Enum (f (g a)) => GHC.Enum.Enum (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Enum.Enum GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Enum.Enum GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Enum.Enum GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Enum.Enum GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall k (f :: k -> *) (a :: k). GHC.Enum.Enum (f a) => GHC.Enum.Enum (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. (GHC.Enum.Enum a, GHC.Enum.Bounded a, GHC.Classes.Eq a) => GHC.Enum.Enum (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Real.Integral a => GHC.Enum.Enum (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Enum.Enum a => GHC.Enum.Enum (Data.Semigroup.WrappedMonoid a) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). Coercible a b => GHC.Enum.Enum (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance GHC.Enum.Enum GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Enum.Enum Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Enum.Enum Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance [safe] GHC.Enum.Enum GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Enum.Enum GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Enum.Enum GHC.Types.Float -- Defined in ‘GHC.Float’
instance GHC.Enum.Enum GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Enum.Enum GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Enum.Enum GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Enum.Enum GHC.RTS.Flags.DoCostCentres -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.DoHeapProfile -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.DoTrace -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.GiveGCStats -- Defined in ‘GHC.RTS.Flags’
instance GHC.Enum.Enum GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance GHC.Exception.Type.Exception GHC.IO.Exception.AllocationLimitExceeded -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.AssertionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.BlockedIndefinitelyOnMVar -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.BlockedIndefinitelyOnSTM -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.CompactionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.Deadlock -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.FixIOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.IOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.IO.Exception.SomeAsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Exception.Type.Exception GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Exception.Type.Exception GHC.Exception.Type.SomeException -- Defined in ‘GHC.Exception.Type’
instance GHC.Exception.Type.Exception GHC.Base.Void -- Defined in ‘GHC.Exception.Type’
instance GHC.Exception.Type.Exception GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Exception.Type.Exception Control.Exception.Base.NestedAtomically -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMatchingContinuationPrompt -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.NoMethodError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.NonTermination -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.PatternMatchFail -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.RecConError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.RecSelError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.RecUpdError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Control.Exception.Base.TypeError -- Defined in ‘Control.Exception.Base’
instance GHC.Exception.Type.Exception Data.Dynamic.Dynamic -- Defined in ‘Data.Dynamic’
instance [safe] GHC.Exception.Type.Exception base-4.18.0.0:GHC.IO.Handle.Lock.Common.FileLockingNotSupported -- Defined in ‘base-4.18.0.0:GHC.IO.Handle.Lock.Common’
instance GHC.Exception.Type.Exception GHC.IOPort.IOPortException -- Defined in ‘GHC.IOPort’
instance [safe] GHC.Exception.Type.Exception System.Timeout.Timeout -- Defined in ‘System.Timeout’
instance forall a k (b :: k). GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Float.RealFloat a => GHC.Float.Floating (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall a b. GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Float.Floating a => GHC.Float.Floating (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance forall a. GHC.Float.Floating a => GHC.Float.Floating (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Float.Floating GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Float.Floating GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance forall a. GHC.Float.RealFloat a => GHC.Float.RealFloat (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Float.RealFloat GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Float.RealFloat GHC.Types.Float -- Defined in ‘GHC.Float’
instance GHC.GHCi.GHCiSandboxIO GHC.Types.IO -- Defined in ‘GHC.GHCi’
instance GHC.GHCi.GHCiSandboxIO GHC.GHCi.NoIO -- Defined in ‘GHC.GHCi’
instance forall (n :: GHC.Types.Symbol) (f :: GHC.Generics.FixityI) (r :: GHC.Types.Bool). (GHC.TypeLits.KnownSymbol n, GHC.Generics.SingI f, GHC.Generics.SingI r) => GHC.Generics.Constructor (GHC.Generics.MetaCons n f r) -- Defined in ‘GHC.Generics’
instance forall (n :: GHC.Types.Symbol) (m :: GHC.Types.Symbol) (p :: GHC.Types.Symbol) (nt :: GHC.Types.Bool). (GHC.TypeLits.KnownSymbol n, GHC.TypeLits.KnownSymbol m, GHC.TypeLits.KnownSymbol p, GHC.Generics.SingI nt) => GHC.Generics.Datatype (GHC.Generics.MetaData n m p nt) -- Defined in ‘GHC.Generics’
instance forall (a :: * -> * -> *) b c. GHC.Generics.Generic (Control.Applicative.WrappedArrow a b c) -- Defined in ‘Control.Applicative’
instance forall (m :: * -> *) a. GHC.Generics.Generic (Control.Applicative.WrappedMonad m a) -- Defined in ‘Control.Applicative’
instance forall a. GHC.Generics.Generic (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall a k (b :: k). GHC.Generics.Generic (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall (m :: * -> *) a b. GHC.Generics.Generic (Control.Arrow.Kleisli m a b) -- Defined in ‘Control.Arrow’
instance GHC.Generics.Generic GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance forall a. GHC.Generics.Generic (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k1 (f :: k1 -> *) k2 (g :: k2 -> k1) (a :: k2). GHC.Generics.Generic (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Generics.Generic (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (g :: k -> *) (a :: k). GHC.Generics.Generic (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Generics.Generic (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Generics.Generic (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Generics.Generic base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Generics.Generic base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Endo a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Generics.Generic (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a b. GHC.Generics.Generic (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Generics.Generic (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Generics.Generic (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Generics.Generic (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Generics.Generic (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Generics.Generic (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance [safe] GHC.Generics.Generic Data.Version.Version -- Defined in ‘Data.Version’
instance [safe] GHC.Generics.Generic GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). GHC.Generics.Generic ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Generics.Generic ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Types.Bool -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.Generic (Data.Ord.Down a) -- Defined in ‘GHC.Generics’
instance forall a b. GHC.Generics.Generic (Data.Either.Either a b) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Generics.Generic (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.Generic [a] -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.Generic (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.Generic (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Types.Ordering -- Defined in ‘GHC.Generics’
instance forall p. GHC.Generics.Generic (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (t :: k). GHC.Generics.Generic (Data.Proxy.Proxy t) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Generics.Generic (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.Generic (Solo a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Stack.Types.SrcLoc -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i j. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i j k. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i j k l. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i j k l m. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i j k l m n. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i j k l m n o. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Generics’
instance forall a b. GHC.Generics.Generic (a, b) -- Defined in ‘GHC.Generics’
instance forall a b c. GHC.Generics.Generic (a, b, c) -- Defined in ‘GHC.Generics’
instance forall a b c d. GHC.Generics.Generic (a, b, c, d) -- Defined in ‘GHC.Generics’
instance forall a b c d e. GHC.Generics.Generic (a, b, c, d, e) -- Defined in ‘GHC.Generics’
instance forall a b c d e f. GHC.Generics.Generic (a, b, c, d, e, f) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g. GHC.Generics.Generic (a, b, c, d, e, f, g) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h. GHC.Generics.Generic (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Generics’
instance forall a b c d e f g h i. GHC.Generics.Generic (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec (GHC.Ptr.Ptr ()) p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic () -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Generics.Generic (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.Base.Void -- Defined in ‘GHC.Generics’
instance GHC.Generics.Generic GHC.RTS.Flags.CCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.ConcFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DebugFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DoCostCentres -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DoHeapProfile -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.DoTrace -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.GCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.GiveGCStats -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.MiscFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.ParFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.ProfFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.RTSFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.TickyFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.RTS.Flags.TraceFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Generics.Generic GHC.Stats.GCDetails -- Defined in ‘GHC.Stats’
instance GHC.Generics.Generic GHC.Stats.RTSStats -- Defined in ‘GHC.Stats’
instance forall k a. GHC.Generics.Generic1 (Data.Functor.Const.Const a) -- Defined in ‘Data.Functor.Const’
instance [safe] forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Product.Product f g) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (Data.Functor.Sum.Sum f g) -- Defined in ‘Data.Functor.Sum’
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.Monoid.Ap f) -- Defined in ‘Data.Monoid’
instance forall k (f :: k -> *). GHC.Generics.Generic1 (base-4.18.0.0:Data.Semigroup.Internal.Alt f) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:*: g) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *). GHC.Generics.Generic1 (f GHC.Generics.:+: g) -- Defined in ‘GHC.Generics’
instance forall k i c. GHC.Generics.Generic1 (GHC.Generics.K1 i c) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.M1 i c f) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 Data.Proxy.Proxy -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *). GHC.Generics.Generic1 (GHC.Generics.Rec1 f) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 GHC.Generics.U1 -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 (GHC.Generics.URec (GHC.Ptr.Ptr ())) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Char) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Double) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Float) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Int) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 (GHC.Generics.URec GHC.Types.Word) -- Defined in ‘GHC.Generics’
instance forall k. GHC.Generics.Generic1 GHC.Generics.V1 -- Defined in ‘GHC.Generics’
instance forall (mn :: GHC.Maybe.Maybe GHC.Types.Symbol) (su :: GHC.Generics.SourceUnpackedness) (ss :: GHC.Generics.SourceStrictness) (ds :: GHC.Generics.DecidedStrictness). (GHC.Generics.SingI mn, GHC.Generics.SingI su, GHC.Generics.SingI ss, GHC.Generics.SingI ds) => GHC.Generics.Selector (GHC.Generics.MetaSel mn su ss ds) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.LeftAssociative -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.NotAssociative -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.RightAssociative -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Types.False -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Types.True -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.DecidedLazy -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.DecidedStrict -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.DecidedUnpack -- Defined in ‘GHC.Generics’
instance forall (a :: GHC.Generics.Associativity) (n :: GHC.TypeNats.Nat). (GHC.Generics.SingI a, GHC.TypeNats.KnownNat n) => GHC.Generics.SingI (GHC.Generics.InfixI a n) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.PrefixI -- Defined in ‘GHC.Generics’
instance forall a1 (a2 :: a1). GHC.Generics.SingI a2 => GHC.Generics.SingI (GHC.Maybe.Just a2) -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.SingI GHC.Maybe.Nothing -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.NoSourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceLazy -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceStrict -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.NoSourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceNoUnpack -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingI GHC.Generics.SourceUnpack -- Defined in ‘GHC.Generics’
instance forall (a :: GHC.Types.Symbol). GHC.TypeLits.KnownSymbol a => GHC.Generics.SingI a -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Types.Bool -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.FixityI -- Defined in ‘GHC.Generics’
instance forall a. GHC.Generics.SingKind a => GHC.Generics.SingKind (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Generics.SingKind GHC.Types.Symbol -- Defined in ‘GHC.Generics’
instance GHC.IO.BufferedIO.BufferedIO GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.IO.Device.IODevice GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.IO.Device.RawIO GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.IsList.IsList Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.IsList.IsList GHC.Stack.Types.CallStack -- Defined in ‘GHC.IsList’
instance forall a. GHC.IsList.IsList [a] -- Defined in ‘GHC.IsList’
instance forall a. GHC.IsList.IsList (GHC.Base.NonEmpty a) -- Defined in ‘GHC.IsList’
instance GHC.IsList.IsList Data.Version.Version -- Defined in ‘GHC.IsList’
instance forall a. GHC.IsList.IsList (Control.Applicative.ZipList a) -- Defined in ‘GHC.IsList’
instance forall a k (b :: k). GHC.Ix.Ix a => GHC.Ix.Ix (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Ix.Ix GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (s :: k). GHC.Ix.Ix (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance forall a. GHC.Ix.Ix a => GHC.Ix.Ix (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Ix.Ix GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Ix.Ix GHC.Types.Bool -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Char -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Int -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Num.Integer.Integer -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Num.Natural.Natural -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Ordering -- Defined in ‘GHC.Ix’
instance forall a. GHC.Ix.Ix a => GHC.Ix.Ix (Solo a) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9 aA. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB aC. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB aC aD. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB aC aD aE. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD, GHC.Ix.Ix aE) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9 aA aB aC aD aE aF. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9, GHC.Ix.Ix aA, GHC.Ix.Ix aB, GHC.Ix.Ix aC, GHC.Ix.Ix aD, GHC.Ix.Ix aE, GHC.Ix.Ix aF) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9, aA, aB, aC, aD, aE, aF) -- Defined in ‘GHC.Ix’
instance forall a b. (GHC.Ix.Ix a, GHC.Ix.Ix b) => GHC.Ix.Ix (a, b) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3) => GHC.Ix.Ix (a1, a2, a3) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4) => GHC.Ix.Ix (a1, a2, a3, a4) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5) => GHC.Ix.Ix (a1, a2, a3, a4, a5) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8) -- Defined in ‘GHC.Ix’
instance forall a1 a2 a3 a4 a5 a6 a7 a8 a9. (GHC.Ix.Ix a1, GHC.Ix.Ix a2, GHC.Ix.Ix a3, GHC.Ix.Ix a4, GHC.Ix.Ix a5, GHC.Ix.Ix a6, GHC.Ix.Ix a7, GHC.Ix.Ix a8, GHC.Ix.Ix a9) => GHC.Ix.Ix (a1, a2, a3, a4, a5, a6, a7, a8, a9) -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix () -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Base.Void -- Defined in ‘GHC.Ix’
instance GHC.Ix.Ix GHC.Types.Word -- Defined in ‘GHC.Ix’
instance forall a. GHC.Ix.Ix a => GHC.Ix.Ix (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Ix.Ix GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Ix.Ix Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Ix.Ix Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Ix.Ix GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance GHC.Ix.Ix GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Ix.Ix GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance forall a k (b :: k). GHC.Num.Num a => GHC.Num.Num (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Float.RealFloat a => GHC.Num.Num (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Num.Num (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Num.Num (f (g a)) => GHC.Num.Num (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a b. GHC.Num.Num a => GHC.Num.Num (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Num.Num a => GHC.Num.Num (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Num.Num GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Num.Num GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Num.Num GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Num.Num GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Num.Num (f a) => GHC.Num.Num (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Num.Num (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Num.Num (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Num.Num a => GHC.Num.Num (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Real.Integral a => GHC.Num.Num (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Num.Num a => GHC.Num.Num (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance GHC.Num.Num GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Num.Num GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Num.Num GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Num.Num GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Num.Num Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Num.Num Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Num.Num GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Num.Num GHC.Types.Float -- Defined in ‘GHC.Float’
instance GHC.Num.Num GHC.Types.Int -- Defined in ‘GHC.Num’
instance GHC.Num.Num GHC.Num.Integer.Integer -- Defined in ‘GHC.Num’
instance GHC.Num.Num GHC.Num.Natural.Natural -- Defined in ‘GHC.Num’
instance GHC.Num.Num GHC.Types.Word -- Defined in ‘GHC.Num’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall k a (b :: k). GHC.Read.Read a => GHC.Read.Read (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Read.Read GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance forall a b. (GHC.Ix.Ix a, GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (GHC.Arr.Array a b) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Bool -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Char -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Double -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Float -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Int -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Num.Integer.Integer -- Defined in ‘GHC.Read’
instance GHC.Read.Read Text.Read.Lex.Lexeme -- Defined in ‘GHC.Read’
instance forall a. GHC.Read.Read a => GHC.Read.Read [a] -- Defined in ‘GHC.Read’
instance forall a. GHC.Read.Read a => GHC.Read.Read (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Num.Natural.Natural -- Defined in ‘GHC.Read’
instance forall a. GHC.Read.Read a => GHC.Read.Read (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Ordering -- Defined in ‘GHC.Read’
instance forall a. (GHC.Real.Integral a, GHC.Read.Read a) => GHC.Read.Read (GHC.Real.Ratio a) -- Defined in ‘GHC.Read’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Solo a) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i j. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i j k. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i j k l. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i j k l m. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i j k l m n. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m, GHC.Read.Read n) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i j k l m n o. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i, GHC.Read.Read j, GHC.Read.Read k, GHC.Read.Read l, GHC.Read.Read m, GHC.Read.Read n, GHC.Read.Read o) => GHC.Read.Read (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Read’
instance forall a b. (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (a, b) -- Defined in ‘GHC.Read’
instance forall a b c. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c) => GHC.Read.Read (a, b, c) -- Defined in ‘GHC.Read’
instance forall a b c d. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d) => GHC.Read.Read (a, b, c, d) -- Defined in ‘GHC.Read’
instance forall a b c d e. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e) => GHC.Read.Read (a, b, c, d, e) -- Defined in ‘GHC.Read’
instance forall a b c d e f. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f) => GHC.Read.Read (a, b, c, d, e, f) -- Defined in ‘GHC.Read’
instance forall a b c d e f g. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g) => GHC.Read.Read (a, b, c, d, e, f, g) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h) => GHC.Read.Read (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Read’
instance forall a b c d e f g h i. (GHC.Read.Read a, GHC.Read.Read b, GHC.Read.Read c, GHC.Read.Read d, GHC.Read.Read e, GHC.Read.Read f, GHC.Read.Read g, GHC.Read.Read h, GHC.Read.Read i) => GHC.Read.Read (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Read’
instance GHC.Read.Read () -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Base.Void -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Types.Word -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word16 -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word32 -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word64 -- Defined in ‘GHC.Read’
instance GHC.Read.Read GHC.Word.Word8 -- Defined in ‘GHC.Read’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k (a :: k) (b :: k). (a ~ b) => GHC.Read.Read (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). (a ~~ b) => GHC.Read.Read (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (t :: k). GHC.Read.Read (Data.Proxy.Proxy t) -- Defined in ‘Data.Proxy’
instance forall a b. (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Read.Read (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Read.Read (f (g a)) => GHC.Read.Read (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Read.Read (f a), GHC.Read.Read (g a)) => GHC.Read.Read (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Read.Read (f a), GHC.Read.Read (g a)) => GHC.Read.Read (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Read.Read GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Read.Read GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Read.Read GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Read.Read GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Read.Read base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Read.Read (f a) => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Read.Read base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Read.Read a => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Read.Read a => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Read.Read a => GHC.Read.Read (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a b. (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Read.Read a => GHC.Read.Read (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Read.Read m => GHC.Read.Read (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). Coercible a b => GHC.Read.Read (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance [safe] GHC.Read.Read Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Read.Read Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Read.Read Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance [safe] GHC.Read.Read GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Read.Read (f p), GHC.Read.Read (g p)) => GHC.Read.Read ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Read.Read (f (g p)) => GHC.Read.Read ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Read.Read c => GHC.Read.Read (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall p. GHC.Read.Read p => GHC.Read.Read (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Read.Read (f p) => GHC.Read.Read (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Read.Read (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Read.Read GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Read.Read GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Read.Read GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Read.Read GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Read.Read GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Read.Read GHC.Stats.GCDetails -- Defined in ‘GHC.Stats’
instance GHC.Read.Read GHC.Stats.RTSStats -- Defined in ‘GHC.Stats’
instance GHC.Read.Read GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Read.Read GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance GHC.Read.Read GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance forall a k (b :: k). GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Float.RealFloat a => GHC.Real.Fractional (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.Fractional (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall a b. GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Contravariant.Op a b) -- Defined in ‘Data.Functor.Contravariant’
instance forall a. GHC.Real.Fractional a => GHC.Real.Fractional (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance forall a. GHC.Real.Fractional a => GHC.Real.Fractional (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Real.Integral a => GHC.Real.Fractional (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Real.Fractional GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Real.Fractional GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Real.Integral (f (g a)) => GHC.Real.Integral (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Real.Integral a => GHC.Real.Integral (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Real.Integral GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance GHC.Real.Integral GHC.Types.Int -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Num.Integer.Integer -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Num.Natural.Natural -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Types.Word -- Defined in ‘GHC.Real’
instance GHC.Real.Integral GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Real.Integral Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Real.Integral Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a k (b :: k). GHC.Real.Real a => GHC.Real.Real (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.Real (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Real.Real (f (g a)) => GHC.Real.Real (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Real.Real a => GHC.Real.Real (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance GHC.Real.Real GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Real.Real GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Real.Real GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Real.Real GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall a. GHC.Real.Real a => GHC.Real.Real (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Real.Real GHC.Types.Int -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Num.Integer.Integer -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Num.Natural.Natural -- Defined in ‘GHC.Real’
instance forall a. GHC.Real.Integral a => GHC.Real.Real (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Types.Word -- Defined in ‘GHC.Real’
instance GHC.Real.Real GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Real.Real GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Real.Real GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Real.Real GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance GHC.Real.Real Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Real.Real Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Real.Real GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Real.Real GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a k (b :: k). GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Real.RealFrac (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall a. GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance forall a. GHC.Real.RealFrac a => GHC.Real.RealFrac (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Real.Integral a => GHC.Real.RealFrac (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance GHC.Real.RealFrac GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Real.RealFrac GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall k a (b :: k). GHC.Show.Show a => GHC.Show.Show (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Show.Show GHC.Conc.Sync.BlockReason -- Defined in ‘GHC.Conc.Sync’
instance GHC.Show.Show GHC.Conc.Sync.ThreadId -- Defined in ‘GHC.Conc.Sync’
instance GHC.Show.Show GHC.Conc.Sync.ThreadStatus -- Defined in ‘GHC.Conc.Sync’
instance GHC.Show.Show GHC.IO.Exception.AllocationLimitExceeded -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.AssertionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.BlockedIndefinitelyOnMVar -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.BlockedIndefinitelyOnSTM -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.CompactionFailed -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.Deadlock -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.FixIOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.IOErrorType -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.IOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.IO.Exception.SomeAsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Show.Show GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Show.Show GHC.Exception.Type.SomeException -- Defined in ‘GHC.Exception.Type’
instance GHC.Show.Show GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Show.Show GHC.IO.MaskingState -- Defined in ‘GHC.IO’
instance GHC.Show.Show Control.Exception.Base.NestedAtomically -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.NoMatchingContinuationPrompt -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.NoMethodError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.NonTermination -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.PatternMatchFail -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.RecConError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.RecSelError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.RecUpdError -- Defined in ‘Control.Exception.Base’
instance GHC.Show.Show Control.Exception.Base.TypeError -- Defined in ‘Control.Exception.Base’
instance forall s a. GHC.Show.Show (GHC.ST.ST s a) -- Defined in ‘GHC.ST’
instance GHC.Show.Show Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Show.Show GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance GHC.Show.Show GHC.Types.Bool -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Stack.Types.CallStack -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Char -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Int -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Num.Integer.Integer -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.KindRep -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Levity -- Defined in ‘GHC.Show’
instance forall a. GHC.Show.Show a => GHC.Show.Show [a] -- Defined in ‘GHC.Show’
instance forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Module -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Num.Natural.Natural -- Defined in ‘GHC.Show’
instance forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Ordering -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.RuntimeRep -- Defined in ‘GHC.Show’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Solo a) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Stack.Types.SrcLoc -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.TrName -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i j. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i j k. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i j k l. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i j k l m. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i j k l m n. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i j k l m n o. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i, GHC.Show.Show j, GHC.Show.Show k, GHC.Show.Show l, GHC.Show.Show m, GHC.Show.Show n, GHC.Show.Show o) => GHC.Show.Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Show’
instance forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a, b) -- Defined in ‘GHC.Show’
instance forall a b c. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (a, b, c) -- Defined in ‘GHC.Show’
instance forall a b c d. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d) => GHC.Show.Show (a, b, c, d) -- Defined in ‘GHC.Show’
instance forall a b c d e. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e) => GHC.Show.Show (a, b, c, d, e) -- Defined in ‘GHC.Show’
instance forall a b c d e f. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f) => GHC.Show.Show (a, b, c, d, e, f) -- Defined in ‘GHC.Show’
instance forall a b c d e f g. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g) => GHC.Show.Show (a, b, c, d, e, f, g) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h) => GHC.Show.Show (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Show’
instance forall a b c d e f g h i. (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c, GHC.Show.Show d, GHC.Show.Show e, GHC.Show.Show f, GHC.Show.Show g, GHC.Show.Show h, GHC.Show.Show i) => GHC.Show.Show (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.TyCon -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.TypeLitSort -- Defined in ‘GHC.Show’
instance GHC.Show.Show () -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.VecCount -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.VecElem -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Base.Void -- Defined in ‘GHC.Show’
instance GHC.Show.Show GHC.Types.Word -- Defined in ‘GHC.Show’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance GHC.Show.Show Data.Data.Constr -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.ConstrRep -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.DataRep -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.DataType -- Defined in ‘Data.Data’
instance GHC.Show.Show Data.Data.Fixity -- Defined in ‘Data.Data’
instance forall k (a :: k) (b :: k). GHC.Show.Show (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Show.Show (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Show.Show (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Show.Show base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k (a :: k). GHC.Show.Show (base-4.18.0.0:Data.Typeable.Internal.TypeRep a) -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance GHC.Show.Show Data.Dynamic.Dynamic -- Defined in ‘Data.Dynamic’
instance forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). Data.Fixed.HasResolution a => GHC.Show.Show (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Show.Show (f (g a)) => GHC.Show.Show (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Show.Show (f a), GHC.Show.Show (g a)) => GHC.Show.Show (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Show.Show GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Show.Show GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Show.Show GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Show.Show GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Show.Show base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Show.Show (f a) => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Show.Show base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Show.Show a => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Show.Show a => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Show.Show a => GHC.Show.Show (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance GHC.Show.Show GHC.Real.FractionalExponentBase -- Defined in ‘GHC.Real’
instance forall a. GHC.Show.Show a => GHC.Show.Show (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance forall a b. (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Show.Show a => GHC.Show.Show (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Show.Show m => GHC.Show.Show (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance forall k (a :: k) (b :: k). GHC.Show.Show (Data.Type.Ord.OrderingI a b) -- Defined in ‘Data.Type.Ord’
instance [safe] GHC.Show.Show Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Show.Show GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Show.Show GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Show.Show GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Show.Show GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance forall a. GHC.Show.Show (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance forall a. GHC.Show.Show (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
instance forall a. GHC.Show.Show (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
instance GHC.Show.Show Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Show.Show Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a. GHC.Show.Show (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.C.ConstPtr’
instance forall a b. (GHC.Ix.Ix a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (GHC.Arr.Array a b) -- Defined in ‘GHC.Arr’
instance [safe] GHC.Show.Show GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Internal.Types.Timeout -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Manager.FdKey -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.Manager.State -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Show.Show base-4.18.0.0:GHC.Event.TimerManager.State -- Defined in ‘base-4.18.0.0:GHC.Event.TimerManager’
instance GHC.Show.Show GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Fingerprint.Type’
instance GHC.Show.Show GHC.Types.Double -- Defined in ‘GHC.Float’
instance GHC.Show.Show GHC.Types.Float -- Defined in ‘GHC.Float’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Show.Show (f p), GHC.Show.Show (g p)) => GHC.Show.Show ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Show.Show (f (g p)) => GHC.Show.Show ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Show.Show c => GHC.Show.Show (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall p. GHC.Show.Show p => GHC.Show.Show (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Show.Show (f p) => GHC.Show.Show (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Show.Show (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Show.Show GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Show.Show GHC.IO.Encoding.Types.CodingProgress -- Defined in ‘GHC.IO.Encoding.Types’
instance GHC.Show.Show GHC.IO.Encoding.Types.TextEncoding -- Defined in ‘GHC.IO.Encoding.Types’
instance GHC.Show.Show GHC.IO.Encoding.Failure.CodingFailureMode -- Defined in ‘GHC.IO.Encoding.Failure’
instance GHC.Show.Show GHC.IO.FD.FD -- Defined in ‘GHC.IO.FD’
instance GHC.Show.Show GHC.IO.Handle.HandlePosn -- Defined in ‘GHC.IO.Handle’
instance GHC.Show.Show GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.Handle -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.HandleType -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Show.Show GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance [safe] GHC.Show.Show base-4.18.0.0:GHC.IO.Handle.Lock.Common.FileLockingNotSupported -- Defined in ‘base-4.18.0.0:GHC.IO.Handle.Lock.Common’
instance GHC.Show.Show GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Show.Show GHC.RTS.Flags.CCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.ConcFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DebugFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DoCostCentres -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DoHeapProfile -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.DoTrace -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.GCFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.GiveGCStats -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.MiscFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.ParFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.ProfFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.RTSFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.TickyFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.RTS.Flags.TraceFlags -- Defined in ‘GHC.RTS.Flags’
instance GHC.Show.Show GHC.IOPort.IOPortException -- Defined in ‘GHC.IOPort’
instance GHC.Show.Show GHC.InfoProv.InfoProv -- Defined in ‘GHC.InfoProv’
instance GHC.Show.Show GHC.Stack.CloneStack.StackEntry -- Defined in ‘GHC.Stack.CloneStack’
instance GHC.Show.Show GHC.StaticPtr.StaticPtrInfo -- Defined in ‘GHC.StaticPtr’
instance GHC.Show.Show GHC.Stats.GCDetails -- Defined in ‘GHC.Stats’
instance GHC.Show.Show GHC.Stats.RTSStats -- Defined in ‘GHC.Stats’
instance forall (c :: GHC.Types.Char). GHC.Show.Show (GHC.TypeLits.SChar c) -- Defined in ‘GHC.TypeLits’
instance forall (s :: GHC.Types.Symbol). GHC.Show.Show (GHC.TypeLits.SSymbol s) -- Defined in ‘GHC.TypeLits’
instance GHC.Show.Show GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Show.Show GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance forall (n :: GHC.TypeNats.Nat). GHC.Show.Show (GHC.TypeNats.SNat n) -- Defined in ‘GHC.TypeNats’
instance GHC.Show.Show GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance [safe] GHC.Show.Show System.Timeout.Timeout -- Defined in ‘System.Timeout’
instance GHC.Show.Show Text.Read.Lex.Lexeme -- Defined in ‘Text.Read.Lex’
instance GHC.Show.Show Text.Read.Lex.Number -- Defined in ‘Text.Read.Lex’
instance GHC.StaticPtr.IsStatic GHC.StaticPtr.StaticPtr -- Defined in ‘GHC.StaticPtr’
instance [safe] forall a. (a ~ ()) => Text.Printf.HPrintfType (GHC.Types.IO a) -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.IsChar GHC.Types.Char -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Char -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Double -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Float -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Int -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int16 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int32 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int64 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Int.Int8 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Num.Integer.Integer -- Defined in ‘Text.Printf’
instance [safe] forall c. Text.Printf.IsChar c => Text.Printf.PrintfArg [c] -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Num.Natural.Natural -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Types.Word -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word16 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word32 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word64 -- Defined in ‘Text.Printf’
instance [safe] Text.Printf.PrintfArg GHC.Word.Word8 -- Defined in ‘Text.Printf’
instance [safe] forall a. (a ~ ()) => Text.Printf.PrintfType (GHC.Types.IO a) -- Defined in ‘Text.Printf’
instance [safe] forall c. Text.Printf.IsChar c => Text.Printf.PrintfType [c] -- Defined in ‘Text.Printf’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Base’
instance GHC.Classes.Eq GHC.Base.Void -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance forall a. GHC.Classes.Eq (Control.Concurrent.Chan.Chan a) -- Defined in ‘Control.Concurrent.Chan’
instance forall a. GHC.Classes.Eq (GHC.MVar.MVar a) -- Defined in ‘GHC.MVar’
instance GHC.Classes.Eq GHC.Conc.Sync.BlockReason -- Defined in ‘GHC.Conc.Sync’
instance forall a. GHC.Classes.Eq (GHC.Conc.Sync.TVar a) -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadId -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq GHC.Conc.Sync.ThreadStatus -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Eq GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.IOErrorType -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.IO.Exception.IOException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Eq GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Classes.Eq GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Classes.Eq GHC.IO.MaskingState -- Defined in ‘GHC.IO’
instance GHC.Classes.Eq Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance forall s. GHC.Classes.Eq (Data.Array.Byte.MutableByteArray s) -- Defined in ‘Data.Array.Byte’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.And a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Iff a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Ior a) -- Defined in ‘Data.Bits’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Bits.Xor a) -- Defined in ‘Data.Bits’
instance GHC.Classes.Eq GHC.Types.Bool -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Char -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Double -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Float -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Int -- Defined in ‘GHC.Classes’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq [a] -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Module -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Ordering -- Defined in ‘GHC.Classes’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Solo a) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.TrName -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l m. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l m n. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l m n o. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i, GHC.Classes.Eq j, GHC.Classes.Eq k, GHC.Classes.Eq l, GHC.Classes.Eq m, GHC.Classes.Eq n, GHC.Classes.Eq o) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Classes’
instance forall a b. (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a, b) -- Defined in ‘GHC.Classes’
instance forall a b c. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (a, b, c) -- Defined in ‘GHC.Classes’
instance forall a b c d. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d) => GHC.Classes.Eq (a, b, c, d) -- Defined in ‘GHC.Classes’
instance forall a b c d e. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e) => GHC.Classes.Eq (a, b, c, d, e) -- Defined in ‘GHC.Classes’
instance forall a b c d e f. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f) => GHC.Classes.Eq (a, b, c, d, e, f) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g) => GHC.Classes.Eq (a, b, c, d, e, f, g) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h) => GHC.Classes.Eq (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i. (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c, GHC.Classes.Eq d, GHC.Classes.Eq e, GHC.Classes.Eq f, GHC.Classes.Eq g, GHC.Classes.Eq h, GHC.Classes.Eq i) => GHC.Classes.Eq (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.TyCon -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq () -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Types.Word -- Defined in ‘GHC.Classes’
instance GHC.Classes.Eq GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Complex.Complex a) -- Defined in ‘Data.Complex’
instance GHC.Classes.Eq Data.Data.Constr -- Defined in ‘Data.Data’
instance GHC.Classes.Eq Data.Data.ConstrRep -- Defined in ‘Data.Data’
instance GHC.Classes.Eq Data.Data.DataRep -- Defined in ‘Data.Data’
instance GHC.Classes.Eq Data.Data.Fixity -- Defined in ‘Data.Data’
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Eq (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Classes.Eq (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Classes.Eq base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k (a :: k). GHC.Classes.Eq (base-4.18.0.0:Data.Typeable.Internal.TypeRep a) -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall a b. (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). GHC.Classes.Eq (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Classes.Eq (f (g a)) => GHC.Classes.Eq (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Eq (f a), GHC.Classes.Eq (g a)) => GHC.Classes.Eq (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance forall a. GHC.Classes.Eq (GHC.IORef.IORef a) -- Defined in ‘GHC.IORef’
instance GHC.Classes.Eq GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Classes.Eq GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Maybe’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Eq base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Eq (f a) => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Eq base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance forall s a. GHC.Classes.Eq (GHC.STRef.STRef s a) -- Defined in ‘GHC.STRef’
instance forall a b. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Eq a => GHC.Classes.Eq (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Classes.Eq m => GHC.Classes.Eq (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance forall k (a :: k) (b :: k). GHC.Classes.Eq (Data.Type.Ord.OrderingI a b) -- Defined in ‘Data.Type.Ord’
instance GHC.Classes.Eq Data.Unique.Unique -- Defined in ‘Data.Unique’
instance [safe] GHC.Classes.Eq Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Classes.Eq GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Classes.Eq GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance forall a. GHC.Classes.Eq (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance forall a. GHC.Classes.Eq (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
instance forall a. GHC.Classes.Eq (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
instance GHC.Classes.Eq Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Classes.Eq Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a. GHC.Classes.Eq (GHC.Stable.StablePtr a) -- Defined in ‘GHC.Stable’
instance GHC.Classes.Eq Foreign.C.Error.Errno -- Defined in ‘Foreign.C.Error’
instance forall a. GHC.Classes.Eq (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.C.ConstPtr’
instance forall i e. (GHC.Ix.Ix i, GHC.Classes.Eq e) => GHC.Classes.Eq (GHC.Arr.Array i e) -- Defined in ‘GHC.Arr’
instance forall s i e. GHC.Classes.Eq (GHC.Arr.STArray s i e) -- Defined in ‘GHC.Arr’
instance [safe] GHC.Classes.Eq GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Internal.Types.Event -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Internal.Types.EventLifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Internal.Types.Lifetime -- Defined in ‘base-4.18.0.0:GHC.Event.Internal.Types’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Manager.FdKey -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.Manager.State -- Defined in ‘base-4.18.0.0:GHC.Event.Manager’
instance GHC.Classes.Eq GHC.Event.TimeOut.TimeoutKey -- Defined in ‘GHC.Event.TimeOut’
instance GHC.Classes.Eq base-4.18.0.0:GHC.Event.TimerManager.State -- Defined in ‘base-4.18.0.0:GHC.Event.TimerManager’
instance GHC.Classes.Eq GHC.Stack.Types.SrcLoc -- Defined in ‘GHC.Stack.Types’
instance GHC.Classes.Eq GHC.Exts.SpecConstrAnnotation -- Defined in ‘GHC.Exts’
instance GHC.Classes.Eq GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Fingerprint.Type’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Eq (f p), GHC.Classes.Eq (g p)) => GHC.Classes.Eq ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Eq (f (g p)) => GHC.Classes.Eq ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (a :: k). (GHC.Generics.Generic1 f, GHC.Classes.Eq (GHC.Generics.Rep1 f a)) => GHC.Classes.Eq (GHC.Generics.Generically1 f a) -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Classes.Eq c => GHC.Classes.Eq (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall p. GHC.Classes.Eq p => GHC.Classes.Eq (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Eq (f p) => GHC.Classes.Eq (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec (GHC.Ptr.Ptr ()) p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Eq (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Eq GHC.IO.Buffer.BufferState -- Defined in ‘GHC.IO.Buffer’
instance GHC.Classes.Eq GHC.IO.Device.IODeviceType -- Defined in ‘GHC.IO.Device’
instance GHC.Classes.Eq GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Classes.Eq GHC.IO.Encoding.Types.CodingProgress -- Defined in ‘GHC.IO.Encoding.Types’
instance GHC.Classes.Eq GHC.IO.Handle.HandlePosn -- Defined in ‘GHC.IO.Handle’
instance GHC.Classes.Eq GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.Handle.Types.Handle -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Eq GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Classes.Eq GHC.RTS.Flags.IoSubSystem -- Defined in ‘GHC.RTS.Flags’
instance forall i e. GHC.Classes.Eq (GHC.IOArray.IOArray i e) -- Defined in ‘GHC.IOArray’
instance forall a. GHC.Classes.Eq (GHC.IOPort.IOPort a) -- Defined in ‘GHC.IOPort’
instance GHC.Classes.Eq GHC.InfoProv.InfoProv -- Defined in ‘GHC.InfoProv’
instance GHC.Classes.Eq GHC.Num.Integer.Integer -- Defined in ‘GHC.Num.Integer’
instance GHC.Classes.Eq GHC.Num.BigNat.BigNat -- Defined in ‘GHC.Num.BigNat’
instance GHC.Classes.Eq GHC.Num.Natural.Natural -- Defined in ‘GHC.Num.Natural’
instance forall a. GHC.Classes.Eq (GHC.StableName.StableName a) -- Defined in ‘GHC.StableName’
instance GHC.Classes.Eq GHC.Stack.CloneStack.StackEntry -- Defined in ‘GHC.Stack.CloneStack’
instance forall (c :: GHC.Types.Char). GHC.Classes.Eq (GHC.TypeLits.SChar c) -- Defined in ‘GHC.TypeLits’
instance forall (s :: GHC.Types.Symbol). GHC.Classes.Eq (GHC.TypeLits.SSymbol s) -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Eq GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Eq GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance forall (n :: GHC.TypeNats.Nat). GHC.Classes.Eq (GHC.TypeNats.SNat n) -- Defined in ‘GHC.TypeNats’
instance GHC.Classes.Eq GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
instance [safe] GHC.Classes.Eq System.Timeout.Timeout -- Defined in ‘System.Timeout’
instance GHC.Classes.Eq Text.Read.Lex.Lexeme -- Defined in ‘Text.Read.Lex’
instance GHC.Classes.Eq Text.Read.Lex.Number -- Defined in ‘Text.Read.Lex’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Control.Applicative.ZipList a) -- Defined in ‘Control.Applicative’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Base.NonEmpty a) -- Defined in ‘GHC.Base’
instance GHC.Classes.Ord GHC.Base.Void -- Defined in ‘GHC.Base’
instance forall a k (b :: k). GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Const.Const a b) -- Defined in ‘Data.Functor.Const’
instance GHC.Classes.Ord GHC.Conc.Sync.BlockReason -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadId -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Ord GHC.Conc.Sync.ThreadStatus -- Defined in ‘GHC.Conc.Sync’
instance GHC.Classes.Ord GHC.IO.Exception.ArrayException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Ord GHC.IO.Exception.AsyncException -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Ord GHC.IO.Exception.ExitCode -- Defined in ‘GHC.IO.Exception’
instance GHC.Classes.Ord GHC.Exception.Type.ArithException -- Defined in ‘GHC.Exception.Type’
instance GHC.Classes.Ord GHC.Exception.ErrorCall -- Defined in ‘GHC.Exception’
instance GHC.Classes.Ord Data.Array.Byte.ByteArray -- Defined in ‘Data.Array.Byte’
instance GHC.Classes.Ord GHC.Types.Bool -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Char -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Double -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Float -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Int -- Defined in ‘GHC.Classes’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord [a] -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Ordering -- Defined in ‘GHC.Classes’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Solo a) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l m. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l m n. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i j k l m n o. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i, GHC.Classes.Ord j, GHC.Classes.Ord k, GHC.Classes.Ord l, GHC.Classes.Ord m, GHC.Classes.Ord n, GHC.Classes.Ord o) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) -- Defined in ‘GHC.Classes’
instance forall a b. (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a, b) -- Defined in ‘GHC.Classes’
instance forall a b c. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => GHC.Classes.Ord (a, b, c) -- Defined in ‘GHC.Classes’
instance forall a b c d. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d) => GHC.Classes.Ord (a, b, c, d) -- Defined in ‘GHC.Classes’
instance forall a b c d e. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e) => GHC.Classes.Ord (a, b, c, d, e) -- Defined in ‘GHC.Classes’
instance forall a b c d e f. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f) => GHC.Classes.Ord (a, b, c, d, e, f) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g) => GHC.Classes.Ord (a, b, c, d, e, f, g) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h) => GHC.Classes.Ord (a, b, c, d, e, f, g, h) -- Defined in ‘GHC.Classes’
instance forall a b c d e f g h i. (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c, GHC.Classes.Ord d, GHC.Classes.Ord e, GHC.Classes.Ord f, GHC.Classes.Ord g, GHC.Classes.Ord h, GHC.Classes.Ord i) => GHC.Classes.Ord (a, b, c, d, e, f, g, h, i) -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.TyCon -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord () -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Types.Word -- Defined in ‘GHC.Classes’
instance GHC.Classes.Ord GHC.Unicode.GeneralCategory -- Defined in ‘GHC.Unicode’
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (a Data.Type.Equality.:~: b) -- Defined in ‘Data.Type.Equality’
instance forall k1 k2 (a :: k1) (b :: k2). GHC.Classes.Ord (a Data.Type.Equality.:~~: b) -- Defined in ‘Data.Type.Equality’
instance forall k (s :: k). GHC.Classes.Ord (Data.Proxy.Proxy s) -- Defined in ‘Data.Proxy’
instance GHC.Classes.Ord base-4.18.0.0:Data.Typeable.Internal.SomeTypeRep -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall k (a :: k). GHC.Classes.Ord (base-4.18.0.0:Data.Typeable.Internal.TypeRep a) -- Defined in ‘base-4.18.0.0:Data.Typeable.Internal’
instance forall a b. (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Either.Either a b) -- Defined in ‘Data.Either’
instance forall k (a :: k). GHC.Classes.Ord (Data.Fixed.Fixed a) -- Defined in ‘Data.Fixed’
instance forall k1 k2 (f :: k1 -> *) (g :: k2 -> k1) (a :: k2). GHC.Classes.Ord (f (g a)) => GHC.Classes.Ord (Data.Functor.Compose.Compose f g a) -- Defined in ‘Data.Functor.Compose’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Functor.Identity.Identity a) -- Defined in ‘Data.Functor.Identity’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Product.Product f g a) -- Defined in ‘Data.Functor.Product’
instance [safe] forall k (f :: k -> *) (a :: k) (g :: k -> *). (GHC.Classes.Ord (f a), GHC.Classes.Ord (g a)) => GHC.Classes.Ord (Data.Functor.Sum.Sum f g a) -- Defined in ‘Data.Functor.Sum’
instance GHC.Classes.Ord GHC.Int.Int16 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord GHC.Int.Int32 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord GHC.Int.Int64 -- Defined in ‘GHC.Int’
instance GHC.Classes.Ord GHC.Int.Int8 -- Defined in ‘GHC.Int’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (GHC.Maybe.Maybe a) -- Defined in ‘GHC.Maybe’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (Data.Monoid.Ap f a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.First a) -- Defined in ‘Data.Monoid’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Monoid.Last a) -- Defined in ‘Data.Monoid’
instance GHC.Classes.Ord base-4.18.0.0:Data.Semigroup.Internal.All -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall k (f :: k -> *) (a :: k). GHC.Classes.Ord (f a) => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Alt f a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance GHC.Classes.Ord base-4.18.0.0:Data.Semigroup.Internal.Any -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Dual a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Product a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (base-4.18.0.0:Data.Semigroup.Internal.Sum a) -- Defined in ‘base-4.18.0.0:Data.Semigroup.Internal’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Ord.Down a) -- Defined in ‘Data.Ord’
instance forall a. GHC.Real.Integral a => GHC.Classes.Ord (GHC.Real.Ratio a) -- Defined in ‘GHC.Real’
instance forall a b. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Arg a b) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.First a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Last a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Max a) -- Defined in ‘Data.Semigroup’
instance forall a. GHC.Classes.Ord a => GHC.Classes.Ord (Data.Semigroup.Min a) -- Defined in ‘Data.Semigroup’
instance forall m. GHC.Classes.Ord m => GHC.Classes.Ord (Data.Semigroup.WrappedMonoid m) -- Defined in ‘Data.Semigroup’
instance forall k (a :: k) (b :: k). GHC.Classes.Ord (Data.Type.Coercion.Coercion a b) -- Defined in ‘Data.Type.Coercion’
instance GHC.Classes.Ord Data.Unique.Unique -- Defined in ‘Data.Unique’
instance [safe] GHC.Classes.Ord Data.Version.Version -- Defined in ‘Data.Version’
instance GHC.Classes.Ord GHC.Word.Word16 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord GHC.Word.Word32 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord GHC.Word.Word64 -- Defined in ‘GHC.Word’
instance GHC.Classes.Ord GHC.Word.Word8 -- Defined in ‘GHC.Word’
instance forall a. GHC.Classes.Ord (GHC.ForeignPtr.ForeignPtr a) -- Defined in ‘GHC.ForeignPtr’
instance forall a. GHC.Classes.Ord (GHC.Ptr.FunPtr a) -- Defined in ‘GHC.Ptr’
instance forall a. GHC.Classes.Ord (GHC.Ptr.Ptr a) -- Defined in ‘GHC.Ptr’
instance GHC.Classes.Ord Foreign.Ptr.IntPtr -- Defined in ‘Foreign.Ptr’
instance GHC.Classes.Ord Foreign.Ptr.WordPtr -- Defined in ‘Foreign.Ptr’
instance forall a. GHC.Classes.Ord (Foreign.C.ConstPtr.ConstPtr a) -- Defined in ‘Foreign.C.ConstPtr’
instance forall i e. (GHC.Ix.Ix i, GHC.Classes.Ord e) => GHC.Classes.Ord (GHC.Arr.Array i e) -- Defined in ‘GHC.Arr’
instance [safe] GHC.Classes.Ord GHC.ByteOrder.ByteOrder -- Defined in ‘GHC.ByteOrder’
instance GHC.Classes.Ord GHC.Event.TimeOut.TimeoutKey -- Defined in ‘GHC.Event.TimeOut’
instance GHC.Classes.Ord GHC.Fingerprint.Type.Fingerprint -- Defined in ‘GHC.Fingerprint.Type’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:*:) f g p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (g :: k -> *) (p :: k). (GHC.Classes.Ord (f p), GHC.Classes.Ord (g p)) => GHC.Classes.Ord ((GHC.Generics.:+:) f g p) -- Defined in ‘GHC.Generics’
instance forall k2 (f :: k2 -> *) k1 (g :: k1 -> k2) (p :: k1). GHC.Classes.Ord (f (g p)) => GHC.Classes.Ord ((GHC.Generics.:.:) f g p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.Associativity -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.DecidedStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.Fixity -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (a :: k). (GHC.Generics.Generic1 f, GHC.Classes.Ord (GHC.Generics.Rep1 f a)) => GHC.Classes.Ord (GHC.Generics.Generically1 f a) -- Defined in ‘GHC.Generics’
instance forall i c k (p :: k). GHC.Classes.Ord c => GHC.Classes.Ord (GHC.Generics.K1 i c p) -- Defined in ‘GHC.Generics’
instance forall i (c :: GHC.Generics.Meta) k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.M1 i c f p) -- Defined in ‘GHC.Generics’
instance forall p. GHC.Classes.Ord p => GHC.Classes.Ord (GHC.Generics.Par1 p) -- Defined in ‘GHC.Generics’
instance forall k (f :: k -> *) (p :: k). GHC.Classes.Ord (f p) => GHC.Classes.Ord (GHC.Generics.Rec1 f p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.SourceStrictness -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.Generics.SourceUnpackedness -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.U1 p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec (GHC.Ptr.Ptr ()) p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Char p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Double p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Float p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Int p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.URec GHC.Types.Word p) -- Defined in ‘GHC.Generics’
instance forall k (p :: k). GHC.Classes.Ord (GHC.Generics.V1 p) -- Defined in ‘GHC.Generics’
instance GHC.Classes.Ord GHC.IO.Device.SeekMode -- Defined in ‘GHC.IO.Device’
instance GHC.Classes.Ord GHC.IO.Handle.Types.BufferMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Ord GHC.IO.Handle.Types.Newline -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Ord GHC.IO.Handle.Types.NewlineMode -- Defined in ‘GHC.IO.Handle.Types’
instance GHC.Classes.Ord GHC.IO.IOMode.IOMode -- Defined in ‘GHC.IO.IOMode’
instance GHC.Classes.Ord GHC.Num.Integer.Integer -- Defined in ‘GHC.Num.Integer’
instance GHC.Classes.Ord GHC.Num.BigNat.BigNat -- Defined in ‘GHC.Num.BigNat’
instance GHC.Classes.Ord GHC.Num.Natural.Natural -- Defined in ‘GHC.Num.Natural’
instance forall (c :: GHC.Types.Char). GHC.Classes.Ord (GHC.TypeLits.SChar c) -- Defined in ‘GHC.TypeLits’
instance forall (s :: GHC.Types.Symbol). GHC.Classes.Ord (GHC.TypeLits.SSymbol s) -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Ord GHC.TypeLits.SomeChar -- Defined in ‘GHC.TypeLits’
instance GHC.Classes.Ord GHC.TypeLits.SomeSymbol -- Defined in ‘GHC.TypeLits’
instance forall (n :: GHC.TypeNats.Nat). GHC.Classes.Ord (GHC.TypeNats.SNat n) -- Defined in ‘GHC.TypeNats’
instance GHC.Classes.Ord GHC.TypeNats.SomeNat -- Defined in ‘GHC.TypeNats’
